// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

RGraph = window.RGraph || { isRGraph: true };

// Module pattern
(function (win, doc, undefined) {
    var RG = RGraph,
        ua = navigator.userAgent,
        ma = Math;

    /**
     * Initialise the various objects
     */
    RG.Highlight = {};
    RG.Registry = {};
    RG.Registry.store = [];
    RG.Registry.store['chart.event.handlers'] = [];
    RG.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips
    RG.Background = {};
    RG.background = {};
    RG.objects = [];
    RG.Resizing = {};
    RG.events = [];
    RG.cursor = [];
    RG.Effects = RG.Effects || {};
    RG.cache = [];

    RG.ObjectRegistry = {};
    RG.ObjectRegistry.objects = {};
    RG.ObjectRegistry.objects.byUID = [];
    RG.ObjectRegistry.objects.byCanvasID = [];
    RG.OR = RG.ObjectRegistry;

    /**
     * Some "testData". The ua variable is navigator.userAgent (definedabove)
     */
    RG.PI = ma.PI;
    RG.HALFPI = RG.PI / 2;
    RG.TWOPI = RG.PI * 2;

    RG.ISFF = ua.indexOf('Firefox') != -1;
    RG.ISOPERA = ua.indexOf('Opera') != -1;
    RG.ISCHROME = ua.indexOf('Chrome') != -1;
    RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;
    RG.ISWEBKIT = ua.indexOf('WebKit') != -1;

    RG.ISIE = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;
    RG.ISIE6 = ua.indexOf('MSIE 6') > 0;
    RG.ISIE7 = ua.indexOf('MSIE 7') > 0;
    RG.ISIE8 = ua.indexOf('MSIE 8') > 0;
    RG.ISIE9 = ua.indexOf('MSIE 9') > 0;
    RG.ISIE10 = ua.indexOf('MSIE 10') > 0;
    RG.ISOLD = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here

    RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;
    RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;
    RG.ISIE9UP = RG.ISIE9 || RG.ISIE10UP;

    /**
     * Returns five values which are used as a nice scale
     *
     * @param  max int    The maximum value of the graph
     * @param  obj object The graph object
     * @return     array   An appropriate scale
     */
    RG.getScale = function (max, obj) {
        /**
         * Special case for 0
         */
        if (max == 0) {
            return ['0.2', '0.4', '0.6', '0.8', '1.0'];
        }

        var original_max = max;

        /**
         * Manually do decimals
         */
        if (max <= 1) {
            if (max > 0.5) {
                return [0.2, 0.4, 0.6, 0.8, Number(1).toFixed(1)];
            } else if (max >= 0.1) {
                return obj.Get('chart.scale.round') ? [0.2, 0.4, 0.6, 0.8, 1] : [0.1, 0.2, 0.3, 0.4, 0.5];
            } else {

                var tmp = max;
                var exp = 0;

                while (tmp < 1.01) {
                    exp += 1;
                    tmp *= 10;
                }

                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];

                if (max <= '5e-' + exp) {
                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];
                }

                return ret;
            }
        }

        // Take off any decimals
        if (String(max).indexOf('.') > 0) {
            max = String(max).replace(/\.\d+$/, '');
        }

        var interval = ma.pow(10, Number(String(Number(max)).length - 1));
        var topValue = interval;

        while (topValue < max) {
            topValue += interval / 2;
        }

        // Handles cases where the max is (for example) 50.5
        if (Number(original_max) > Number(topValue)) {
            topValue += interval / 2;
        }

        // Custom if the max is greater than 5 and less than 10
        if (max < 10) {
            topValue = Number(original_max) <= 5 ? 5 : 10;
        }

        /**
         * Added 02/11/2010 to create "nicer" scales
         */
        if (obj && typeof obj.Get('chart.scale.round') == 'boolean' && obj.Get('chart.scale.round')) {
            topValue = 10 * interval;
        }

        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];
    };

    /**
     * Returns an appropriate scale. The return value is actualy an object consisting of:
     *  scale.max
     *  scale.min
     *  scale.scale
     *
     * @param  obj object  The graph object
     * @param  prop object An object consisting of configuration properties
     * @return     object  An object containg scale information
     */
    RG.getScale2 = function (obj, opt) {
        var ca = obj.canvas,
            co = obj.context,
            prop = obj.properties,
            numlabels = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,
            units_pre = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',
            units_post = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',
            max = Number(opt['max']),
            min = typeof opt['min'] == 'number' ? opt['min'] : 0,
            strict = opt['strict'],
            decimals = Number(opt['scale.decimals']),
            // Sometimes the default is null
        point = opt['scale.point'],
            // Default is a string in all chart libraries so no need to cast it
        thousand = opt['scale.thousand'],
            // Default is a string in all chart libraries so no need to cast it
        original_max = max,
            round = opt['scale.round'],
            scale = { max: 1, labels: [], values: [] };

        /**
         * Special case for 0
         *
         * ** Must be first **
         */
        if (!max) {

            var max = 1;

            for (var i = 0; i < numlabels; ++i) {

                var label = (((max - min) / numlabels + min) * (i + 1)).toFixed(decimals);

                scale.labels.push(units_pre + label + units_post);
                scale.values.push(parseFloat(label));
            }

            /**
             * Manually do decimals
             */
        } else if (max <= 1 && !strict) {

            var arr = [1, 0.5, 0.10, 0.05, 0.010, 0.005, 0.0010, 0.0005, 0.00010, 0.00005, 0.000010, 0.000005, 0.0000010, 0.0000005, 0.00000010, 0.00000005, 0.000000010, 0.000000005, 0.0000000010, 0.0000000005, 0.00000000010, 0.00000000005, 0.000000000010, 0.000000000005, 0.0000000000010, 0.0000000000005],
                vals = [];

            for (var i = 0; i < arr.length; ++i) {
                if (max > arr[i]) {
                    i--;
                    break;
                }
            }

            scale.max = arr[i];
            scale.labels = [];
            scale.values = [];

            for (var j = 0; j < numlabels; ++j) {

                var value = ((arr[i] - min) / numlabels * (j + 1) + min).toFixed(decimals);

                scale.values.push(value);
                scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));
            }
        } else if (!strict) {

            /**
             * Now comes the scale handling for integer values
             */

            // This accomodates decimals by rounding the max up to the next integer
            max = ma.ceil(max);

            var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)));

            var topValue = interval;

            while (topValue < max) {
                topValue += interval / 2;
            }

            // Handles cases where the max is (for example) 50.5
            if (Number(original_max) > Number(topValue)) {
                topValue += interval / 2;
            }

            // Custom if the max is greater than 5 and less than 10
            if (max <= 10) {
                topValue = Number(original_max) <= 5 ? 5 : 10;
            }

            // Added 02/11/2010 to create "nicer" scales
            if (obj && typeof round == 'boolean' && round) {
                topValue = 10 * interval;
            }

            scale.max = topValue;

            // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those
            //that we've been given as the number_format functuion looks at those instead of using argumrnts.
            var tmp_point = prop['chart.scale.point'];
            var tmp_thousand = prop['chart.scale.thousand'];

            obj.Set('chart.scale.thousand', thousand);
            obj.Set('chart.scale.point', point);

            for (var i = 0; i < numlabels; ++i) {
                scale.labels.push(RG.number_format(obj, ((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals), units_pre, units_post));
                scale.values.push(((i + 1) / numlabels * (topValue - min) + min).toFixed(decimals));
            }

            obj.Set('chart.scale.thousand', tmp_thousand);
            obj.Set('chart.scale.point', tmp_point);
        } else if (typeof max == 'number' && strict) {

            /**
             * ymax is set and also strict
             */
            for (var i = 0; i < numlabels; ++i) {
                scale.labels.push(RG.numberFormat(obj, ((i + 1) / numlabels * (max - min) + min).toFixed(decimals), units_pre, units_post));

                scale.values.push(((i + 1) / numlabels * (max - min) + min).toFixed(decimals));
            }

            // ???
            scale.max = max;
        }

        scale.units_pre = units_pre;
        scale.units_post = units_post;
        scale.point = point;
        scale.decimals = decimals;
        scale.thousand = thousand;
        scale.numlabels = numlabels;
        scale.round = Boolean(round);
        scale.min = min;

        //
        // Convert all of the scale values to numbers
        //
        for (var i = 0; i < scale.values.length; ++i) {
            scale.values[i] = parseFloat(scale.values[i]);
        }

        return scale;
    };

    //
    // Converts an the truthy values to falsey values and vice-versa
    //
    RG.arrayInvert = function (arr) {
        for (var i = 0, len = arr.length; i < len; ++i) {
            arr[i] = !arr[i];
        }

        return arr;
    };

    //
    // An array_trim function that removes the empty elements off
    //both ends
    //
    RG.arrayTrim = function (arr) {
        var out = [],
            content = false;

        // Trim the start
        for (var i = 0; i < arr.length; i++) {

            if (arr[i]) {
                content = true;
            }

            if (content) {
                out.push(arr[i]);
            }
        }

        // Reverse the array and trim the start again
        out = RG.arrayReverse(out);

        var out2 = [],
            content = false;
        for (var i = 0; i < out.length; i++) {

            if (out[i]) {
                content = true;
            }

            if (content) {
                out2.push(out[i]);
            }
        }

        // Now reverse the array and return it
        out2 = RG.arrayReverse(out2);

        return out2;
    };

    /**
     * Makes a clone of an object
     *
     * @param obj val The object to clone
     */
    RG.arrayClone = RG.array_clone = function (obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }

        var temp = [];

        for (var i = 0, len = obj.length; i < len; ++i) {

            if (typeof obj[i] === 'number') {
                temp[i] = function (arg) {
                    return Number(arg);
                }(obj[i]);
            } else if (typeof obj[i] === 'string') {
                temp[i] = function (arg) {
                    return String(arg);
                }(obj[i]);
            } else if (typeof obj[i] === 'function') {
                temp[i] = obj[i];
            } else {
                temp[i] = RG.arrayClone(obj[i]);
            }
        }

        return temp;
    };

    /**
     * Returns the maximum numeric value which is in an array. This function IS NOT
     * recursive
     *
     * @param  array arr The array (can also be a number, in which case it's returned as-is)
     * @param  int       Whether to ignore signs (ie negative/positive)
     * @return int       The maximum value in the array
     */
    RG.arrayMax = RG.array_max = function (arr) {
        var max = null,
            ma = Math;

        if (typeof arr === 'number') {
            return arr;
        }

        if (RG.isNull(arr)) {
            return 0;
        }

        for (var i = 0, len = arr.length; i < len; ++i) {
            if (typeof arr[i] === 'number') {

                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];

                if (typeof max === 'number') {
                    max = ma.max(max, val);
                } else {
                    max = val;
                }
            }
        }

        return max;
    };

    /**
     * Returns the minimum numeric value which is in an array
     *
     * @param  array arr The array (can also be a number, in which case it's returned as-is)
     * @param  int       Whether to ignore signs (ie negative/positive)
     * @return int       The minimum value in the array
     */
    RG.arrayMin = function (arr) {
        var max = null,
            min = null,
            ma = Math;

        if (typeof arr === 'number') {
            return arr;
        }

        if (RG.isNull(arr)) {
            return 0;
        }

        for (var i = 0, len = arr.length; i < len; ++i) {
            if (typeof arr[i] === 'number') {

                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];

                if (typeof min === 'number') {
                    min = ma.min(min, val);
                } else {
                    min = val;
                }
            }
        }

        return min;
    };

    /**
     * Returns the maximum value which is in an array
     *
     * @param  array arr The array
     * @param  int   len The length to pad the array to
     * @param  mixed     The value to use to pad the array (optional)
     */
    RG.arrayPad = RG.array_pad = function (arr, len) {
        if (arr.length < len) {
            var val = arguments[2] ? arguments[2] : null;

            for (var i = arr.length; i < len; i += 1) {
                arr[i] = val;
            }
        }

        return arr;
    };

    /**
     * An array sum function
     *
     * @param  array arr The  array to calculate the total of
     * @return int       The summed total of the arrays elements
     */
    RG.arraySum = RG.array_sum = function (arr) {
        // Allow integers
        if (typeof arr === 'number') {
            return arr;
        }

        // Account for null
        if (RG.is_null(arr)) {
            return 0;
        }

        var i,
            sum,
            len = arr.length;

        for (i = 0, sum = 0; i < len; sum += arr[i++]);

        return sum;
    };

    /**
     * Takes any number of arguments and adds them to one big linear array
     * which is then returned
     *
     * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
     */
    RG.arrayLinearize = RG.array_linearize = function () {
        var arr = [],
            args = arguments;

        for (var i = 0, len = args.length; i < len; ++i) {

            if (typeof args[i] === 'object' && args[i]) {
                for (var j = 0, len2 = args[i].length; j < len2; ++j) {
                    var sub = RG.array_linearize(args[i][j]);

                    for (var k = 0, len3 = sub.length; k < len3; ++k) {
                        arr.push(sub[k]);
                    }
                }
            } else {
                arr.push(args[i]);
            }
        }

        return arr;
    };

    /**
     * Takes one off the front of the given array and returns the new array.
     *
     * @param array arr The array from which to take one off the front of array
     *
     * @return array The new array
     */
    RG.arrayShift = RG.array_shift = function (arr) {
        var ret = [];

        for (var i = 1, len = arr.length; i < len; ++i) {
            ret.push(arr[i]);
        }

        return ret;
    };

    /**
     * Reverses the order of an array
     *
     * @param array arr The array to reverse
     */
    RG.arrayReverse = RG.array_reverse = function (arr) {
        if (!arr) {
            return;
        }

        var newarr = [];

        for (var i = arr.length - 1; i >= 0; i -= 1) {
            newarr.push(arr[i]);
        }

        return newarr;
    };

    /**
     * Returns the absolute value of a number. You can also pass in an
     * array and it will run the abs() function on each element. It
     * operates recursively so sub-arrays are also traversed.
     *
     * @param array arr The number or array to work on
     */
    RG.abs = function (value) {
        if (typeof value === 'string') {
            value = parseFloat(value) || 0;
        }

        if (typeof value === 'number') {
            return ma.abs(value);
        }

        if (typeof value === 'object') {
            for (i in value) {
                if (typeof i === 'string' || typeof i === 'number' || typeof i === 'object') {

                    value[i] = RG.abs(value[i]);
                }
            }

            return value;
        }

        return 0;
    };

    /**
     * Clears the canvas by setting the width. You can specify a colour if you wish.
     *
     * @param object canvas The canvas to clear
     * @param mixed         Usually a color string to use to clear the canvas
     *                      with - could also be a gradient object
     */
    RG.clear = RG.Clear = function (ca) {
        var obj = ca.__object__,
            co = ca.getContext('2d'),
            color = arguments[1] || obj && obj.get('clearto');

        if (!ca) {
            return;
        }

        RG.fireCustomEvent(obj, 'onbeforeclear');

        /**
         * Set the CSS display: to none for DOM text
         */
        if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {
            for (var i in RG.text2.domNodeCache[ca.id]) {

                var el = RG.text2.domNodeCache[ca.id][i];

                if (el && el.style) {
                    el.style.display = 'none';
                }
            }
        }

        /**
         * Can now clear the canvas back to fully transparent
         */
        if (!color || color && color === 'rgba(0,0,0,0)' || color === 'transparent') {

            co.clearRect(-100, -100, ca.width + 200, ca.height + 200);

            // Reset the globalCompositeOperation
            co.globalCompositeOperation = 'source-over';
        } else if (color) {
            RG.path2(co, 'fs % fr -100 -100 % %', color, ca.width + 200, ca.height + 200);
        } else {
            RG.path2(co, 'fs % fr -100 -100 % %', obj.get('clearto'), ca.width + 200, ca.height + 200);
        }

        //if (RG.ClearAnnotations) {
        //RG.ClearAnnotations(ca.id);
        //}

        /**
         * This removes any background image that may be present
         */
        if (RG.Registry.Get('chart.background.image.' + ca.id)) {
            var img = RG.Registry.Get('chart.background.image.' + ca.id);
            img.style.position = 'absolute';
            img.style.left = '-10000px';
            img.style.top = '-10000px';
        }

        /**
         * This hides the tooltip that is showing IF it has the same canvas ID as
         * that which is being cleared
         */
        if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {
            RG.HideTooltip(ca);
            //RG.Redraw();
        }

        //
        // Hide all DOM text by positioning it outside the canvas
        //
        //for (i in RG.cache) {
        //    if (typeof i === 'string' && i.indexOf('-text-') > 0) {
        //        RG.cache[i].style.left = '-100px';
        //        RG.cache[i].style.top  = '-100px';
        //    }
        //}

        /**
         * Set the cursor to default
         */
        ca.style.cursor = 'default';

        RG.FireCustomEvent(obj, 'onclear');
    };

    /**
     * Draws the title of the graph
     *
     * @param object  canvas The canvas object
     * @param string  text   The title to write
     * @param integer gutter The size of the gutter
     * @param integer        The center X point (optional - if not given it will be generated from the canvas width)
     * @param integer        Size of the text. If not given it will be 14
     * @param object         An optional object which has canvas and context properties to use instead of those on
     *                       the obj argument (so as to enable caching)
     */
    RG.drawTitle = RG.DrawTitle = function (obj, text, gutterTop) {
        var ca = canvas = obj.canvas,
            co = context = obj.context,
            prop = obj.properties;
        gutterLeft = prop['chart.gutter.left'], gutterRight = prop['chart.gutter.right'], gutterTop = gutterTop, gutterBottom = prop['chart.gutter.bottom'], size = arguments[4] ? arguments[4] : 12, bold = prop['chart.title.bold'], italic = prop['chart.title.italic'], centerx = arguments[3] ? arguments[3] : (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft, keypos = prop['chart.key.position'], vpos = prop['chart.title.vpos'], hpos = prop['chart.title.hpos'], bgcolor = prop['chart.title.background'], x = prop['chart.title.x'], y = prop['chart.title.y'], halign = 'center', valign = 'center';

        // Account for 3D effect by faking the key position
        if (obj.type == 'bar' && prop['chart.variant'] == '3d') {
            keypos = 'gutter';
        }

        co.beginPath();
        co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';

        /**
         * Vertically center the text if the key is not present
         */
        if (keypos && keypos != 'gutter') {
            var valign = 'center';
        } else if (!keypos) {
            var valign = 'center';
        } else {
            var valign = 'bottom';
        }

        // if chart.title.vpos is a number, use that
        if (typeof prop['chart.title.vpos'] === 'number') {
            vpos = prop['chart.title.vpos'] * gutterTop;

            if (prop['chart.xaxispos'] === 'top') {
                vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);
            }
        } else {
            vpos = gutterTop - size - 5;

            if (prop['chart.xaxispos'] === 'top') {
                vpos = ca.height - gutterBottom + size + 5;
            }
        }

        // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width
        if (typeof hpos === 'number') {
            centerx = hpos * ca.width;
        }

        /**
         * Now the chart.title.x and chart.title.y settings override (is set) the above
         */
        if (typeof x === 'number') centerx = x;
        if (typeof y === 'number') vpos = y;

        /**
         * Horizontal alignment can now (Jan 2013) be specified
         */
        if (typeof prop['chart.title.halign'] === 'string') {
            halign = prop['chart.title.halign'];
        }

        /**
         * Vertical alignment can now (Jan 2013) be specified
         */
        if (typeof prop['chart.title.valign'] === 'string') {
            valign = prop['chart.title.valign'];
        }

        // Set the colour
        if (typeof prop['chart.title.color'] !== null) {
            var oldColor = co.fillStyle;
            var newColor = prop['chart.title.color'];
            co.fillStyle = newColor ? newColor : 'black';
        }

        /**
         * Default font is Arial
         */
        var font = prop['chart.text.font'];

        /**
         * Override the default font with chart.title.font
         */
        if (typeof prop['chart.title.font'] === 'string') {
            font = prop['chart.title.font'];
        }

        /**
         * Draw the title
         */

        var ret = RG.text2(obj, {
            font: font,
            size: size,
            x: centerx,
            y: vpos,
            text: text,
            valign: valign,
            halign: halign,
            bounding: bgcolor != null,
            'bounding.fill': bgcolor,
            'bold': bold,
            italic: italic,
            tag: 'title',
            marker: false
        });

        // Reset the fill colour
        co.fillStyle = oldColor;
    };

    /**
     * Gets the mouse X/Y coordinates relative to the canvas
     *
     * @param object e The event object. As such this method should be used in an event listener.
     */
    RG.getMouseXY = function (e) {
        // This is necessary foe IE9
        if (!e.target) {
            return;
        }

        var el = e.target;
        var ca = el;
        var caStyle = ca.style;
        var offsetX = 0;
        var offsetY = 0;
        var x;
        var y;
        var borderLeft = parseInt(caStyle.borderLeftWidth) || 0;
        var borderTop = parseInt(caStyle.borderTopWidth) || 0;
        var paddingLeft = parseInt(caStyle.paddingLeft) || 0;
        var paddingTop = parseInt(caStyle.paddingTop) || 0;
        var additionalX = borderLeft + paddingLeft;
        var additionalY = borderTop + paddingTop;

        if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {

            if (!RG.ISIE && !RG.ISOPERA) {
                x = e.offsetX - borderLeft - paddingLeft;
                y = e.offsetY - borderTop - paddingTop;
            } else if (RG.ISIE) {
                x = e.offsetX - paddingLeft;
                y = e.offsetY - paddingTop;
            } else {
                x = e.offsetX;
                y = e.offsetY;
            }
        } else {

            if (typeof el.offsetParent !== 'undefined') {
                do {
                    offsetX += el.offsetLeft;
                    offsetY += el.offsetTop;
                } while (el = el.offsetParent);
            }

            x = e.pageX - offsetX - additionalX;
            y = e.pageY - offsetY - additionalY;

            x -= 2 * (parseInt(document.body.style.borderLeftWidth) || 0);
            y -= 2 * (parseInt(document.body.style.borderTopWidth) || 0);

            //x += (parseInt(caStyle.borderLeftWidth) || 0);
            //y += (parseInt(caStyle.borderTopWidth) || 0);
        }

        // We return a javascript array with x and y defined
        return [x, y];
    };

    /**
     * This function returns a two element array of the canvas x/y position in
     * relation to the page
     *
     * @param object canvas
     */
    RG.getCanvasXY = function (canvas) {
        var x = 0;
        var y = 0;
        var el = canvas; // !!!

        do {

            x += el.offsetLeft;
            y += el.offsetTop;

            // ACCOUNT FOR TABLES IN wEBkIT
            if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {
                x += parseInt(el.border) || 0;
                y += parseInt(el.border) || 0;
            }

            el = el.offsetParent;
        } while (el && el.tagName.toLowerCase() != 'body');

        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;
        var paddingTop = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;
        var borderLeft = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;
        var borderTop = canvas.style.borderTopWidth ? parseInt(canvas.style.borderTopWidth) : 0;

        if (navigator.userAgent.indexOf('Firefox') > 0) {
            x += parseInt(document.body.style.borderLeftWidth) || 0;
            y += parseInt(document.body.style.borderTopWidth) || 0;
        }

        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
    };

    /**
     * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns
     * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).
     *
     * @return Either false or the fixed positioned element
     */
    RG.isFixed = function (canvas) {
        var obj = canvas;
        var i = 0;

        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {

            if (obj.style.position == 'fixed') {
                return obj;
            }

            obj = obj.offsetParent;
        }

        return false;
    };

    /**
     * Registers a graph object (used when the canvas is redrawn)
     *
     * @param object obj The object to be registered
     */
    RG.register = RG.Register = function (obj) {
        // Checking this property ensures the object is only registered once
        if (!obj.Get('chart.noregister')) {
            // As of 21st/1/2012 the object registry is now used
            RGraph.ObjectRegistry.Add(obj);
            obj.Set('chart.noregister', true);
        }
    };

    /**
     * Causes all registered objects to be redrawn
     *
     * @param string An optional color to use to clear the canvas
     */
    RG.redraw = RG.Redraw = function () {
        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;

        // Get all of the canvas tags on the page
        var tags = document.getElementsByTagName('canvas');

        for (var i = 0, len = tags.length; i < len; ++i) {
            if (tags[i].__object__ && tags[i].__object__.isRGraph) {

                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects
                if (!tags[i].noclear) {
                    RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);
                }
            }
        }

        // Go through the object registry and redraw *all* of the canvas'es that have been registered
        for (var i = 0, len = objectRegistry.length; i < len; ++i) {
            if (objectRegistry[i]) {
                var id = objectRegistry[i][0];
                objectRegistry[i][1].Draw();
            }
        }
    };

    /**
     * Causes all registered objects ON THE GIVEN CANVAS to be redrawn
     *
     * @param canvas object The canvas object to redraw
     * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas
     */
    RG.redrawCanvas = RG.RedrawCanvas = function (ca) {
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);

        /**
         * First clear the canvas
         */
        if (!arguments[1] || typeof arguments[1] === 'boolean' && !arguments[1] == false) {
            var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';
            RG.clear(ca, color);
        }

        /**
         * Now redraw all the charts associated with that canvas
         */
        for (var i = 0, len = objects.length; i < len; ++i) {
            if (objects[i]) {
                if (objects[i] && objects[i].isRGraph) {
                    // Is it an RGraph object ??
                    objects[i].Draw();
                }
            }
        }
    };

    /**
     * This function draws the background for the bar chart, line chart and scatter chart.
     *
     * @param  object obj The graph object
     */
    RG.Background.draw = RG.background.draw = RG.background.Draw = function (obj) {
        var ca = obj.canvas,
            co = obj.context,
            prop = obj.properties,
            height = 0,
            gutterLeft = obj.gutterLeft,
            gutterRight = obj.gutterRight,
            gutterTop = obj.gutterTop,
            gutterBottom = obj.gutterBottom,
            variant = prop['chart.variant'];

        co.fillStyle = prop['chart.text.color'];

        // If it's a bar and 3D variant, translate
        if (variant == '3d') {
            co.save();
            co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);
        }

        // X axis title
        if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {

            var size = prop['chart.text.size'] + 2;
            var font = prop['chart.text.font'];
            var bold = prop['chart.title.xaxis.bold'];

            if (typeof prop['chart.title.xaxis.size'] == 'number') {
                size = prop['chart.title.xaxis.size'];
            }

            if (typeof prop['chart.title.xaxis.font'] == 'string') {
                font = prop['chart.title.xaxis.font'];
            }

            var hpos = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;
            var vpos = ca.height - gutterBottom + 25;

            if (typeof prop['chart.title.xaxis.pos'] === 'number') {
                vpos = ca.height - gutterBottom * prop['chart.title.xaxis.pos'];
            }

            // Specifically specified X/Y positions
            if (typeof prop['chart.title.xaxis.x'] === 'number') {
                hpos = prop['chart.title.xaxis.x'];
            }

            if (typeof prop['chart.title.xaxis.y'] === 'number') {
                vpos = prop['chart.title.xaxis.y'];
            }

            RG.text2(prop['chart.text.accessible'] ? obj.context : co, {
                font: font,
                size: size,
                x: hpos,
                y: vpos,
                text: prop['chart.title.xaxis'],
                halign: 'center',
                valign: 'center',
                bold: bold,
                color: prop['chart.title.xaxis.color'] || 'black',
                tag: 'title xaxis'
            });
        }

        // Y axis title
        if (typeof prop['chart.title.yaxis'] == 'string' && prop['chart.title.yaxis'].length) {

            var size = prop['chart.text.size'] + 2;
            var font = prop['chart.text.font'];
            var angle = 270;
            var bold = prop['chart.title.yaxis.bold'];
            var color = prop['chart.title.yaxis.color'];

            if (typeof prop['chart.title.yaxis.pos'] == 'number') {
                var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;
            } else {
                var yaxis_title_pos = (gutterLeft - 25) / gutterLeft * gutterLeft;
            }

            if (typeof prop['chart.title.yaxis.size'] === 'number') {
                size = prop['chart.title.yaxis.size'];
            }

            if (typeof prop['chart.title.yaxis.font'] === 'string') {
                font = prop['chart.title.yaxis.font'];
            }

            if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right' || obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined') {

                angle = 90;
                yaxis_title_pos = prop['chart.title.yaxis.pos'] ? ca.width - gutterRight + prop['chart.title.yaxis.pos'] * gutterRight : ca.width - gutterRight + prop['chart.text.size'] + 5;
            } else {
                yaxis_title_pos = yaxis_title_pos;
            }

            var y = (ca.height - gutterTop - gutterBottom) / 2 + gutterTop;

            // Specifically specified X/Y positions
            if (typeof prop['chart.title.yaxis.x'] === 'number') {
                yaxis_title_pos = prop['chart.title.yaxis.x'];
            }

            if (typeof prop['chart.title.yaxis.y'] === 'number') {
                y = prop['chart.title.yaxis.y'];
            }

            co.fillStyle = color;
            RG.text2(prop['chart.text.accessible'] ? obj.context : co, {
                'font': font,
                'size': size,
                'x': yaxis_title_pos,
                'y': y,
                'valign': 'center',
                'halign': 'center',
                'angle': angle,
                'bold': bold,
                'text': prop['chart.title.yaxis'],
                'tag': 'title yaxis',
                accessible: false
            });
        }

        /**
         * If the background color is spec ified - draw that. It's a rectangle that fills the
         * entire area within the gutters
         */
        var bgcolor = prop['chart.background.color'];
        if (bgcolor) {
            co.fillStyle = bgcolor;
            co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
        }

        /**
         * Draw horizontal background bars
         */
        var numbars = prop['chart.ylabels.count'] || 5;
        var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;

        co.beginPath();
        co.fillStyle = prop['chart.background.barcolor1'];
        co.strokeStyle = co.fillStyle;
        height = ca.height - gutterBottom;

        for (var i = 0; i < numbars; i += 2) {
            co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);
        }
        co.fill();

        co.beginPath();
        co.fillStyle = prop['chart.background.barcolor2'];
        co.strokeStyle = co.fillStyle;

        for (var i = 1; i < numbars; i += 2) {
            co.rect(gutterLeft, i * barHeight + gutterTop, ca.width - gutterLeft - gutterRight, barHeight);
        }

        co.fill();

        // Close any errantly open path
        co.beginPath();

        //
        // The background grid is cached
        //
        var func = function (obj, cacheCanvas, cacheContext) {
            // Draw the background grid
            if (prop['chart.background.grid']) {

                prop['chart.background.grid.autofit.numhlines'] += 0.0001;

                // If autofit is specified, use the .numhlines and .numvlines along with the width to work
                // out the hsize and vsize
                if (prop['chart.background.grid.autofit']) {

                    /**
                     * Align the grid to the tickmarks
                     */
                    if (prop['chart.background.grid.autofit.align']) {

                        // Align the horizontal lines
                        if (obj.type === 'hbar') {
                            obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                        }

                        // Align the vertical lines for the line
                        if (obj.type === 'line') {
                            if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {
                                // Nada
                            } else if (prop['chart.labels'] && prop['chart.labels'].length) {
                                obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);
                            } else {
                                obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);
                            }
                        } else if (obj.type === 'waterfall') {
                            obj.set('backgroundGridAutofitNumvlines', obj.data.length + (prop['chart.total'] ? 1 : 0));

                            // Align the vertical lines for the bar, Scatter
                        } else if ((obj.type === 'bar' || obj.type === 'scatter') && (prop['chart.labels'] && prop['chart.labels'].length || obj.type === 'bar')) {

                            var len = prop['chart.labels'] && prop['chart.labels'].length || obj.data.length;

                            obj.set({
                                backgroundGridAutofitNumvlines: len
                            });

                            // Gantt
                        } else if (obj.type === 'gantt') {

                            if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {
                                // Nothing to do here
                            } else {
                                obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);
                            }

                            obj.set('chart.background.grid.autofit.numhlines', obj.data.length);

                            // HBar
                        } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines'])) {
                            obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                        }
                    }

                    var vsize = (cacheCanvas.width - gutterLeft - gutterRight) / prop['chart.background.grid.autofit.numvlines'];
                    var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];

                    obj.Set('chart.background.grid.vsize', vsize);
                    obj.Set('chart.background.grid.hsize', hsize);
                }

                co.beginPath();
                cacheContext.lineWidth = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;
                cacheContext.strokeStyle = prop['chart.background.grid.color'];

                // Dashed background grid
                if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {
                    cacheContext.setLineDash([3, 5]);
                }

                // Dotted background grid
                if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {
                    cacheContext.setLineDash([1, 3]);
                }

                co.beginPath();

                // Draw the horizontal lines
                if (prop['chart.background.grid.hlines']) {
                    height = cacheCanvas.height - gutterBottom;
                    var hsize = prop['chart.background.grid.hsize'];
                    for (y = gutterTop; y <= height; y += hsize) {
                        cacheContext.moveTo(gutterLeft, ma.round(y));
                        cacheContext.lineTo(ca.width - gutterRight, ma.round(y));
                    }
                }

                if (prop['chart.background.grid.vlines']) {
                    // Draw the vertical lines
                    var width = cacheCanvas.width - gutterRight;
                    var vsize = prop['chart.background.grid.vsize'];

                    for (x = gutterLeft; ma.round(x) <= width; x += vsize) {
                        cacheContext.moveTo(ma.round(x), gutterTop);
                        cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);
                    }
                }

                if (prop['chart.background.grid.border']) {
                    // Make sure a rectangle, the same colour as the grid goes around the graph
                    cacheContext.strokeStyle = prop['chart.background.grid.color'];
                    cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
                }
            }

            cacheContext.stroke();

            // Ensure the grids drawn before continuing
            cacheContext.beginPath();
            cacheContext.closePath();
        };

        // Now a cached draw in newer browsers
        RG.cachedDraw(obj, obj.uid + '_background', func);

        // If it's a bar and 3D variant, translate
        if (variant == '3d') {
            co.restore();
        }

        // Reset the line dash
        if (typeof co.setLineDash == 'function') {
            co.setLineDash([1, 0]);
        }

        co.stroke();

        // Draw the title if one is set
        if (typeof obj.properties['chart.title'] == 'string') {

            var prop = obj.properties;

            RG.drawTitle(obj, prop['chart.title'], obj.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2, obj);
        }
    };

    /**
     * Formats a number with thousand seperators so it's easier to read
     *
     * @param  integer obj The chart object
     * @param  integer num The number to format
     * @param  string      The (optional) string to prepend to the string
     * @param  string      The (optional) string to append to the string
     * @return string      The formatted number
     */
    RG.numberFormat = RG.number_format = function (obj, num) {
        var ca = obj.canvas;
        var co = obj.context;
        var prop = obj.properties;

        var i;
        var prepend = arguments[2] ? String(arguments[2]) : '';
        var append = arguments[3] ? String(arguments[3]) : '';
        var output = '';
        var decimal = '';
        var decimal_seperator = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';
        var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';
        RegExp.$1 = '';
        var i, j;

        if (typeof prop['chart.scale.formatter'] === 'function') {
            return prop['chart.scale.formatter'](obj, num);
        }

        // Ignore the preformatted version of "1e-2"
        if (String(num).indexOf('e') > 0) {
            return String(prepend + String(num) + append);
        }

        // We need then number as a string
        num = String(num);

        // Take off the decimal part - we re-append it later
        if (num.indexOf('.') > 0) {
            var tmp = num;
            num = num.replace(/\.(.*)/, ''); // The front part of the number
            decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
        }

        // Thousand seperator
        //var seperator = arguments[1] ? String(arguments[1]) : ',';
        var seperator = thousand_seperator;

        /**
         * Work backwards adding the thousand seperators
         */
        var foundPoint;
        for (i = num.length - 1, j = 0; i >= 0; j++, i--) {
            var character = num.charAt(i);

            if (j % 3 == 0 && j != 0) {
                output += seperator;
            }

            /**
             * Build the output
             */
            output += character;
        }

        /**
         * Now need to reverse the string
         */
        var rev = output;
        output = '';
        for (i = rev.length - 1; i >= 0; i--) {
            output += rev.charAt(i);
        }

        // Tidy up
        //output = output.replace(/^-,/, '-');
        if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {
            output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);
        }

        // Reappend the decimal
        if (decimal.length) {
            output = output + decimal_seperator + decimal;
            decimal = '';
            RegExp.$1 = '';
        }

        // Minor bugette
        if (output.charAt(0) == '-') {
            output = output.replace(/-/, '');
            prepend = '-' + prepend;
        }

        return prepend + output + append;
    };

    /**
     * Draws horizontal coloured bars on something like the bar, line or scatter
     */
    RG.drawBars = RG.DrawBars = function (obj) {
        var prop = obj.properties;
        var co = obj.context;
        var ca = obj.canvas;
        var hbars = prop['chart.background.hbars'];

        if (hbars === null) {
            return;
        }

        /**
         * Draws a horizontal bar
         */
        co.beginPath();

        for (i = 0, len = hbars.length; i < len; ++i) {

            var start = hbars[i][0];
            var length = hbars[i][1];
            var color = hbars[i][2];

            // Perform some bounds checking
            if (RG.is_null(start)) start = obj.scale2.max;
            if (start > obj.scale2.max) start = obj.scale2.max;
            if (RG.is_null(length)) length = obj.scale2.max - start;
            if (start + length > obj.scale2.max) length = obj.scale2.max - start;
            if (start + length < -1 * obj.scale2.max) length = -1 * obj.scale2.max - start;

            if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < obj.scale2.max * -2) {
                length = obj.scale2.max * -2;
            }

            /**
             * Draw the bar
             */
            var x = prop['chart.gutter.left'];
            var y = obj.getYCoord(start);
            var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
            var h = obj.getYCoord(start + length) - y;

            // Accommodate Opera :-/
            if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {
                h *= -1;
                y = y - h;
            }

            /**
             * Account for X axis at the top
             */
            if (prop['chart.xaxispos'] == 'top') {
                y = ca.height - y;
                h *= -1;
            }

            co.fillStyle = color;
            co.fillRect(x, y, w, h);
        }
        /*
              // If the X axis is at the bottom, and a negative max is given, warn the user
         if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {
         alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');
         }
          var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));
         //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;
         var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);
          // Account for the X axis being in the center
         if (obj.Get('chart.xaxispos') == 'center') {
         ystart /= 2;
         //height /= 2;
         }
          ystart += obj.Get('chart.gutter.top')
          var x = obj.Get('chart.gutter.left');
         var y = ystart - height;
         var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');
         var h = height;
          // Accommodate Opera :-/
         if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {
         h *= -1;
         y = y - h;
         }
          /**
         * Account for X axis at the top
         */
        //if (obj.Get('chart.xaxispos') == 'top') {
        //    y  = obj.canvas.height - y;
        //    h *= -1;
        //}

        //obj.context.fillStyle = hbars[i][2];
        //obj.context.fillRect(x, y, w, h);
        //}
    };

    /**
     * Draws in-graph labels.
     *
     * @param object obj The graph object
     */
    RG.drawInGraphLabels = RG.DrawInGraphLabels = function (obj) {
        var ca = obj.canvas;
        var co = obj.context;
        var prop = obj.properties;
        var labels = prop['chart.labels.ingraph'];
        var labels_processed = [];

        // Defaults
        var fgcolor = 'black';
        var bgcolor = 'white';
        var direction = 1;

        if (!labels) {
            return;
        }

        /**
         * Preprocess the labels array. Numbers are expanded
         */
        for (var i = 0, len = labels.length; i < len; i += 1) {
            if (typeof labels[i] === 'number') {
                for (var j = 0; j < labels[i]; ++j) {
                    labels_processed.push(null);
                }
            } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {
                labels_processed.push(labels[i]);
            } else {
                labels_processed.push('');
            }
        }

        /**
         * Turn off any shadow
         */
        RG.noShadow(obj);

        if (labels_processed && labels_processed.length > 0) {

            for (var i = 0, len = labels_processed.length; i < len; i += 1) {
                if (labels_processed[i]) {
                    var coords = obj.coords[i];

                    if (coords && coords.length > 0) {
                        var x = obj.type == 'bar' ? coords[0] + coords[2] / 2 : coords[0];
                        var y = obj.type == 'bar' ? coords[1] + coords[3] / 2 : coords[1];
                        var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;

                        co.beginPath();
                        co.fillStyle = 'black';
                        co.strokeStyle = 'black';

                        if (obj.type === 'bar') {

                            /**
                             * X axis at the top
                             */
                            if (obj.Get('chart.xaxispos') == 'top') {
                                length *= -1;
                            }

                            if (prop['chart.variant'] == 'dot') {
                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);

                                var text_x = ma.round(x);
                                var text_y = obj.coords[i][1] - 5 - length;
                            } else if (prop['chart.variant'] == 'arrow') {
                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);

                                var text_x = ma.round(x);
                                var text_y = obj.coords[i][1] - 5 - length;
                            } else {

                                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);
                                co.moveTo(ma.round(x), y);
                                co.lineTo(ma.round(x), y - length);

                                var text_x = ma.round(x);
                                var text_y = y - length;
                            }

                            co.stroke();
                            co.fill();
                        } else {

                            if (typeof labels_processed[i] == 'object' && typeof labels_processed[i][3] == 'number' && labels_processed[i][3] == -1) {

                                co.moveTo(ma.round(x), y + 5);
                                co.lineTo(ma.round(x), y + 5 + length);

                                co.stroke();
                                co.beginPath();

                                // This draws the arrow
                                co.moveTo(ma.round(x), y + 5);
                                co.lineTo(ma.round(x) - 3, y + 10);
                                co.lineTo(ma.round(x) + 3, y + 10);
                                co.closePath();

                                var text_x = x;
                                var text_y = y + 5 + length;
                            } else {

                                var text_x = x;
                                var text_y = y - 5 - length;

                                co.moveTo(ma.round(x), y - 5);
                                co.lineTo(ma.round(x), y - 5 - length);

                                co.stroke();
                                co.beginPath();

                                // This draws the arrow
                                co.moveTo(ma.round(x), y - 5);
                                co.lineTo(ma.round(x) - 3, y - 10);
                                co.lineTo(ma.round(x) + 3, y - 10);
                                co.closePath();
                            }

                            co.fill();
                        }

                        // Taken out on the 10th Nov 2010 - unnecessary
                        //var width = context.measureText(labels[i]).width;

                        co.beginPath();

                        // Fore ground color
                        co.fillStyle = typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string' ? labels_processed[i][1] : 'black';

                        RG.text2(obj, {
                            'font': prop['chart.text.font'],
                            'size': prop['chart.text.size'],
                            'x': text_x,
                            'y': text_y + (obj.properties['chart.text.accessible'] ? 2 : 0),
                            'text': typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string' ? labels_processed[i][0] : labels_processed[i],
                            'valign': 'bottom',
                            'halign': 'center',
                            'bounding': true,
                            'bounding.fill': typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string' ? labels_processed[i][2] : 'white',
                            'tag': 'labels ingraph'
                        });
                        co.fill();
                    }
                }
            }
        }
    };

    /**
     * This function "fills in" key missing properties that various implementations lack
     *
     * @param object e The event object
     */
    RG.fixEventObject = RG.FixEventObject = function (e) {
        if (RG.ISOLD) {
            var e = event;

            e.pageX = event.clientX + doc.body.scrollLeft;
            e.pageY = event.clientY + doc.body.scrollTop;
            e.target = event.srcElement;

            if (!doc.body.scrollTop && doc.documentElement.scrollTop) {
                e.pageX += parseInt(doc.documentElement.scrollLeft);
                e.pageY += parseInt(doc.documentElement.scrollTop);
            }
        }

        // Any browser that doesn't implement stopPropagation() (MSIE)
        if (!e.stopPropagation) {
            e.stopPropagation = function () {
                window.event.cancelBubble = true;
            };
        }

        return e;
    };

    /**
     * Thisz function hides the crosshairs coordinates
     */
    RG.hideCrosshairCoords = RG.HideCrosshairCoords = function () {
        var div = RG.Registry.Get('chart.coordinates.coords.div');

        if (div && div.style.opacity == 1 && div.__object__.Get('chart.crosshairs.coords.fadeout')) {

            var style = RG.Registry.Get('chart.coordinates.coords.div').style;

            setTimeout(function () {
                style.opacity = 0.9;
            }, 25);
            setTimeout(function () {
                style.opacity = 0.8;
            }, 50);
            setTimeout(function () {
                style.opacity = 0.7;
            }, 75);
            setTimeout(function () {
                style.opacity = 0.6;
            }, 100);
            setTimeout(function () {
                style.opacity = 0.5;
            }, 125);
            setTimeout(function () {
                style.opacity = 0.4;
            }, 150);
            setTimeout(function () {
                style.opacity = 0.3;
            }, 175);
            setTimeout(function () {
                style.opacity = 0.2;
            }, 200);
            setTimeout(function () {
                style.opacity = 0.1;
            }, 225);
            setTimeout(function () {
                style.opacity = 0;
            }, 250);
            setTimeout(function () {
                style.display = 'none';
            }, 275);
        }
    };

    /**
     * Draws the3D axes/background
     *
     * @param object obj The chart object
     */
    RG.draw3DAxes = RG.Draw3DAxes = function (obj) {
        var prop = obj.properties,
            co = obj.context,
            ca = obj.canvas;

        var gutterLeft = obj.gutterLeft,
            gutterRight = obj.gutterRight,
            gutterTop = obj.gutterTop,
            gutterBottom = obj.gutterBottom,
            xaxispos = prop['chart.xaxispos'],
            graphArea = ca.height - gutterTop - gutterBottom,
            halfGraphArea = graphArea / 2,
            offsetx = prop['chart.variant.threed.offsetx'],
            offsety = prop['chart.variant.threed.offsety'],
            xaxis = prop['chart.variant.threed.xaxis'],
            yaxis = prop['chart.variant.threed.yaxis'];

        //
        // Draw the 3D Y axis
        //
        if (yaxis) {
            RG.draw3DYAxis(obj);
        }

        // X axis
        if (xaxis) {
            if (xaxispos === 'center') {
                RG.path2(co, 'b m % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, gutterTop + halfGraphArea, gutterLeft + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight + offsetx, gutterTop + halfGraphArea - offsety, ca.width - gutterRight, gutterTop + halfGraphArea);
            } else {

                if (obj.type === 'hbar') {
                    var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];
                } else {
                    var xaxisYCoord = obj.getYCoord(0);
                }

                RG.path2(co, 'm % % l % % l % % l % % c s #aaa f #ddd', gutterLeft, xaxisYCoord, gutterLeft + offsetx, xaxisYCoord - offsety, ca.width - gutterRight + offsetx, xaxisYCoord - offsety, ca.width - gutterRight, xaxisYCoord);
            }
        }
    };

    /**
     * Draws the3D Y axis/background
     *
     * @param object obj The chart object
     */
    RG.draw3DYAxis = function (obj) {
        var prop = obj.properties,
            co = obj.context,
            ca = obj.canvas;

        var gutterLeft = obj.gutterLeft,
            gutterRight = obj.gutterRight,
            gutterTop = obj.gutterTop,
            gutterBottom = obj.gutterBottom,
            xaxispos = prop['chart.xaxispos'],
            graphArea = ca.height - gutterTop - gutterBottom,
            halfGraphArea = graphArea / 2,
            offsetx = prop['chart.variant.threed.offsetx'],
            offsety = prop['chart.variant.threed.offsety'];

        // Y axis
        // Commented out the if condition because of drawing oddities
        //if (!prop['chart.noaxes'] && !prop['chart.noyaxis']) {

        if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {
            var x = (ca.width - gutterLeft - gutterRight) / 2 + gutterLeft;
        } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {
            var x = ca.width - gutterRight;
        } else {
            var x = gutterLeft;
        }

        RG.path2(co, 'b m % % l % % l % % l % % s #aaa f #ddd', x, gutterTop, x + offsetx, gutterTop - offsety, x + offsetx, ca.height - gutterBottom - offsety, x, ca.height - gutterBottom);
        //}
    };

    /**
     * Draws a rectangle with curvy corners
     *
     * @param co object The context
     * @param x number The X coordinate (top left of the square)
     * @param y number The Y coordinate (top left of the square)
     * @param w number The width of the rectangle
     * @param h number The height of the rectangle
     * @param   number The radius of the curved corners
     * @param   boolean Whether the top left corner is curvy
     * @param   boolean Whether the top right corner is curvy
     * @param   boolean Whether the bottom right corner is curvy
     * @param   boolean Whether the bottom left corner is curvy
     */
    RG.strokedCurvyRect = function (co, x, y, w, h) {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = arguments[6] || arguments[6] == null ? true : false;
        var corner_tr = arguments[7] || arguments[7] == null ? true : false;
        var corner_br = arguments[8] || arguments[8] == null ? true : false;
        var corner_bl = arguments[9] || arguments[9] == null ? true : false;

        co.beginPath();

        // Top left side
        co.moveTo(x + (corner_tl ? r : 0), y);
        co.lineTo(x + w - (corner_tr ? r : 0), y);

        // Top right corner
        if (corner_tr) {
            co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);
        }

        // Top right side
        co.lineTo(x + w, y + h - (corner_br ? r : 0));

        // Bottom right corner
        if (corner_br) {
            co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);
        }

        // Bottom right side
        co.lineTo(x + (corner_bl ? r : 0), y + h);

        // Bottom left corner
        if (corner_bl) {
            co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
        }

        // Bottom left side
        co.lineTo(x, y + (corner_tl ? r : 0));

        // Top left corner
        if (corner_tl) {
            co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
        }

        co.stroke();
    };

    /**
     * Draws a filled rectangle with curvy corners
     *
     * @param context object The context
     * @param x       number The X coordinate (top left of the square)
     * @param y       number The Y coordinate (top left of the square)
     * @param w       number The width of the rectangle
     * @param h       number The height of the rectangle
     * @param         number The radius of the curved corners
     * @param         boolean Whether the top left corner is curvy
     * @param         boolean Whether the top right corner is curvy
     * @param         boolean Whether the bottom right corner is curvy
     * @param         boolean Whether the bottom left corner is curvy
     */
    RG.filledCurvyRect = function (co, x, y, w, h) {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = arguments[6] || arguments[6] == null ? true : false;
        var corner_tr = arguments[7] || arguments[7] == null ? true : false;
        var corner_br = arguments[8] || arguments[8] == null ? true : false;
        var corner_bl = arguments[9] || arguments[9] == null ? true : false;

        co.beginPath();

        // First draw the corners

        // Top left corner
        if (corner_tl) {
            co.moveTo(x + r, y + r);
            co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
        } else {
            co.fillRect(x, y, r, r);
        }

        // Top right corner
        if (corner_tr) {
            co.moveTo(x + w - r, y + r);
            co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);
        } else {
            co.moveTo(x + w - r, y);
            co.fillRect(x + w - r, y, r, r);
        }

        // Bottom right corner
        if (corner_br) {
            co.moveTo(x + w - r, y + h - r);
            co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);
        } else {
            co.moveTo(x + w - r, y + h - r);
            co.fillRect(x + w - r, y + h - r, r, r);
        }

        // Bottom left corner
        if (corner_bl) {
            co.moveTo(x + r, y + h - r);
            co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
        } else {
            co.moveTo(x, y + h - r);
            co.fillRect(x, y + h - r, r, r);
        }

        // Now fill it in
        co.fillRect(x + r, y, w - r - r, h);
        co.fillRect(x, y + r, r + 1, h - r - r);
        co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);

        co.fill();
    };

    /**
     * Hides the zoomed canvas
     */
    RG.hideZoomedCanvas = RG.HideZoomedCanvas = function () {
        var interval = 10;
        var frames = 15;

        if (typeof RG.zoom_image === 'object') {
            var obj = RG.zoom_image.obj;
            var prop = obj.properties;
        } else {
            return;
        }

        if (prop['chart.zoom.fade.out']) {
            for (var i = frames, j = 1; i >= 0; --i, ++j) {
                if (typeof RG.zoom_image === 'object') {
                    setTimeout("RGraph.zoom_image.style.opacity = " + String(i / 10), j * interval);
                }
            }

            if (typeof RG.zoom_background === 'object') {
                setTimeout("RGraph.zoom_background.style.opacity = " + String(i / frames), j * interval);
            }
        }

        if (typeof RG.zoom_image === 'object') {
            setTimeout("RGraph.zoom_image.style.display = 'none'", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);
        }

        if (typeof RG.zoom_background === 'object') {
            setTimeout("RGraph.zoom_background.style.display = 'none'", prop['chart.zoom.fade.out'] ? frames * interval + 10 : 0);
        }
    };

    /**
     * Adds an event handler
     *
     * @param object obj   The graph object
     * @param string event The name of the event, eg ontooltip
     * @param object func  The callback function
     */
    RG.addCustomEventListener = RG.AddCustomEventListener = function (obj, name, func) {
        // Initialise the events array if necessary
        if (typeof RG.events[obj.uid] === 'undefined') {
            RG.events[obj.uid] = [];
        }

        // Prepend "on" if necessary
        if (name.substr(0, 2) !== 'on') {
            name = 'on' + name;
        }

        RG.events[obj.uid].push([obj, name, func]);

        return RG.events[obj.uid].length - 1;
    };

    /**
     * Used to fire one of the RGraph custom events
     *
     * @param object obj   The graph object that fires the event
     * @param string event The name of the event to fire
     */
    RG.fireCustomEvent = RG.FireCustomEvent = function (obj, name) {
        if (obj && obj.isRGraph) {

            // This allows the eventsMouseout property to work
            // (for some reason...)
            if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {
                obj.properties['chart.events.mouseout'](obj);
            }

            // DOM1 style of adding custom events
            if (obj[name]) {
                obj[name](obj);
            }

            var uid = obj.uid;

            if (typeof uid === 'string' && typeof RG.events === 'object' && typeof RG.events[uid] === 'object' && RG.events[uid].length > 0) {

                for (var j = 0; j < RG.events[uid].length; ++j) {
                    if (RG.events[uid][j] && RG.events[uid][j][1] === name) {
                        RG.events[uid][j][2](obj);
                    }
                }
            }
        }
    };

    /**
     * Clears all the custom event listeners that have been registered
     *
     * @param    string Limits the clearing to this object ID
     */
    RGraph.removeAllCustomEventListeners = RGraph.RemoveAllCustomEventListeners = function () {
        var id = arguments[0];

        if (id && RG.events[id]) {
            RG.events[id] = [];
        } else {
            RG.events = [];
        }
    };

    /**
     * Clears a particular custom event listener
     *
     * @param object obj The graph object
     * @param number i   This is the index that is return by .AddCustomEventListener()
     */
    RG.removeCustomEventListener = RG.RemoveCustomEventListener = function (obj, i) {
        if (typeof RG.events === 'object' && typeof RG.events[obj.id] === 'object' && typeof RG.events[obj.id][i] === 'object') {

            RG.events[obj.id][i] = null;
        }
    };

    /**
     * This draws the background
     *
     * @param object obj The graph object
     */
    RG.drawBackgroundImage = RG.DrawBackgroundImage = function (obj) {
        var prop = obj.properties;
        var ca = obj.canvas;
        var co = obj.context;

        if (typeof prop['chart.background.image'] === 'string') {
            if (typeof ca.__rgraph_background_image__ === 'undefined') {
                var img = new Image();
                img.__object__ = obj;
                img.__canvas__ = ca;
                img.__context__ = co;
                img.src = obj.Get('chart.background.image');

                ca.__rgraph_background_image__ = img;
            } else {
                img = ca.__rgraph_background_image__;
            }

            // When the image has loaded - redraw the canvas
            img.onload = function () {
                obj.__rgraph_background_image_loaded__ = true;
                RG.clear(ca);
                RG.redrawCanvas(ca);
            };

            var gutterLeft = obj.gutterLeft;
            var gutterRight = obj.gutterRight;
            var gutterTop = obj.gutterTop;
            var gutterBottom = obj.gutterBottom;
            var stretch = prop['chart.background.image.stretch'];
            var align = prop['chart.background.image.align'];

            // Handle chart.background.image.align
            if (typeof align === 'string') {
                if (align.indexOf('right') != -1) {
                    var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;
                } else {
                    var x = gutterLeft;
                }

                if (align.indexOf('bottom') != -1) {
                    var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;
                } else {
                    var y = gutterTop;
                }
            } else {
                var x = gutterLeft || 25;
                var y = gutterTop || 25;
            }

            // X/Y coords take precedence over the align
            var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;
            var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;
            var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;
            var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;

            /**
             * You can now specify the width and height of the image
             */
            if (typeof prop['chart.background.image.w'] === 'number') w = prop['chart.background.image.w'];
            if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];

            var oldAlpha = co.globalAlpha;
            co.globalAlpha = prop['chart.background.image.alpha'];
            co.drawImage(img, x, y, w, h);
            co.globalAlpha = oldAlpha;
        }
    };

    /**
     * This function determines wshether an object has tooltips or not
     *
     * @param object obj The chart object
     */
    RG.hasTooltips = function (obj) {
        var prop = obj.properties;

        if (typeof prop['chart.tooltips'] == 'object' && prop['chart.tooltips']) {
            for (var i = 0, len = prop['chart.tooltips'].length; i < len; ++i) {
                if (!RG.is_null(obj.Get('chart.tooltips')[i])) {
                    return true;
                }
            }
        } else if (typeof prop['chart.tooltips'] === 'function') {
            return true;
        }

        return false;
    };

    /**
     * This function creates a (G)UID which can be used to identify objects.
     *
     * @return string (g)uid The (G)UID
     */
    RG.createUID = RG.CreateUID = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = ma.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
        });
    };

    /**
     * This is the new object registry, used to facilitate multiple objects per canvas.
     *
     * @param object obj The object to register
     */
    RG.OR.add = RG.OR.Add = function (obj) {
        var uid = obj.uid;
        var id = obj.canvas.id;

        /**
         * Index the objects by UID
         */
        RG.ObjectRegistry.objects.byUID.push([uid, obj]);

        /**
         * Index the objects by the canvas that they're drawn on
         */
        RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);
    };

    /**
     * Remove an object from the object registry
     *
     * @param object obj The object to remove.
     */
    RG.OR.remove = RG.OR.Remove = function (obj) {
        var id = obj.id;
        var uid = obj.uid;

        for (var i = 0; i < RG.ObjectRegistry.objects.byUID.length; ++i) {
            if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {
                RG.ObjectRegistry.objects.byUID[i] = null;
            }
        }

        for (var i = 0; i < RG.ObjectRegistry.objects.byCanvasID.length; ++i) {
            if (RG.ObjectRegistry.objects.byCanvasID[i] && RG.ObjectRegistry.objects.byCanvasID[i][1] && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {

                RG.ObjectRegistry.objects.byCanvasID[i] = null;
            }
        }
    };

    /**
     * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,
     * or the canvas itself, then only objects pertaining to that canvas are cleared.
     *
     * @param mixed   Either a canvas object (as returned by document.getElementById()
     *                or the ID of a canvas (ie a string)
     */
    RG.OR.clear = RG.OR.Clear = function () {
        // If an ID is supplied restrict the learing to that
        if (arguments[0]) {
            var id = typeof arguments[0] === 'object' ? arguments[0].id : arguments[0];
            var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);

            for (var i = 0, len = objects.length; i < len; ++i) {
                RG.ObjectRegistry.remove(objects[i]);
            }
        } else {

            RG.ObjectRegistry.objects = {};
            RG.ObjectRegistry.objects.byUID = [];
            RG.ObjectRegistry.objects.byCanvasID = [];
        }
    };

    /**
     * Lists all objects in the ObjectRegistry
     *
     * @param boolean ret Whether to return the list or alert() it
     */
    RG.OR.list = RG.OR.List = function () {
        var list = [];

        for (var i = 0, len = RG.ObjectRegistry.objects.byUID.length; i < len; ++i) {
            if (RG.ObjectRegistry.objects.byUID[i]) {
                list.push(RG.ObjectRegistry.objects.byUID[i][1].type);
            }
        }

        if (arguments[0]) {
            return list;
        } else {
            $p(list);
        }
    };

    /**
     * Clears the ObjectRegistry of objects that are of a certain given type
     *
     * @param type string The type to clear
     */
    RG.OR.clearByType = RG.OR.ClearByType = function (type) {
        var objects = RG.ObjectRegistry.objects.byUID;

        for (var i = 0, len = objects.length; i < len; ++i) {
            if (objects[i]) {
                var uid = objects[i][0];
                var obj = objects[i][1];

                if (obj && obj.type == type) {
                    RG.ObjectRegistry.remove(obj);
                }
            }
        }
    };

    /**
     * This function provides an easy way to go through all of the objects that are held in the
     * Registry
     *
     * @param func function This function is run for every object. Its passed the object as an argument
     * @param string type Optionally, you can pass a type of object to look for
     */
    RG.OR.iterate = RG.OR.Iterate = function (func) {
        var objects = RGraph.ObjectRegistry.objects.byUID;

        for (var i = 0, len = objects.length; i < len; ++i) {

            if (typeof arguments[1] === 'string') {

                var types = arguments[1].split(/,/);

                for (var j = 0, len2 = types.length; j < len2; ++j) {
                    if (types[j] == objects[i][1].type) {
                        func(objects[i][1]);
                    }
                }
            } else {
                func(objects[i][1]);
            }
        }
    };

    /**
     * Retrieves all objects for a given canvas id
     *
     * @patarm id string The canvas ID to get objects for.
     */
    RG.OR.getObjectsByCanvasID = function (id) {
        var store = RG.ObjectRegistry.objects.byCanvasID;
        var ret = [];

        // Loop through all of the objects and return the appropriate ones
        for (var i = 0, len = store.length; i < len; ++i) {
            if (store[i] && store[i][0] == id) {
                ret.push(store[i][1]);
            }
        }

        return ret;
    };

    /**
     * Retrieves the relevant object based on the X/Y position.
     *
     * @param  object e The event object
     * @return object   The applicable (if any) object
     */
    RG.OR.firstbyxy = RG.OR.getFirstObjectByXY = RG.OR.getObjectByXY = function (e) {
        var canvas = e.target;
        var ret = null;
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

        for (var i = objects.length - 1; i >= 0; --i) {

            var obj = objects[i].getObjectByXY(e);

            if (obj) {
                return obj;
            }
        }
    };

    /**
     * Retrieves the relevant objects based on the X/Y position.
     * NOTE This function returns an array of objects
     *
     * @param  object e The event object
     * @return          An array of pertinent objects. Note the there may be only one object
     */
    RG.OR.getObjectsByXY = function (e) {
        var canvas = e.target;
        var ret = [];
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

        // Retrieve objects "front to back"
        for (var i = objects.length - 1; i >= 0; --i) {

            var obj = objects[i].getObjectByXY(e);

            if (obj) {
                ret.push(obj);
            }
        }

        return ret;
    };

    /**
     * Retrieves the object with the corresponding UID
     *
     * @param string uid The UID to get the relevant object for
     */
    RG.OR.get = RG.OR.getObjectByUID = function (uid) {
        var objects = RG.ObjectRegistry.objects.byUID;

        for (var i = 0, len = objects.length; i < len; ++i) {
            if (objects[i] && objects[i][1].uid == uid) {
                return objects[i][1];
            }
        }
    };

    /**
     * Brings a chart to the front of the ObjectRegistry by
     * removing it and then readding it at the end and then
     * redrawing the canvas
     *
     * @param object  obj    The object to bring to the front
     * @param boolean redraw Whether to redraw the canvas after the
     *                       object has been moved
     */
    RG.OR.bringToFront = function (obj) {
        var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];

        RG.ObjectRegistry.remove(obj);
        RG.ObjectRegistry.add(obj);

        if (redraw) {
            RG.redrawCanvas(obj.canvas);
        }
    };

    /**
     * Retrieves the objects that are the given type
     *
     * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID
     * @param  string type   The type to look for
     * @return array         An array of one or more objects
     */
    RG.OR.type = RG.OR.getObjectsByType = function (type) {
        var objects = RG.ObjectRegistry.objects.byUID;
        var ret = [];

        for (var i = 0, len = objects.length; i < len; ++i) {

            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {
                ret.push(objects[i][1]);
            }
        }

        return ret;
    };

    /**
     * Retrieves the FIRST object that matches the given type
     *
     * @param  string type   The type of object to look for
     * @return object        The FIRST object that matches the given type
     */
    RG.OR.first = RG.OR.getFirstObjectByType = function (type) {
        var objects = RG.ObjectRegistry.objects.byUID;

        for (var i = 0, len = objects.length; i < len; ++i) {
            if (objects[i] && objects[i][1] && objects[i][1].type == type) {
                return objects[i][1];
            }
        }

        return null;
    };

    /**
     * This takes centerx, centery, x and y coordinates and returns the
     * appropriate angle relative to the canvas angle system. Remember
     * that the canvas angle system starts at the EAST axis
     *
     * @param  number cx  The centerx coordinate
     * @param  number cy  The centery coordinate
     * @param  number x   The X coordinate (eg the mouseX if coming from a click)
     * @param  number y   The Y coordinate (eg the mouseY if coming from a click)
     * @return number     The relevant angle (measured in in RADIANS)
     */
    RG.getAngleByXY = function (cx, cy, x, y) {
        var angle = ma.atan((y - cy) / (x - cx));
        angle = ma.abs(angle);

        if (x >= cx && y >= cy) {
            angle += RG.TWOPI;
        } else if (x >= cx && y < cy) {
            angle = RG.HALFPI - angle + (RG.PI + RG.HALFPI);
        } else if (x < cx && y < cy) {
            angle += RG.PI;
        } else {
            angle = RG.PI - angle;
        }

        /**
         * Upper and lower limit checking
         */
        if (angle > RG.TWOPI) {
            angle -= RG.TWOPI;
        }

        return angle;
    };

    /**
     * This function returns the distance between two points. In effect the
     * radius of an imaginary circle that is centered on x1 and y1. The name
     * of this function is derived from the word "Hypoteneuse", which in
     * trigonmetry is the longest side of a triangle
     *
     * @param number x1 The original X coordinate
     * @param number y1 The original Y coordinate
     * @param number x2 The target X coordinate
     * @param number y2 The target Y  coordinate
     */
    RG.getHypLength = function (x1, y1, x2, y2) {
        var ret = ma.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));

        return ret;
    };

    /**
     * This function gets the end point (X/Y coordinates) of a given radius.
     * You pass it the center X/Y and the radius and this function will return
     * the endpoint X/Y coordinates.
     *
     * @param number cx The center X coord
     * @param number cy The center Y coord
     * @param number r  The lrngth of the radius
     */
    RG.getRadiusEndPoint = function (cx, cy, angle, radius) {
        var x = cx + ma.cos(angle) * radius;
        var y = cy + ma.sin(angle) * radius;

        return [x, y];
    };

    /**
     * This installs all of the event listeners
     *
     * @param object obj The chart object
     */
    RG.installEventListeners = RG.InstallEventListeners = function (obj) {
        var prop = obj.properties;

        /**
         * Don't attempt to install event listeners for older versions of MSIE
         */
        if (RG.ISOLD) {
            return;
        }

        /**
         * If this function exists, then the dynamic file has been included.
         */
        if (RG.installCanvasClickListener) {

            RG.installWindowMousedownListener(obj);
            RG.installWindowMouseupListener(obj);
            RG.installCanvasMousemoveListener(obj);
            RG.installCanvasMouseupListener(obj);
            RG.installCanvasMousedownListener(obj);
            RG.installCanvasClickListener(obj);
        } else if (RG.hasTooltips(obj) || prop['chart.adjustable'] || prop['chart.annotatable'] || prop['chart.contextmenu'] || prop['chart.resizable'] || prop['chart.key.interactive'] || prop['chart.events.click'] || prop['chart.events.mousemove'] || typeof obj.onclick === 'function' || typeof obj.onmousemove === 'function') {

            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');
        }
    };

    /**
     * Loosly mimicks the PHP function print_r();
     */
    RG.pr = function (obj) {
        var indent = arguments[2] ? arguments[2] : '    ';
        var str = '';

        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;

        if (counter >= 5) {
            return '';
        }

        switch (typeof obj) {

            case 'string':
                str += obj + ' (' + typeof obj + ', ' + obj.length + ')';break;
            case 'number':
                str += obj + ' (' + typeof obj + ')';break;
            case 'boolean':
                str += obj + ' (' + typeof obj + ')';break;
            case 'function':
                str += 'function () {}';break;
            case 'undefined':
                str += 'undefined';break;
            case 'null':
                str += 'null';break;

            case 'object':
                // In case of null
                if (RGraph.is_null(obj)) {
                    str += indent + 'null\n';
                } else {
                    str += indent + 'Object {' + '\n';
                    for (j in obj) {
                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\n';
                    }
                    str += indent + '}';
                }
                break;

            default:
                str += 'Unknown type: ' + typeof obj + '';
                break;
        }

        /**
         * Finished, now either return if we're in a recursed call, or alert()
         * if we're not.
         */
        if (!arguments[1]) {
            alert(str);
        }

        return str;
    };

    /**
     * Produces a dashed line
     *
     * @param object co The 2D context
     * @param number x1 The start X coordinate
     * @param number y1 The start Y coordinate
     * @param number x2 The end X coordinate
     * @param number y2 The end Y coordinate
     */
    RG.dashedLine = RG.DashedLine = function (co, x1, y1, x2, y2) {
        /**
         * This is the size of the dashes
         */
        var size = 5;

        /**
         * The optional fifth argument can be the size of the dashes
         */
        if (typeof arguments[5] === 'number') {
            size = arguments[5];
        }

        var dx = x2 - x1;
        var dy = y2 - y1;
        var num = ma.floor(ma.sqrt(dx * dx + dy * dy) / size);

        var xLen = dx / num;
        var yLen = dy / num;

        var count = 0;

        do {
            count % 2 == 0 && count > 0 ? co.lineTo(x1, y1) : co.moveTo(x1, y1);

            x1 += xLen;
            y1 += yLen;
        } while (count++ <= num);
    };

    /**
     * Makes an AJAX call. It calls the given callback (a function) when ready
     *
     * @param string   url      The URL to retrieve
     * @param function callback A function that is called when the response is ready, there's an example below
     *                          called "myCallback".
     */
    RG.AJAX = function (url, callback) {
        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

            // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }

        httpRequest.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;

                this.__user_callback__(this.responseText);
            }
        };

        httpRequest.open('GET', url, true);
        httpRequest.send();
    };

    /**
     * Makes an AJAX POST request. It calls the given callback (a function) when ready
     *
     * @param string   url      The URL to retrieve
     * @param object   data     The POST data
     * @param function callback A function that is called when the response is ready, there's an example below
     *                          called "myCallback".
     */
    RG.AJAX.POST = function (url, data, callback) {
        // Used when building the POST string
        var crumbs = [];

        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

            // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }

        httpRequest.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;
                this.__user_callback__(this.responseText);
            }
        };

        httpRequest.open('POST', url, true);
        httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

        for (i in data) {
            if (typeof i == 'string') {
                crumbs.push(i + '=' + encodeURIComponent(data[i]));
            }
        }

        httpRequest.send(crumbs.join('&'));
    };

    /**
     * Uses the above function but calls the call back passing a number as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the number as an argument)
     */
    RG.AJAX.getNumber = function (url, callback) {
        RG.AJAX(url, function () {
            var num = parseFloat(this.responseText);

            callback(num);
        });
    };

    /**
     * Uses the above function but calls the call back passing a string as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the string as an argument)
     */
    RG.AJAX.getString = function (url, callback) {
        RG.AJAX(url, function () {
            var str = String(this.responseText);

            callback(str);
        });
    };

    /**
     * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the JSON object as an argument)
     */
    RG.AJAX.getJSON = function (url, callback) {
        RG.AJAX(url, function () {
            var json = eval('(' + this.responseText + ')');

            callback(json);
        });
    };

    /**
     * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
     * Useful if you're retrieving CSV data
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the CSV/array as an argument)
     */
    RG.AJAX.getCSV = function (url, callback) {
        var seperator = arguments[2] ? arguments[2] : ',';

        RG.AJAX(url, function () {
            var regexp = new RegExp(seperator);
            var arr = this.responseText.split(regexp);

            // Convert the strings to numbers
            for (var i = 0, len = arr.length; i < len; ++i) {
                arr[i] = parseFloat(arr[i]);
            }

            callback(arr);
        });
    };

    /**
     * Rotates the canvas
     *
     * @param object canvas The canvas to rotate
     * @param  int   x      The X coordinate about which to rotate the canvas
     * @param  int   y      The Y coordinate about which to rotate the canvas
     * @param  int   angle  The angle(in RADIANS) to rotate the canvas by
     */
    RG.rotateCanvas = RG.RotateCanvas = function (ca, x, y, angle) {
        var co = ca.getContext('2d');

        co.translate(x, y);
        co.rotate(angle);
        co.translate(0 - x, 0 - y);
    };

    /**
     * Measures text by creating a DIV in the document and adding the relevant text to it.
     * Then checking the .offsetWidth and .offsetHeight.
     *
     * @param  string text   The text to measure
     * @param  bool   bold   Whether the text is bold or not
     * @param  string font   The font to use
     * @param  size   number The size of the text (in pts)
     * @return array         A two element array of the width and height of the text
     */
    RG.measureText = RG.MeasureText = function (text, bold, font, size) {
        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
        if (typeof RG.measuretext_cache === 'undefined') {
            RG.measuretext_cache = [];
        }

        var str = text + ':' + bold + ':' + font + ':' + size;
        if (typeof RG.measuretext_cache == 'object' && RG.measuretext_cache[str]) {
            return RG.measuretext_cache[str];
        }

        if (!RG.measuretext_cache['text-div']) {
            var div = document.createElement('DIV');
            div.style.position = 'absolute';
            div.style.top = '-100px';
            div.style.left = '-100px';
            document.body.appendChild(div);

            // Now store the newly created DIV
            RG.measuretext_cache['text-div'] = div;
        } else if (RG.measuretext_cache['text-div']) {
            var div = RG.measuretext_cache['text-div'];
        }

        div.innerHTML = text.replace(/\r\n/g, '<br />');
        div.style.fontFamily = font;
        div.style.fontWeight = bold ? 'bold' : 'normal';
        div.style.fontSize = (size || 12) + 'pt';

        var size = [div.offsetWidth, div.offsetHeight];

        //document.body.removeChild(div);
        RG.measuretext_cache[str] = size;

        return size;
    };

    /* New text function. Accepts two arguments:
     *  o obj - The chart object
     *  o opt - An object/hash/map of properties. This can consist of:
     *          x                The X coordinate (REQUIRED)
     *          y                The Y coordinate (REQUIRED)
     *          text             The text to show (REQUIRED)
     *          font             The font to use
     *          size             The size of the text (in pt)
     *          italic           Whether the text should be italic or not
     *          bold             Whether the text shouldd be bold or not
     *          marker           Whether to show a marker that indicates the X/Y coordinates
     *          valign           The vertical alignment
     *          halign           The horizontal alignment
     *          bounding         Whether to draw a bounding box for the text
     *          boundingStroke   The strokeStyle of the bounding box
     *          boundingFill     The fillStyle of the bounding box
     *          accessible       If false this will cause the text to be
     *                           rendered as native canvas text. DOM text otherwise
     */
    RG.text2 = RG.Text2 = function (obj, opt) {
        /**
         * Use DOM nodes to get better quality text. This option is BETA quality
         * code and most likely and will not work if you use 3D or if you use
         * your own transformations.
         */
        function domtext() {
            /**
             * Check the font property to see if it contains the italic keyword,
             * and if it does then take it out and set the italic property
             */
            if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {
                opt.size = opt.size.replace(/ *italic +/, '');
                opt.italic = true;
            }

            // Used for caching the DOM node
            var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;

            // Wrap the canvas in a DIV
            if (!ca.rgraph_domtext_wrapper) {
                var wrapper = document.createElement('div');
                wrapper.id = ca.id + '_rgraph_domtext_wrapper';
                wrapper.className = 'rgraph_domtext_wrapper';

                // The wrapper can be configured to hide or show the
                // overflow with the textAccessibleOverflow option
                wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';

                wrapper.style.width = ca.offsetWidth + 'px';
                wrapper.style.height = ca.offsetHeight + 'px';

                wrapper.style.cssFloat = ca.style.cssFloat;
                wrapper.style.display = ca.style.display || 'inline-block';
                wrapper.style.position = ca.style.position || 'relative';
                wrapper.style.left = ca.style.left;
                wrapper.style.top = ca.style.top;
                wrapper.style.width = ca.width + 'px';
                wrapper.style.height = ca.height + 'px';

                ca.style.position = 'absolute';
                ca.style.left = 0;
                ca.style.top = 0;
                ca.style.display = 'inline';
                ca.style.cssFloat = 'none';

                if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {
                    wrapper.style.transform = 'skewY(5.7deg)';
                }

                ca.parentNode.insertBefore(wrapper, ca);

                // Remove the canvas from the DOM and put it in the wrapper
                ca.parentNode.removeChild(ca);
                wrapper.appendChild(ca);

                ca.rgraph_domtext_wrapper = wrapper;

                // TODO Add a subwrapper here
            } else {
                wrapper = ca.rgraph_domtext_wrapper;
            }

            var defaults = {
                size: 12,
                font: 'Arial',
                italic: 'normal',
                bold: 'normal',
                valign: 'bottom',
                halign: 'left',
                marker: true,
                color: co.fillStyle,
                bounding: {
                    enabled: false,
                    fill: 'rgba(255,255,255,0.7)',
                    stroke: '#666'
                }
            };

            // Transform \n to the string [[RETURN]] which is then replaced
            // further down
            opt.text = String(opt.text).replace(/\r?\n/g, '[[RETURN]]');

            // Create the node cache array that nodes
            // already created are stored in
            if (typeof RG.text2.domNodeCache === 'undefined') {
                RG.text2.domNodeCache = new Array();
            }

            if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {
                RG.text2.domNodeCache[obj.id] = new Array();
            }

            // Create the dimension cache array that node
            // dimensions are stored in
            if (typeof RG.text2.domNodeDimensionCache === 'undefined') {
                RG.text2.domNodeDimensionCache = new Array();
            }

            if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {
                RG.text2.domNodeDimensionCache[obj.id] = new Array();
            }

            // Create the DOM node
            if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {

                var span = document.createElement('span');
                span.style.position = 'absolute';
                span.style.display = 'inline';

                span.style.left = opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width)) + 'px';
                span.style.top = opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)) + 'px';
                span.style.color = opt.color || defaults.color;
                span.style.fontFamily = opt.font || defaults.font;
                span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;
                span.style.fontStyle = opt.italic ? 'italic' : defaults.italic;
                span.style.fontSize = (opt.size || defaults.size) + 'pt';
                span.style.whiteSpace = 'nowrap';
                span.tag = opt.tag;

                // CSS angled text. This should be conasidered BETA quality code at the moment,
                // but it seems to be OK. You may need to use the labelsOffsety when using this
                // option.
                if (typeof opt.angle === 'number' && opt.angle !== 0) {

                    var coords = RG.measureText(opt.text, opt.bold, opt.font, opt.size);

                    //span.style.left = parseFloat(span.style.left) - coords[0] + 'px';
                    span.style.transformOrigin = '100% 50%';
                    span.style.transform = 'rotate(' + opt.angle + 'deg)';
                }

                // Shadow
                span.style.textShadow = '{1}px {2}px {3}px {4}'.format(co.shadowOffsetX, co.shadowOffsetY, co.shadowBlur, co.shadowColor);

                if (opt.bounding) {
                    span.style.border = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);
                    span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;
                }
                // Pointer events
                if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' || obj.properties['chart.text.accessible.pointerevents']) && obj.properties['chart.text.accessible.pointerevents'] !== 'none') {

                    span.style.pointerEvents = 'auto';
                } else {
                    span.style.pointerEvents = 'none';
                }

                span.style.padding = opt.bounding ? '2px' : null;
                span.__text__ = opt.text;
                span.innerHTML = opt.text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');

                // Now replace the string [[RETURN]] with a <br />
                span.innerHTML = span.innerHTML.replace(/\[\[RETURN\]\]/g, '<br />');

                wrapper.appendChild(span);

                // Alignment defaults
                opt.halign = opt.halign || 'left';
                opt.valign = opt.valign || 'bottom';

                // Horizontal alignment
                if (opt.halign === 'right') {
                    span.style.left = parseFloat(span.style.left) - span.offsetWidth + 'px';
                    span.style.textAlign = 'right';
                } else if (opt.halign === 'center') {
                    span.style.left = parseFloat(span.style.left) - span.offsetWidth / 2 + 'px';
                    span.style.textAlign = 'center';
                }

                // Vertical alignment
                if (opt.valign === 'top') {
                    // Nothing to do here
                } else if (opt.valign === 'center') {
                    span.style.top = parseFloat(span.style.top) - span.offsetHeight / 2 + 'px';
                } else {
                    span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';
                }

                var offsetWidth = parseFloat(span.offsetWidth),
                    offsetHeight = parseFloat(span.offsetHeight),
                    top = parseFloat(span.style.top),
                    left = parseFloat(span.style.left);

                RG.text2.domNodeCache[obj.id][cacheKey] = span;
                RG.text2.domNodeDimensionCache[obj.id][cacheKey] = {
                    left: left,
                    top: top,
                    width: offsetWidth,
                    height: offsetHeight
                };
                span.id = cacheKey;
            } else {
                span = RG.text2.domNodeCache[obj.id][cacheKey];
                span.style.display = 'inline';

                var offsetWidth = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,
                    offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,
                    top = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,
                    left = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;
            }

            // If requested, draw a marker to indicate the coords
            if (opt.marker) {
                RG.path2(context, 'b m % % l % % m % % l % % s', opt.x - 5, opt.y, opt.x + 5, opt.y, opt.x, opt.y - 5, opt.x, opt.y + 5);
            }

            /**
             * If its a drawing API text object then allow
             * for events and tooltips
             */
            if (obj.type === 'drawing.text') {
                // Mousemove
                if (obj.properties['chart.events.mousemove']) {
                    span.addEventListener('mousemove', function (e) {
                        obj.properties['chart.events.mousemove'](e, obj);
                    }, false);
                }

                // Click
                if (obj.properties['chart.events.click']) {
                    span.addEventListener('click', function (e) {
                        obj.properties['chart.events.click'](e, obj);
                    }, false);
                }

                // Tooltips
                if (obj.properties['chart.tooltips']) {
                    span.addEventListener(obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click', function (e) {
                        if (!RG.Registry.get('chart.tooltip') || RG.Registry.get('chart.tooltip').__index__ !== 0 || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid) {

                            RG.hideTooltip();
                            RG.redraw();
                            RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);
                        }
                    }, false);
                }
            }

            // Build the return value
            var ret = {};
            ret.x = left;
            ret.y = top;
            ret.width = offsetWidth;
            ret.height = offsetHeight;
            ret.object = obj;
            ret.text = opt.text;
            ret.tag = opt.tag;

            // The reset() function clears the domNodeCache
            ////
            // @param object OPTIONAL You can pass in the canvas to limit the
            //                        clearing to that canvas.
            RG.text2.domNodeCache.reset = function () {
                // Limit the clearing to a single canvas tag
                if (arguments[0]) {

                    var nodes = RG.text2.domNodeCache[arguments[0].id];
                    for (j in nodes) {
                        var node = RG.text2.domNodeCache[arguments[0].id][j];

                        if (node && node.parentNode) {
                            node.parentNode.removeChild(node);
                        }
                    }

                    // Clear all DOM text from all tags
                } else {
                    for (i in RG.text2.domNodeCache) {
                        for (j in RG.text2.domNodeCache[i]) {
                            if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {
                                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);
                            }
                        }
                    }
                }
            };

            //
            // Helps you get hold of the SPAN tag nodes that hold the text on the chart
            //
            RG.text2.find = function (opt) {
                var span,
                    nodes = [];
                var id = typeof opt.id === 'string' ? opt.id : opt.object.id;
                for (i in RG.text2.domNodeCache[id]) {

                    span = RG.text2.domNodeCache[id][i];

                    // A full tag is given
                    if (typeof opt.tag === 'string' && opt.tag === span.tag) {
                        nodes.push(span);
                        continue;
                    }

                    // A regex is given as the tag
                    if (typeof opt.tag === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {

                        var regexp = new RegExp(opt.tag);

                        if (regexp.test(span.tag)) {
                            nodes.push(span);
                            continue;
                        }
                    }

                    // A full text is given
                    if (typeof opt.text === 'string' && opt.text === span.__text__) {
                        nodes.push(span);
                        continue;
                    }

                    // Regex for the text is given
                    // A regex is given as the tag
                    if (typeof opt.text === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {

                        var regexp = new RegExp(opt.text);

                        if (regexp.test(span.__text__)) {
                            nodes.push(span);

                            continue;
                        }
                    }
                }

                return nodes;
            };

            //
            // Add the SPAN tag to the return value
            //
            ret.node = span;

            /**
             * Save and then return the details of the text (but oly
             * if it's an RGraph object that was given)
             */
            if (obj && obj.isRGraph && obj.coordsText) {
                obj.coordsText.push(ret);
            }

            return ret;
        }

        /**
         * An RGraph object can be given, or a string or the 2D rendering context
         * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function
         * still returns the cooords though in all cases.
         */
        if (obj && obj.isRGraph) {
            var obj = obj;
            var co = obj.context;
            var ca = obj.canvas;
        } else if (typeof obj == 'string') {
            var ca = document.getElementById(obj);
            var co = ca.getContext('2d');
            var obj = ca.__object__;
        } else if (typeof obj.getContext === 'function') {
            var ca = obj;
            var co = ca.getContext('2d');
            var obj = ca.__object__;
        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {
            var co = obj;
            var ca = obj.canvas;
            var obj = ca.__object__;

            // IE7/8
        } else if (RG.ISOLD && obj.fillText) {
            var co = obj;
            var ca = obj.canvas;
            var obj = ca.__object__;
        }

        /**
         * Changed the name of boundingFill/boundingStroke - this allows you to still use those names
         */
        if (typeof opt.boundingFill === 'string') opt['bounding.fill'] = opt.boundingFill;
        if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;

        if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {
            return domtext();
        }

        var x = opt.x,
            y = opt.y,
            originalX = x,
            originalY = y,
            text = opt.text,
            text_multiline = typeof text === 'string' ? text.split(/\r?\n/g) : '',
            numlines = text_multiline.length,
            font = opt.font ? opt.font : 'Arial',
            size = opt.size ? opt.size : 10,
            size_pixels = size * 1.5,
            bold = opt.bold,
            italic = opt.italic,
            halign = opt.halign ? opt.halign : 'left',
            valign = opt.valign ? opt.valign : 'bottom',
            tag = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',
            marker = opt.marker,
            angle = opt.angle || 0;

        var bounding = opt.bounding,
            bounding_stroke = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',
            bounding_fill = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',
            bounding_shadow = opt['bounding.shadow'],
            bounding_shadow_color = opt['bounding.shadow.color'] || '#ccc',
            bounding_shadow_blur = opt['bounding.shadow.blur'] || 3,
            bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,
            bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,
            bounding_linewidth = opt['bounding.linewidth'] || 1;

        /**
         * Initialize the return value to an empty object
         */
        var ret = {};

        //
        // Color
        //
        if (typeof opt.color === 'string') {
            var orig_fillstyle = co.fillStyle;
            co.fillStyle = opt.color;
        }

        /**
         * The text arg must be a string or a number
         */
        if (typeof text == 'number') {
            text = String(text);
        }

        if (typeof text !== 'string') {
            return;
        }

        /**
         * This facilitates vertical text
         */
        if (angle != 0) {
            co.save();
            co.translate(x, y);
            co.rotate(ma.PI / 180 * angle);
            x = 0;
            y = 0;
        }

        /**
         * Set the font
         */
        co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;

        /**
         * Measure the width/height. This must be done AFTER the font has been set
         */
        var width = 0;
        for (var i = 0; i < numlines; ++i) {
            width = ma.max(width, co.measureText(text_multiline[i]).width);
        }
        var height = size_pixels * numlines;

        /**
         * Accommodate old MSIE 7/8
         */
        //if (document.all && RGraph.ISOLD) {
        //y += 2;
        //}


        /**
         * If marker is specified draw a marker at the X/Y coordinates
         */
        if (opt.marker) {
            var marker_size = 10;
            var strokestyle = co.strokeStyle;
            co.beginPath();
            co.strokeStyle = 'red';
            co.moveTo(x, y - marker_size);
            co.lineTo(x, y + marker_size);
            co.moveTo(x - marker_size, y);
            co.lineTo(x + marker_size, y);
            co.stroke();
            co.strokeStyle = strokestyle;
        }

        /**
         * Set the horizontal alignment
         */
        if (halign == 'center') {
            co.textAlign = 'center';
            var boundingX = x - 2 - width / 2;
        } else if (halign == 'right') {
            co.textAlign = 'right';
            var boundingX = x - 2 - width;
        } else {
            co.textAlign = 'left';
            var boundingX = x - 2;
        }

        /**
         * Set the vertical alignment
         */
        if (valign == 'center') {

            co.textBaseline = 'middle';
            // Move the text slightly
            y -= 1;

            y -= (numlines - 1) / 2 * size_pixels;
            var boundingY = y - size_pixels / 2 - 2;
        } else if (valign == 'top') {
            co.textBaseline = 'top';

            var boundingY = y - 2;
        } else {

            co.textBaseline = 'bottom';

            // Move the Y coord if multiline text
            if (numlines > 1) {
                y -= (numlines - 1) * size_pixels;
            }

            var boundingY = y - size_pixels - 2;
        }

        var boundingW = width + 4;
        var boundingH = height + 4;

        /**
         * Draw a bounding box if required
         */
        if (bounding) {

            var pre_bounding_linewidth = co.lineWidth;
            var pre_bounding_strokestyle = co.strokeStyle;
            var pre_bounding_fillstyle = co.fillStyle;
            var pre_bounding_shadowcolor = co.shadowColor;
            var pre_bounding_shadowblur = co.shadowBlur;
            var pre_bounding_shadowoffsetx = co.shadowOffsetX;
            var pre_bounding_shadowoffsety = co.shadowOffsetY;

            co.lineWidth = bounding_linewidth;
            co.strokeStyle = bounding_stroke;
            co.fillStyle = bounding_fill;

            if (bounding_shadow) {
                co.shadowColor = bounding_shadow_color;
                co.shadowBlur = bounding_shadow_blur;
                co.shadowOffsetX = bounding_shadow_offsetx;
                co.shadowOffsetY = bounding_shadow_offsety;
            }

            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
            co.strokeRect(boundingX, boundingY, boundingW, boundingH);
            co.fillRect(boundingX, boundingY, boundingW, boundingH);

            // Reset the linewidth,colors and shadow to it's original setting
            co.lineWidth = pre_bounding_linewidth;
            co.strokeStyle = pre_bounding_strokestyle;
            co.fillStyle = pre_bounding_fillstyle;
            co.shadowColor = pre_bounding_shadowcolor;
            co.shadowBlur = pre_bounding_shadowblur;
            co.shadowOffsetX = pre_bounding_shadowoffsetx;
            co.shadowOffsetY = pre_bounding_shadowoffsety;
        }

        /**
         * Draw the text
         */
        if (numlines > 1) {
            for (var i = 0; i < numlines; ++i) {
                co.fillText(text_multiline[i], x, y + size_pixels * i);
            }
        } else {
            co.fillText(text, x + 0.5, y + 0.5);
        }

        /**
         * If the text is at 90 degrees restore() the canvas - getting rid of the rotation
         * and the translate that we did
         */
        if (angle != 0) {
            if (angle == 90) {
                if (halign == 'left') {
                    if (valign == 'bottom') {
                        boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                } else if (halign == 'center') {
                    if (valign == 'bottom') {
                        boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                } else if (halign == 'right') {
                    if (valign == 'bottom') {
                        boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                }
            } else if (angle == 180) {

                if (halign == 'left') {
                    if (valign == 'bottom') {
                        boundingX = originalX - width - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - width - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - width - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                } else if (halign == 'center') {
                    if (valign == 'bottom') {
                        boundingX = originalX - width / 2 - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - width / 2 - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - width / 2 - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                } else if (halign == 'right') {
                    if (valign == 'bottom') {
                        boundingX = originalX - 2;boundingY = originalY - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - 2;boundingY = originalY - height / 2 - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - 2;boundingY = originalY - height - 2;boundingW = width + 4;boundingH = height + 4;
                    }
                }
            } else if (angle == 270) {

                if (halign == 'left') {
                    if (valign == 'bottom') {
                        boundingX = originalX - height - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 4;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - 2;boundingY = originalY - width - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                } else if (halign == 'center') {
                    if (valign == 'bottom') {
                        boundingX = originalX - height - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 4;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - 2;boundingY = originalY - width / 2 - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                } else if (halign == 'right') {
                    if (valign == 'bottom') {
                        boundingX = originalX - height - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'center') {
                        boundingX = originalX - height / 2 - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                    if (valign == 'top') {
                        boundingX = originalX - 2;boundingY = originalY - 2;boundingW = height + 4;boundingH = width + 4;
                    }
                }
            }

            co.restore();
        }

        /**
         * Reset the text alignment so that text rendered after this text function is not affected
         */
        co.textBaseline = 'alphabetic';
        co.textAlign = 'left';

        /**
         * Fill the ret variable with details of the text
         */
        ret.x = boundingX;
        ret.y = boundingY;
        ret.width = boundingW;
        ret.height = boundingH;
        ret.object = obj;
        ret.text = text;
        ret.tag = tag;

        /**
         * Save and then return the details of the text (but oly
         * if it's an RGraph object that was given)
         */
        if (obj && obj.isRGraph && obj.coordsText) {
            obj.coordsText.push(ret);
        }

        //
        // Restore the original fillstyle
        //
        if (typeof orig_fillstyle === 'string') {
            co.fillStyle = orig_fillstyle;
        }

        return ret;
    };

    /**
     * Takes a sequential index abd returns the group/index variation of it. Eg if you have a
     * sequential index from a grouped bar chart this function can be used to convert that into
     * an appropriate group/index combination
     *
     * @param nindex number The sequential index
     * @param data   array  The original data (which is grouped)
     * @return              The group/index information
     */
    RG.sequentialIndexToGrouped = function (index, data) {
        var group = 0;
        var grouped_index = 0;

        while (--index >= 0) {

            if (RG.is_null(data[group])) {
                group++;
                grouped_index = 0;
                continue;
            }

            // Allow for numbers as well as arrays in the dataset
            if (typeof data[group] == 'number') {
                group++;
                grouped_index = 0;
                continue;
            }

            grouped_index++;

            if (grouped_index >= data[group].length) {
                group++;
                grouped_index = 0;
            }
        }

        return [group, grouped_index];
    };

    /**
     * This function highlights a rectangle
     *
     * @param object obj    The chart object
     * @param number shape  The coordinates of the rect to highlight
     */
    RG.Highlight.rect = RG.Highlight.Rect = function (obj, shape) {
        var ca = obj.canvas;
        var co = obj.context;
        var prop = obj.properties;

        if (prop['chart.tooltips.highlight']) {

            // Safari seems to need this
            co.lineWidth = 1;

            /**
             * Draw a rectangle on the canvas to highlight the appropriate area
             */
            co.beginPath();

            co.strokeStyle = prop['chart.highlight.stroke'];
            co.fillStyle = prop['chart.highlight.fill'];

            co.rect(shape['x'], shape['y'], shape['width'], shape['height']);
            //co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);
            co.stroke();
            co.fill();
        }
    };

    /**
     * This function highlights a point
     *
     * @param object obj    The chart object
     * @param number shape  The coordinates of the rect to highlight
     */
    RG.Highlight.point = RG.Highlight.Point = function (obj, shape) {
        var prop = obj.properties;
        var ca = obj.canvas;
        var co = obj.context;

        if (prop['chart.tooltips.highlight']) {

            /**
             * Draw a rectangle on the canvas to highlight the appropriate area
             */
            co.beginPath();
            co.strokeStyle = prop['chart.highlight.stroke'];
            co.fillStyle = prop['chart.highlight.fill'];
            var radius = prop['chart.highlight.point.radius'] || 2;
            co.arc(shape['x'], shape['y'], radius, 0, RG.TWOPI, 0);
            co.stroke();
            co.fill();
        }
    };

    /**
     * This is the same as Date.parse - though a little more flexible.
     *
     * @param string str The date string to parse
     * @return Returns the same thing as Date.parse
     */
    RG.parseDate = function (str) {

        str = RG.trim(str);

        // Allow for: now (just the word "now")
        if (str === 'now') {
            str = new Date().toString();
        }

        // Allow for: 22-11-2013
        // Allow for: 22/11/2013
        // Allow for: 22-11-2013 12:09:09
        // Allow for: 22/11/2013 12:09:09
        if (str.match(/^(\d\d)(?:-|\/)(\d\d)(?:-|\/)(\d\d\d\d)(.*)$/)) {
            str = '{1}/{2}/{3}{4}'.format(RegExp.$3, RegExp.$2, RegExp.$1, RegExp.$4);
        }

        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12
        if (str.match(/^(\d\d\d\d)(-|\/)(\d\d)(-|\/)(\d\d)( |T)(\d\d):(\d\d):(\d\d)$/)) {
            str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;
        }

        // Allow for: 2013-11-22
        if (str.match(/^\d\d\d\d-\d\d-\d\d$/)) {
            str = str.replace(/-/g, '/');
        }

        // Allow for: 12:09:44 (time only using todays date)
        if (str.match(/^\d\d:\d\d:\d\d$/)) {

            var dateObj = new Date();
            var date = dateObj.getDate();
            var month = dateObj.getMonth() + 1;
            var year = dateObj.getFullYear();

            // Pad the date/month with a zero if it's not two characters
            if (String(month).length === 1) month = '0' + month;
            if (String(date).length === 1) date = '0' + date;

            str = year + '/' + month + '/' + date + ' ' + str;
        }

        return Date.parse(str);
    };

    /**
     * Reset all of the color values to their original values
     *
     * @param object
     */
    RG.resetColorsToOriginalValues = function (obj) {
        if (obj.original_colors) {
            // Reset the colors to their original values
            for (var j in obj.original_colors) {
                if (typeof j === 'string' && j.substr(0, 6) === 'chart.') {
                    obj.properties[j] = RG.arrayClone(obj.original_colors[j]);
                }
            }
        }

        /**
         * If the function is present on the object to reset specific colors - use that
         */
        if (typeof obj.resetColorsToOriginalValues === 'function') {
            obj.resetColorsToOriginalValues();
        }

        // Reset the colorsParsed flag so that they're parsed for gradients again
        obj.colorsParsed = false;
    };

    /**
     * Creates a Linear gradient
     *
     * @param object obj The chart object
     * @param number x1 The start X coordinate
     * @param number x2 The end X coordinate
     * @param number y1 The start Y coordinate
     * @param number y2 The end Y coordinate
     * @param string color1 The start color
     * @param string color2 The end color
     */
    RG.linearGradient = RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2) {
        var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);
        var numColors = arguments.length - 5;

        for (var i = 5; i < arguments.length; ++i) {

            var color = arguments[i];
            var stop = (i - 5) / (numColors - 1);

            gradient.addColorStop(stop, color);
        }

        return gradient;
    };

    /**
     * Creates a Radial gradient
     *
     * @param object obj The chart object
     * @param number x1 The start X coordinate
     * @param number x2 The end X coordinate
     * @param number y1 The start Y coordinate
     * @param number y2 The end Y coordinate
     * @param string color1 The start color
     * @param string color2 The end color
     */
    RG.radialGradient = RG.RadialGradient = function (obj, x1, y1, r1, x2, y2, r2, color1, color2) {
        var gradient = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);
        var numColors = arguments.length - 7;

        for (var i = 7; i < arguments.length; ++i) {

            var color = arguments[i];
            var stop = (i - 7) / (numColors - 1);

            gradient.addColorStop(stop, color);
        }

        return gradient;
    };

    /**
     * Adds an event listener to RGraphs internal array so that RGraph can track them.
     * This DOESN'T add the event listener to the canvas/window.
     *
     * 5/1/14 TODO Used in the tooltips file, but is it necessary any more?
     */
    RG.addEventListener = RG.AddEventListener = function (id, e, func) {
        var type = arguments[3] ? arguments[3] : 'unknown';

        RG.Registry.get('chart.event.handlers').push([id, e, func, type]);
    };

    /**
     * Clears event listeners that have been installed by RGraph
     *
     * @param string id The ID of the canvas to clear event listeners for - or 'window' to clear
     *                  the event listeners attached to the window
     */
    RG.clearEventListeners = RG.ClearEventListeners = function (id) {
        if (id && id == 'window') {

            window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);
            window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);
        } else {

            var canvas = document.getElementById(id);

            canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);
            canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);
            canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);
            canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);
        }
    };

    /**
     * Hides the annotating palette. It's here because it can be called
     * from code other than the annotating code.
     */
    RG.hidePalette = RG.HidePalette = function () {
        var div = RG.Registry.get('palette');

        if (typeof div == 'object' && div) {

            div.style.visibility = 'hidden';
            div.style.display = 'none';

            RG.Registry.set('palette', null);
        }
    };

    /**
     * Generates a random number between the minimum and maximum
     *
     * @param number min The minimum value
     * @param number max The maximum value
     * @param number     OPTIONAL Number of decimal places
     */
    RG.random = function (min, max) {
        var dp = arguments[2] ? arguments[2] : 0;
        var r = ma.random();

        return Number(((max - min) * r + min).toFixed(dp));
    };

    /**
     *
     */
    RG.arrayRand = RG.arrayRandom = RG.random.array = function (num, min, max) {
        for (var i = 0, arr = []; i < num; i += 1) {
            arr.push(RG.random(min, max, arguments[3]));
        }

        return arr;
    };

    /**
     * Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.
     *
     * @param object obj The chart object
     */
    RG.noShadow = RG.NoShadow = function (obj) {
        var co = obj.context;

        co.shadowColor = 'rgba(0,0,0,0)';
        co.shadowBlur = 0;
        co.shadowOffsetX = 0;
        co.shadowOffsetY = 0;
    };

    /**
     * Sets the various shadow properties
     *
     * @param object obj     The chart object
     * @param string color   The color of the shadow
     * @param number offsetx The offsetX value for the shadow
     * @param number offsety The offsetY value for the shadow
     * @param number blur    The blurring value for the shadow
     */
    RG.setShadow = RG.SetShadow = function (obj, color, offsetx, offsety, blur) {
        var co = obj.context;

        co.shadowColor = color;
        co.shadowOffsetX = offsetx;
        co.shadowOffsetY = offsety;
        co.shadowBlur = blur;
    };

    /**
     * Sets an object in the RGraph registry
     *
     * @param string name The name of the value to set
     */
    RG.Registry.set = RG.Registry.Set = function (name, value) {
        // Convert uppercase letters to dot+lower case letter
        name = name.replace(/([A-Z])/g, function (str) {
            return '.' + String(RegExp.$1).toLowerCase();
        });

        // Ensure there is the chart. prefix
        if (name.substr(0, 6) !== 'chart.') {
            name = 'chart.' + name;
        }

        RG.Registry.store[name] = value;

        return value;
    };

    /**
     * Gets an object from the RGraph registry
     *
     * @param string name The name of the value to fetch
     */
    RG.Registry.get = RG.Registry.Get = function (name) {
        // Convert uppercase letters to dot+lower case letter
        name = name.replace(/([A-Z])/g, function (str) {
            return '.' + String(RegExp.$1).toLowerCase();
        });

        // Ensure there is the chart. prefix
        if (name.substr(0, 6) !== 'chart.') {
            name = 'chart.' + name;
        }

        return RG.Registry.store[name];
    };

    /**
     * Converts the given number of degrees to radians. Angles in canvas are measured in radians
     *
     * @param number deg The value to convert
     */
    RG.degrees2Radians = function (deg) {
        return deg * (RG.PI / 180);
    };

    /**
     * Generates logs for... ...log charts
     *
     * @param number n    The number to generate the log for
     * @param number base The base to use
     */
    RG.log = function (n, base) {
        return ma.log(n) / (base ? ma.log(base) : 1);
    };

    /**
     * Determines if the given object is an array or not
     *
     * @param mixed obj The variable to test
     */
    RG.isArray = RG.is_array = function (obj) {
        if (obj && obj.constructor) {
            var pos = obj.constructor.toString().indexOf('Array');
        } else {
            return false;
        }

        return obj != null && typeof pos === 'number' && pos > 0 && pos < 20;
    };

    /**
     * Removes white-space from the start aqnd end of a string
     *
     * @param string str The string to trim
     */
    RG.trim = function (str) {
        return RG.ltrim(RG.rtrim(str));
    };

    /**
     * Trims the white-space from the start of a string
     *
     * @param string str The string to trim
     */
    RG.ltrim = function (str) {
        return str.replace(/^(\s|\0)+/, '');
    };

    /**
     * Trims the white-space off of the end of a string
     *
     * @param string str The string to trim
     */
    RG.rtrim = function (str) {
        return str.replace(/(\s|\0)+$/, '');
    };

    /**
     * Returns true/false as to whether the given variable is null or not
     *
     * @param mixed arg The argument to check
     */
    RG.isNull = RG.is_null = function (arg) {
        // must BE DOUBLE EQUALS - NOT TRIPLE
        if (arg == null || typeof arg === 'object' && !arg) {
            return true;
        }

        return false;
    };

    /**
     * This function facilitates a very limited way of making your charts
     * whilst letting the rest of page continue - using  the setTimeout function
     *
     * @param function func The function to run that creates the chart
     */
    RG.async = RG.Async = function (func) {
        return setTimeout(func, arguments[1] ? arguments[1] : 1);
    };

    /**
     * Resets (more than just clears) the canvas and clears any pertinent objects
     * from the ObjectRegistry
     *
     * @param object ca The canvas object (as returned by document.getElementById() ).
     */
    RG.reset = RG.Reset = function (ca) {
        ca.width = ca.width;

        RG.ObjectRegistry.clear(ca);

        ca.__rgraph_aa_translated__ = false;

        if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {
            RG.text2.domNodeCache.reset(ca);
        }

        // Create the node and dimension caches if they don't already exist
        if (!RG.text2.domNodeCache) {
            RG.text2.domNodeCache = [];
        }
        if (!RG.text2.domNodeDimensionCache) {
            RG.text2.domNodeDimensionCache = [];
        }

        // Create/reset the specific canvas arrays in the caches
        RG.text2.domNodeCache[ca.id] = [];
        RG.text2.domNodeDimensionCache[ca.id] = [];
    };

    /**
     * NOT USED ANY MORE
     */
    RG.att = function (ca) {};

    /**
     * This function is due to be removed.
     *
     * @param string id The ID of what can be either the canvas tag or a DIV tag
     */
    RG.getCanvasTag = function (id) {
        id = typeof id === 'object' ? id.id : id;
        var canvas = doc.getElementById(id);

        return [id, canvas];
    };

    /**
     * A wrapper function that encapsulate requestAnimationFrame
     *
     * @param function func The animation function
     */
    RG.Effects.updateCanvas = RG.Effects.UpdateCanvas = function (func) {
        win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || win.mozRequestAnimationFrame || function (func) {
            setTimeout(func, 16.666);
        };

        win.requestAnimationFrame(func);
    };

    /**
     * This function returns an easing multiplier for effects so they eas out towards the
     * end of the effect.
     *
     * @param number frames The total number of frames
     * @param number frame  The frame number
     */
    RG.Effects.getEasingMultiplier = function (frames, frame) {
        return ma.pow(ma.sin(frame / frames * RG.HALFPI), 3);
    };

    /**
     * This function converts an array of strings to an array of numbers. Its used by the meter/gauge
     * style charts so that if you want you can pass in a string. It supports various formats:
     *
     * '45.2'
     * '-45.2'
     * ['45.2']
     * ['-45.2']
     * '45.2,45.2,45.2' // A CSV style string
     *
     * @param number frames The string or array to parse
     */
    RG.stringsToNumbers = function (str) {
        // An optional seperator to use intead of a comma
        var sep = arguments[1] || ',';

        // If it's already a number just return it
        if (typeof str === 'number') {
            return str;
        }

        if (typeof str === 'string') {
            if (str.indexOf(sep) != -1) {
                str = str.split(sep);
            } else {
                str = parseFloat(str);
            }
        }

        if (typeof str === 'object') {
            for (var i = 0, len = str.length; i < len; i += 1) {
                str[i] = parseFloat(str[i]);
            }
        }

        return str;
    };

    /**
     * Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it
     * and then subsequent calls use that  instead of repeatedly drawing the same thing.
     *
     * @param object   obj  The graph object
     * @param string   id   An ID string used to identify the relevant entry in the cache
     * @param function func The drawing function. This will be called to do the draw.
     */
    RG.cachedDraw = function (obj, id, func) {
        //If the cache entry exists - just copy it across to the main canvas
        if (!RG.cache[id]) {

            RG.cache[id] = {};

            RG.cache[id].object = obj;
            RG.cache[id].canvas = document.createElement('canvas');

            RG.cache[id].canvas.setAttribute('width', obj.canvas.width);
            RG.cache[id].canvas.setAttribute('height', obj.canvas.height);
            RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);

            RG.cache[id].canvas.__object__ = obj;
            RG.cache[id].context = RG.cache[id].canvas.getContext('2d');

            // Antialiasing on the cache canvas
            RG.cache[id].context.translate(0.5, 0.5);

            // Call the function
            func(obj, RG.cache[id].canvas, RG.cache[id].context);
        }

        // Now copy the contents of the cached canvas over to the main one.
        // The coordinates are -0.5 because of the anti-aliasing effect in
        // use on the main canvas
        obj.context.drawImage(RG.cache[id].canvas, -0.5, -0.5);
    };

    /**
     * The function that runs through the supplied configuration and
     * converts it to the RGraph stylee.
     *
     * @param object conf The config
     * @param object      The settings for the object
     */
    RG.parseObjectStyleConfig = function (obj, config) {
        /**
         * The recursion function
         */
        var recurse = function (obj, config, name, settings) {
            var i;

            for (key in config) {

                // Allow for functions in the configuration. Run them immediately
                if (key.match(/^exec[0-9]*$/)) {
                    config[key](obj, settings);
                    continue;
                }

                var isObject = false; // Default value
                var isArray = false; // Default value
                var value = config[key];

                // Change caps to dots. Eg textSize => text.size
                while (key.match(/([A-Z])/)) {
                    key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
                }

                if (!RG.isNull(value) && value.constructor) {
                    isObject = value.constructor.toString().indexOf('Object') > 0;
                    isArray = value.constructor.toString().indexOf('Array') > 0;
                }

                if (isObject && !isArray) {
                    recurse(obj, config[key], name + '.' + key, settings);
                } else if (key === 'self') {
                    settings[name] = value;
                } else {
                    settings[name + '.' + key] = value;
                }
            }

            return settings;
        };

        /**
         * Go through the settings that we've been given
         */
        var settings = recurse(obj, config, 'chart', {});

        /**
         * Go through the settings and set them on the object
         */
        for (key in settings) {
            if (typeof key === 'string') {
                obj.set(key, settings[key]);
            }
        }
    };

    /**
     * This function is a short-cut for the canvas path syntax (which can be rather
     * verbose). You can read a description of it (which details all of the
     * various options) on the RGraph blog (www.rgraph.net/blog). The function is
     * added to the CanvasRenderingContext2D object so it becomes a context function.
     *
     * So you can use it like these examples show:
     *
     * 1. RG.path2(context, 'b r 0 0 50 50 f red');
     * 2. RG.path2(context, 'b a 50 50 50 0 3.14 false f red');
     * 3. RG.path2(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');
     * 4. RG.path2(context, 'b m 5 100 at 50 0 95 100 50 s red');
     * 5. RG.path2(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');
     * 6. RG.path2(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');
     * 7. RG.path2(context, 'ga 0.25 b r 5 5 590 240 f red');
     *
     * @param   array p  The path details
     */
    RG.path2 = function (co, p) {
        // Save this functions arguments
        var args = arguments;

        // If the path was a string - split it then collapse quoted bits together
        if (typeof p === 'string') {
            p = splitstring(p);
        }

        // Store the last path on the RGraph object
        RG.path2.last = RG.arrayClone(p);

        // Go through the path information.
        for (var i = 0, len = p.length; i < len; i += 1) {

            switch (p[i]) {
                case 'b':
                    co.beginPath();break;
                case 'c':
                    co.closePath();break;
                case 'm':
                    co.moveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;
                case 'l':
                    co.lineTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;
                case 's':
                    if (p[i + 1]) co.strokeStyle = p[i + 1];co.stroke();i++;break;
                case 'f':
                    if (p[i + 1]) {
                        co.fillStyle = p[i + 1];
                    }co.fill();i++;break;
                case 'qc':
                    co.quadraticCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;
                case 'bc':
                    co.bezierCurveTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;
                case 'r':
                    co.rect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;
                case 'a':
                    co.arc(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), p[i + 6] === 'true' || p[i + 6] === true || p[i + 6] === 1 || p[i + 6] === '1' ? true : false);i += 6;break;
                case 'at':
                    co.arcTo(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]));i += 5;break;
                case 'lw':
                    co.lineWidth = parseFloat(p[i + 1]);i++;break;
                case 'e':
                    co.ellipse(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]), parseFloat(p[i + 7]), p[i + 8] === 'true' ? true : false);i += 8;break;
                case 'lj':
                    co.lineJoin = p[i + 1];i++;break;
                case 'lc':
                    co.lineCap = p[i + 1];i++;break;
                case 'sc':
                    co.shadowColor = p[i + 1];i++;break;
                case 'sb':
                    co.shadowBlur = parseFloat(p[i + 1]);i++;break;
                case 'sx':
                    co.shadowOffsetX = parseFloat(p[i + 1]);i++;break;
                case 'sy':
                    co.shadowOffsetY = parseFloat(p[i + 1]);i++;break;
                case 'fs':
                    co.fillStyle = p[i + 1];i++;break;
                case 'ss':
                    co.strokeStyle = p[i + 1];i++;break;
                case 'fr':
                    co.fillRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;
                case 'sr':
                    co.strokeRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;
                case 'cl':
                    co.clip();break;
                case 'sa':
                    co.save();break;
                case 'rs':
                    co.restore();break;
                case 'tr':
                    co.translate(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;
                case 'sl':
                    co.scale(parseFloat(p[i + 1]), parseFloat(p[i + 2]));i += 2;break;
                case 'ro':
                    co.rotate(parseFloat(p[i + 1]));i++;break;
                case 'tf':
                    co.transform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;
                case 'stf':
                    co.setTransform(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]), parseFloat(p[i + 5]), parseFloat(p[i + 6]));i += 6;break;
                case 'cr':
                    co.clearRect(parseFloat(p[i + 1]), parseFloat(p[i + 2]), parseFloat(p[i + 3]), parseFloat(p[i + 4]));i += 4;break;
                case 'ld':
                    var parts = p[i + 1];co.setLineDash(parts);i += 1;break;
                case 'ldo':
                    co.lineDashOffset = p[i + 1];i++;break;
                case 'fo':
                    co.font = p[i + 1];i++;break;
                case 'ft':
                    co.fillText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;
                case 'st':
                    co.strokeText(p[i + 1], parseFloat(p[i + 2]), parseFloat(p[i + 3]));i += 3;break;
                case 'ta':
                    co.textAlign = p[i + 1];i++;break;
                case 'tbl':
                    co.textBaseline = p[i + 1];i++;break;
                case 'ga':
                    co.globalAlpha = parseFloat(p[i + 1]);i++;break;
                case 'gco':
                    co.globalCompositeOperation = p[i + 1];i++;break;
                case 'fu':
                    p[i + 1](co.canvas.__object__);i++;break;

                // Empty option - ignore it
                case '':
                    break;

                // Unknown option
                default:
                    alert('[ERROR] Unknown option: ' + p[i]);
            }
        }

        function splitstring(p) {
            var ret = [],
                buffer = '',
                inquote = false,
                quote = '',
                substitutionIndex = 2;

            for (var i = 0; i < p.length; i += 1) {

                var chr = p[i],
                    isWS = chr.match(/ /);

                if (isWS) {
                    if (!inquote) {

                        // Get rid of any enclosing quotes
                        if (buffer[0] === '"' || buffer[0] === "'") {
                            buffer = buffer.substr(1, buffer.length - 2);
                        }

                        // String substitution
                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {
                            buffer = args[substitutionIndex++];
                        }

                        ret.push(buffer);
                        buffer = '';
                    } else {
                        buffer += chr;
                    }
                } else {
                    if (chr === "'" || chr === '"') {
                        inquote = !inquote;
                    }

                    buffer += chr;
                }
            }

            // Do the last bit (including substitution)
            if (buffer.trim() === '%' && args[substitutionIndex]) {
                buffer = args[substitutionIndex++];
            }

            ret.push(buffer);

            return ret;
        }
    };

    //
    // Wraps the canvas in a DIV to allow DOM text to be used
    //
    // NOT USED ANY MORE
    //
    RG.wrap = function () {};

    // End module pattern
})(window, document);

/**
 * Uses the alert() function to show the structure of the given variable
 *
 * @param mixed v The variable to print/alert the structure of
 */
window.$p = function (v) {
    RGraph.pr(arguments[0], arguments[1], arguments[3]);
};

/**
 * A shorthand for the default alert() function
 */
window.$a = function (v) {
    alert(v);
};

/**
 * Short-hand for console.log
 *
 * @param mixed v The variable to log to the console
 */
window.$cl = function (v) {
    return console.log(v);
};

/**
 * A basic string formatting function. Use it like this:
 *
 * var str = '{0} {1} {2}'.format('a', 'b', 'c');
 *
 * Outputs: a b c
 */
if (!String.prototype.format) {
    String.prototype.format = function () {
        var args = arguments;

        return this.replace(/{(\d+)}/g, function (str, idx) {
            return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;
        });
    };
}

// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

/**
 * Initialise the various objects
 */
RGraph = window.RGraph || { isRGraph: true };

// Module pattern
(function (win, doc, undefined) {
    var RG = RGraph,
        ua = navigator.userAgent,
        ma = Math;

    /**
     * This is the window click event listener. It redraws all canvas tags on the page.
     */
    RG.installWindowMousedownListener = RG.InstallWindowMousedownListener = function (obj) {
        if (!RG.window_mousedown_event_listener) {

            RG.window_mousedown_event_listener = function (e) {
                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;

                e = RG.fixEventObject(e);

                if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {
                    RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);
                    RG.redraw();
                    RG.hideTooltip();
                }
            };
            win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);
        }
    };

    /**
     * This is the window click event listener. It redraws all canvas tags on the page.
     */
    RG.installWindowMouseupListener = RG.InstallWindowMouseupListener = function (obj) {
        if (!RG.window_mouseup_event_listener) {
            RG.window_mouseup_event_listener = function (e) {
                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;

                e = RG.fixEventObject(e);

                /**
                 * Stop any annotating that may be going on
                 */
                if (RG.annotating_window_onmouseup) {
                    RG.annotating_window_onmouseup(e);
                    return;
                }

                /**
                 * End adjusting
                 */
                if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {

                    var obj = RG.Registry.Get('chart.adjusting');

                    // If it's a line chart update the data_arr variable
                    if (obj && obj.type === 'line') {
                        obj.data_arr = RG.arrayLinearize(obj.data);
                    }

                    RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');
                }

                RG.Registry.set('chart.adjusting', null);
                RG.Registry.set('chart.adjusting.shape', null);
                RG.Registry.set('chart.adjusting.gantt', null);

                // ==============================================
                // Finally, redraw the chart
                // ==============================================

                var tags = document.getElementsByTagName('canvas');
                for (var i = 0; i < tags.length; ++i) {
                    if (tags[i].__object__ && tags[i].__object__.isRGraph) {
                        if (!tags[i].__object__.get('chart.annotatable')) {
                            if (!tags[i].__rgraph_trace_cover__ && !noredraw) {
                                RG.clear(tags[i]);
                            } else {
                                var noredraw = true;
                            }
                        }
                    }
                }

                if (!noredraw) {
                    RG.redraw();
                }
            };
            win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);
        }
    };

    /**
     * This is the canvas mouseup event listener. It installs the mouseup event for the
     * canvas. The mouseup event then checks the relevant object.
     *
     * @param object obj The chart object
     *
     * RGraph.window_mouseup_event_listener
     */
    RG.installCanvasMouseupListener = RG.InstallCanvasMouseupListener = function (obj) {
        if (!obj.canvas.rgraph_mouseup_event_listener) {
            obj.canvas.rgraph_mouseup_event_listener = function (e) {
                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                e = RG.fixEventObject(e);

                // *************************************************************************
                // Tooltips
                // *************************************************************************


                // This causes things at the edge of the chart area - eg line chart hotspots - not to fire because the
                // cursor is out of the chart area
                var objects = RG.ObjectRegistry.getObjectsByXY(e);
                //var objects = RG.ObjectRegistry.getObjectsByCanvasID(e.target.id);

                if (objects) {
                    for (var i = 0, len = objects.length; i < len; i += 1) {

                        var obj = objects[i],
                            id = objects[i].id;

                        // =========================================================================
                        // The drawing API text object supports chart.link
                        // ========================================================================
                        var link = obj.Get('link');

                        if (obj.type == 'drawing.text' && typeof link === 'string') {

                            var link_target = obj.get('link.target');
                            var link_options = obj.get('link.options');

                            window.open(link, link_target ? link_target : null, link_options);
                        }

                        // ========================================================================
                        // Tooltips
                        // ========================================================================


                        if (!RG.isNull(obj) && RG.tooltip) {

                            var shape = obj.getShape(e);

                            if (shape && shape['tooltip']) {

                                var text = shape['tooltip'];

                                if (text) {

                                    var type = shape['object'].type;

                                    RG.clear(obj.canvas);
                                    RG.redraw();
                                    RG.Registry.set('chart.tooltip.shape', shape);

                                    // Note that tooltips are positioned at the pointer
                                    // now; and thats done within the .tooltip() function
                                    RG.tooltip(obj, text, 0, 0, shape['index'], e);

                                    obj.highlight(shape);

                                    // Add the shape that triggered the tooltip
                                    if (RG.Registry.get('chart.tooltip')) {

                                        RG.Registry.get('chart.tooltip').__shape__ = shape;

                                        RG.evaluateCursor(e);
                                    }

                                    e.cancelBubble = true;
                                    e.stopPropagation();
                                    return false;
                                }
                            }
                        }

                        // =========================================================================
                        // Adjusting
                        // ========================================================================


                        if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {

                            //var obj = RG.Registry.get('chart.adjusting');

                            // If it's a line chart update the data_arr variable
                            if (obj && obj.type === 'line') {
                                obj.data_arr = RG.arrayLinearize(obj.data);
                            }

                            RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');
                        }

                        RG.Registry.set('chart.adjusting', null);
                        RG.Registry.set('chart.adjusting.shape', null);
                        RG.Registry.set('chart.adjusting.gantt', null);

                        /**
                         * If the mouse pointer is over a "front" chart this prevents charts behind it
                         * from firing their events.
                         */
                        if (shape || obj.overChartArea && obj.overChartArea(e)) {
                            break;
                        }
                    }
                }
            };
            obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);
        }
    };

    /**
     * This is the canvas mousemove event listener.
     *
     * @param object obj The chart object
     */
    RG.installCanvasMousemoveListener = RG.InstallCanvasMousemoveListener = function (obj) {
        if (!obj.canvas.rgraph_mousemove_event_listener) {
            obj.canvas.rgraph_mousemove_event_listener = function (e) {

                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;
                e = RG.fixEventObject(e);

                /**
                 * Go through all the objects and check them to see if anything needs doing
                 */
                var objects = RG.OR.getObjectsByXY(e);

                // Necessary to track which objects have had the mouseover
                // triggered on them
                var uids = [];

                if (objects && objects.length > 0) {

                    for (var i = 0, len = objects.length; i < len; i += 1) {

                        var obj = objects[i];
                        var id = obj.id;

                        // Record the uid
                        uids[obj.uid] = true;

                        if (!obj.getShape) {
                            continue;
                        }

                        var shape = obj.getShape(e);

                        // Fire the onmouseout event if necessary
                        if (!shape && typeof obj.__mouseover_shape_index__ === 'number' || shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__) {

                            RG.fireCustomEvent(obj, 'onmouseout');
                        }

                        //
                        // If the mouse is over a key element add the details
                        // of it to the Registry
                        //
                        if (obj.coords && obj.coords.key && obj.coords.key.length) {

                            var mouseXY = RG.getMouseXY(e);

                            for (var i = 0, overkey = false; i < obj.coords.key.length; ++i) {

                                if (mouseXY[0] >= obj.coords.key[i][0] && mouseXY[0] <= obj.coords.key[i][0] + obj.coords.key[i][2] && mouseXY[1] >= obj.coords.key[i][1] && mouseXY[1] <= obj.coords.key[i][1] + obj.coords.key[i][3]) {

                                    RG.Registry.set('key-element', obj.coords.key[i]);
                                    overkey = true;
                                }

                                if (!overkey) {
                                    RG.Registry.set('key-element', null);
                                }
                            }
                        }

                        // ================================================================================================ //
                        // This facilitates the chart.events.mousemove option
                        // ================================================================================================ //

                        var func = obj.get('chart.events.mousemove');

                        if (!func && typeof obj.onmousemove == 'function') {
                            var func = obj.onmousemove;
                        }

                        /**
                         *
                         */
                        if (shape) {
                            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];
                            if (typeof obj['$' + index] == 'object' && typeof obj['$' + index].onmousemove == 'function') {
                                var func2 = obj['$' + index].onmousemove;
                            }
                        }

                        /**
                         * This bit saves the current pointer style if there isn't one already saved
                         */
                        if (shape && (typeof func == 'function' || typeof func2 == 'function' || typeof obj.Get('link') === 'string')) {

                            if (obj.Get('chart.events.mousemove.revertto') == null) {
                                obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);
                            }

                            if (typeof func == 'function') RGraph.custom_events_mousemove_pointer = func(e, shape);
                            if (typeof func2 == 'function') RGraph.custom_events_mousemove_pointer = RGraph.custom_events_mousemove_pointer || func2(e, shape);

                            // Go through the RGraph.events array looking for more
                            // event listeners
                            if (typeof RG.events === 'object' && typeof RG.events[obj.uid] === 'object') {

                                for (i in RG.events[obj.uid]) {

                                    if (typeof i === 'string' && typeof RG.events[obj.uid][i] === 'object' && RG.events[obj.uid][i][1] === 'onmousemove' && typeof RG.events[obj.uid][i][2] === 'function') {

                                        RG.events[obj.uid][i][2](obj);
                                    }
                                }
                            }
                            //return;
                        } else if (typeof obj.Get('chart.events.mousemove.revertto') == 'string') {

                            RG.cursor.push('default');
                            obj.Set('chart.events.mousemove.revertto', null);
                        }

                        // ======================================================
                        // This bit of code facilitates the onmouseover event
                        // ======================================================


                        var func = obj.properties['chart.events.mouseover'];

                        if (!func && typeof obj.onmouseover === 'function') {
                            func = obj.onmouseover;
                        }

                        // Allow for individually index functions to be specified
                        if (shape) {

                            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];

                            if (typeof obj['$' + index] == 'object' && typeof obj['$' + index].onmouseover == 'function') {
                                var func2 = obj['$' + index].onmouseover;
                            }
                        } else {

                            obj.__mouseover_shape_index__ = null;
                            RG.__mouseover_objects__ = [];
                        }

                        if (typeof RG.__mouseover_objects__ === 'undefined') {
                            RG.__mouseover_objects__ = [];
                        }

                        if (shape) {
                            if (obj.__mouseover_shape_index__ === shape.index === false) {

                                obj.__mouseover_shape_index__ = shape.index;
                                RG.__mouseover_objects__.push(obj);

                                if (func) func(e, shape);
                                if (func2) func2(e, shape);

                                // Go through the RGraph.events array looking for more
                                // event listeners
                                if (typeof RG.events === 'object' && typeof RG.events[obj.uid] === 'object') {

                                    for (i in RG.events[obj.uid]) {

                                        if (typeof i === 'string' && typeof RG.events[obj.uid][i] === 'object' && RG.events[obj.uid][i][1] === 'onmouseover' && typeof RG.events[obj.uid][i][2] === 'function') {

                                            RG.events[obj.uid][i][2](obj);
                                        }
                                    }
                                }
                            }
                        } else {
                            obj.__mouseover_shape_index__ = null;
                            RG.__mouseover_objects__ = [];
                        }

                        // ================================================================================================ //
                        // Tooltips
                        // ================================================================================================ //
                        var current_tooltip = RG.Registry.get('chart.tooltip');
                        var tooltips = obj.get('chart.tooltips');
                        var tooltips_event = obj.Get('chart.tooltips.event');

                        if (shape && (tooltips && tooltips[shape['index']] || shape['tooltip']) && tooltips_event.indexOf('mousemove') !== -1 && (RG.isNull(current_tooltip) // Is there a tooltip being shown?
                        || obj.uid != current_tooltip.__object__.uid // Same object?
                        || current_tooltip.__index__ != shape['index'] // Same tooltip index?
                        || typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])) {

                            RG.clear(obj.canvas);
                            RG.hideTooltip();
                            RG.redraw();
                            obj.canvas.rgraph_mouseup_event_listener(e);

                            return;
                        }

                        // ================================================================================================ //
                        // Adjusting
                        // ================================================================================================ //


                        if (obj && obj.get('chart.adjustable')) {
                            obj.Adjusting_mousemove(e);
                        }

                        /**
                         * This facilitates breaking out of the loop when a shape has been found -
                         * ie the cursor is over a shape an upper chart
                         */
                        if (shape || obj.overChartArea && obj.overChartArea(e)) {
                            break;
                        }
                    }

                    //
                    // For all objects that are NOT mouseover'ed, reset the
                    // mouseover flag back to null
                    //
                    var objects = RG.OR.getObjectsByCanvasID(e.target.id);

                    for (var i = 0; i < objects.length; ++i) {
                        if (!uids[objects[i].uid]) {
                            objects[i].__mouseover_shape_index__ = null;
                        }
                    }
                } else {

                    // Reset the mouseover flag on all of this canvas tags objects
                    var objects = RG.OR.getObjectsByCanvasID(e.target.id);

                    for (var i = 0; i < objects.length; i++) {

                        if (typeof objects[i].__mouseover_shape_index__ === 'number') {
                            RG.fireCustomEvent(objects[i], 'onmouseout');
                        }

                        objects[i].__mouseover_shape_index__ = null;
                    }

                    RG.__mouseover_objects__ = [];
                }

                // ================================================================================================ //
                // Crosshairs
                // ================================================================================================ //


                if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {
                    RG.drawCrosshairs(e, e.target.__object__);
                }

                // ================================================================================================ //
                // Interactive key No LONGER REQUIRED
                // ================================================================================================ //


                //if (typeof InteractiveKey_line_mousemove == 'function') InteractiveKey_line_mousemove(e);
                //if (typeof InteractiveKey_pie_mousemove == 'function') InteractiveKey_pie_mousemove(e);


                // ================================================================================================ //
                // Annotating
                // ================================================================================================ //


                if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {
                    RG.annotating_canvas_onmousemove(e);
                }

                /**
                 * Determine the pointer
                 */
                RG.evaluateCursor(e);
            };
            obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);
        }
    };

    /**
     * This is the canvas mousedown event listener.
     *
     * @param object obj The chart object
     */
    RG.installCanvasMousedownListener = RG.InstallCanvasMousedownListener = function (obj) {
        if (!obj.canvas.rgraph_mousedown_event_listener) {
            obj.canvas.rgraph_mousedown_event_listener = function (e) {
                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                e = RG.fixEventObject(e);

                /**
                 * Annotating
                 */
                if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {
                    RG.annotating_canvas_onmousedown(e);
                    return;
                }

                var obj = RG.ObjectRegistry.getObjectByXY(e);

                if (obj) {

                    var id = obj.id;

                    /*************************************************************
                     * Handle adjusting for all object types
                     *************************************************************/
                    if (obj && obj.isRGraph && obj.get('chart.adjustable')) {

                        /**
                         * Check the cursor is in the correct area
                         */
                        var obj = RG.OR.getObjectByXY(e);

                        if (obj && obj.isRGraph) {

                            // If applicable, get the appropriate shape and store it in the registry
                            switch (obj.type) {
                                case 'bar':
                                    var shape = obj.getShapeByX(e);break;
                                case 'gantt':

                                    var shape = obj.getShape(e);
                                    var data = typeof shape.subindex === 'number' ? obj.data[shape.index][shape.subindex] : obj.data[shape.index];

                                    if (shape) {

                                        var mouseXY = RG.getMouseXY(e);

                                        RG.Registry.set('chart.adjusting.gantt', {
                                            index: shape.index,
                                            subindex: shape.subindex,
                                            object: obj,
                                            mousex: mouseXY[0],
                                            mousey: mouseXY[1],
                                            event: data,
                                            event_start: data[0],
                                            event_duration: data[1],
                                            mode: mouseXY[0] > shape['x'] + shape['width'] - 5 ? 'resize' : 'move',
                                            shape: shape
                                        });
                                    }
                                    break;
                                case 'line':
                                    var shape = obj.getShape(e);break;
                                case 'hbar':
                                    var shape = obj.getShapeByY(e);break;
                                default:
                                    var shape = null;
                            }

                            //
                            // Added 30/9/2016
                            // Now check the index in the chart.adjusting.limitto property
                            // If that property is an object and the appropriate index is
                            // truthy then allow adjusting, otherwise don't.
                            //
                            if (RG.isNull(obj.properties['chart.adjustable.only']) || typeof obj.properties['chart.adjustable.only'] === 'undefined' || RG.isArray(obj.properties['chart.adjustable.only']) && obj.isAdjustable && obj.isAdjustable(shape)) {

                                RG.Registry.set('chart.adjusting.shape', shape);

                                // Fire the onadjustbegin event
                                RG.fireCustomEvent(obj, 'onadjustbegin');

                                RG.Registry.set('chart.adjusting', obj);

                                // Liberally redraw the canvas
                                RG.clear(obj.canvas);
                                RG.redraw();

                                // Call the mousemove event listener so that the canvas
                                // is adjusted even though the mouse isn't moved
                                obj.canvas.rgraph_mousemove_event_listener(e);
                            }
                        }
                    }

                    RG.clear(obj.canvas);
                    RG.redraw();
                }
            };
            obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);
        }
    };

    /**
     * This is the canvas click event listener. Used by the pseudo event listener
     *
     * @param object obj The chart object
     */
    RG.installCanvasClickListener = RG.InstallCanvasClickListener = function (obj) {
        if (!obj.canvas.rgraph_click_event_listener) {
            obj.canvas.rgraph_click_event_listener = function (e) {
                /**
                 * For firefox add the window.event object
                 */
                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                e = RG.fixEventObject(e);

                var objects = RG.ObjectRegistry.getObjectsByXY(e);

                for (var i = 0, len = objects.length; i < len; i += 1) {

                    var obj = objects[i];
                    var id = obj.id;
                    var shape = obj.getShape(e);

                    /**
                     * This bit saves the current pointer style if there isn't one already saved
                     */
                    var func = obj.get('chart.events.click');

                    if (!func && typeof obj.onclick == 'function') {
                        func = obj.onclick;
                    }

                    if (shape && typeof func == 'function') {

                        func(e, shape);

                        // Go through the RGraph.events array looking for more
                        // event listeners

                        if (typeof RG.events === 'object' && typeof RG.events[obj.uid] === 'object') {

                            for (i in RG.events[obj.uid]) {

                                if (typeof i === 'string' && typeof RG.events[obj.uid][i] === 'object' && RG.events[obj.uid][i][1] === 'onclick' && typeof RG.events[obj.uid][i][2] === 'function') {

                                    RG.events[obj.uid][i][2](obj);
                                }
                            }
                        }

                        /**
                         * If objects are layered on top of each other this return
                         * stops objects underneath from firing once the "top"
                         * objects user event has fired
                         */
                        return;
                    }

                    //
                    // Handle the key click event
                    //
                    var key = RG.Registry.get('key-element');
                    if (key) {
                        RG.fireCustomEvent(obj, 'onkeyclick');
                    }

                    /**
                     * The property takes priority over this.
                     */
                    if (shape) {

                        var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];

                        if (typeof index == 'number' && obj['$' + index]) {

                            var func = obj['$' + index].onclick;

                            if (typeof func == 'function') {

                                func(e, shape);

                                /**
                                 * If objects are layered on top of each other this return
                                 * stops objects underneath from firing once the "top"
                                 * objects user event has fired
                                 */
                                return;
                            }
                        }
                    }

                    /**
                     * This facilitates breaking out of the loop when a shape has been found -
                     * ie the cursor is over a shape an upper chart
                     */
                    if (shape || obj.overChartArea && obj.overChartArea(e)) {
                        break;
                    }
                }
            };
            obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);
        }
    };

    /**
     * This function evaluates the various cursor settings and if there's one for pointer, changes it to that
     */
    RG.evaluateCursor = RG.EvaluateCursor = function (e) {
        var obj = null;
        var mouseXY = RG.getMouseXY(e);
        var mouseX = mouseXY[0];
        var mouseY = mouseXY[1];
        var canvas = e.target;

        /**
         * Tooltips cause the mouse pointer to change
         */
        var objects = RG.OR.getObjectsByCanvasID(canvas.id);

        for (var i = 0, len = objects.length; i < len; i += 1) {
            if (objects[i].getShape && objects[i].getShape(e) || objects[i].overChartArea && objects[i].overChartArea(e)) {
                var obj = objects[i];
                var id = obj.id;
            }
        }

        if (!RG.isNull(obj)) {
            if (obj.getShape && obj.getShape(e)) {

                var shape = obj.getShape(e);

                if (obj.get('chart.tooltips')) {

                    var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);

                    if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {
                        text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);
                    }

                    /**
                     * This essentially makes front charts "hide" the back charts
                     */
                    if (text) {
                        var pointer = true;
                    }
                }
            }

            /**
             * Now go through the key coords and see if it's over that.
             */
            if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {
                for (var j = 0; j < obj.coords.key.length; ++j) {
                    if (mouseX > obj.coords.key[j][0] && mouseX < obj.coords.key[j][0] + obj.coords.key[j][2] && mouseY > obj.coords.key[j][1] && mouseY < obj.coords.key[j][1] + obj.coords.key[j][3]) {
                        var pointer = true;
                    }
                }
            }
        }

        /**
         * It can be specified in the user mousemove event - remember it can now
         * be specified in THREE ways
         */
        if (RGraph.custom_events_mousemove_pointer) {
            var pointer = true;
            RGraph.custom_events_mousemove_pointer = false;
        }
        /*
           var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];
         if (!RG.isNull(obj['$' + index]) && typeof(obj['$' + index].onmousemove) == 'function') {
         var str = (obj['$' + index].onmousemove).toString();
         if (str.match(/pointer/) && str.match(/cursor/) && str.match(/style/)) {
         var pointer = true;
         }
         }
         }
         */

        /**
         * Is the chart resizable? Go through all the objects again
         */
        var objects = RG.OR.objects.byCanvasID;

        for (var i = 0, len = objects.length; i < len; i += 1) {
            if (objects[i] && objects[i][1].Get('chart.resizable')) {
                var resizable = true;
            }
        }

        if (resizable && mouseX > e.target.width - 32 && mouseY > e.target.height - 16) {
            pointer = true;
        }

        if (pointer) {
            e.target.style.cursor = 'pointer';
        } else if (e.target.style.cursor == 'pointer') {
            e.target.style.cursor = 'default';
        } else {
            e.target.style.cursor = null;
        }

        // =========================================================================
        // Resize cursor - check mouseis in bottom left corner and if it is change it
        // =========================================================================


        if (resizable && mouseX >= e.target.width - 15 && mouseY >= e.target.height - 15) {
            e.target.style.cursor = 'move';
        } else if (e.target.style.cursor === 'move') {
            e.target.style.cursor = 'default';
        }

        // =========================================================================
        // Interactive key
        // =========================================================================


        if (typeof mouse_over_key == 'boolean' && mouse_over_key) {
            e.target.style.cursor = 'pointer';
        }

        // =========================================================================
        // Gantt chart adjusting
        // =========================================================================

        //if (obj && obj.type == 'gantt' && obj.get('chart.adjustable')) {
        //    if (obj.getShape && obj.getShape(e)) {
        //        e.target.style.cursor = 'ew-resize';
        //    } else {
        //        e.target.style.cursor = 'default';
        //    }
        //} else if (!obj || !obj.type) {
        //    e.target.style.cursor = cursor;
        //}


        // =========================================================================
        // Line chart adjusting
        // =========================================================================


        if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {
            if (obj.getShape) {

                var shape = obj.getShape(e);

                if (shape && obj.isAdjustable(shape)) {
                    e.target.style.cursor = 'ns-resize';
                }
            } else {
                e.target.style.cursor = 'default';
            }
        }

        // =========================================================================
        // Annotatable
        // =========================================================================


        if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {
            e.target.style.cursor = 'crosshair';
        }

        // =========================================================================
        // Drawing API link
        // =========================================================================


        if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {
            e.target.style.cursor = 'pointer';
        }
    };

    /**
     * This function handles the tooltip text being a string, function
     *
     * @param mixed tooltip This could be a string or a function. If it's a function it's called and
     *                       the return value is used as the tooltip text
     * @param numbr idx The index of the tooltip.
     */
    RG.parseTooltipText = function (tooltips, idx) {
        // No tooltips
        if (!tooltips) {
            return null;
        }

        // Get the tooltip text
        if (typeof tooltips == 'function') {
            var text = tooltips(idx);

            // A single tooltip. Only supported by the Scatter chart
        } else if (typeof tooltips == 'string') {
            var text = tooltips;
        } else if (typeof tooltips == 'object' && typeof tooltips[idx] == 'function') {
            var text = tooltips[idx](idx);
        } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {
            var text = tooltips[idx];
        } else {
            var text = '';
        }

        if (text == 'undefined') {
            text = '';
        } else if (text == 'null') {
            text = '';
        }

        // Conditional in case the tooltip file isn't included
        return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;
    };

    /**
     * Draw crosshairs if enabled
     *
     * @param object obj The graph object (from which we can get the context and canvas as required)
     */
    RG.drawCrosshairs = RG.DrawCrosshairs = function (e, obj) {
        var e = RG.fixEventObject(e),
            width = obj.canvas.width,
            height = obj.canvas.height,
            mouseXY = RG.getMouseXY(e),
            x = mouseXY[0],
            y = mouseXY[1],
            gutterLeft = obj.gutterLeft,
            gutterRight = obj.gutterRight,
            gutterTop = obj.gutterTop,
            gutterBottom = obj.gutterBottom,
            Mathround = Math.round,
            prop = obj.properties,
            co = obj.context,
            ca = obj.canvas;

        RG.redrawCanvas(ca);

        if (x >= gutterLeft && y >= gutterTop && x <= width - gutterRight && y <= height - gutterBottom) {

            var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;
            co.lineWidth = linewidth ? linewidth : 1;

            co.beginPath();
            co.strokeStyle = prop['chart.crosshairs.color'];

            /**
             * The chart.crosshairs.snap option
             */
            if (prop['chart.crosshairs.snap']) {

                // Linear search for the closest point
                var point = null;
                var dist = null;
                var len = null;

                if (obj.type == 'line') {

                    for (var i = 0; i < obj.coords.length; ++i) {

                        var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);

                        // Check the mouse X coordinate
                        if (typeof dist != 'number' || length < dist) {
                            var point = i;
                            var dist = length;
                        }
                    }

                    x = obj.coords[point][0];
                    y = obj.coords[point][1];

                    // Get the dataset
                    for (var dataset = 0; dataset < obj.coords2.length; ++dataset) {
                        for (var point = 0; point < obj.coords2[dataset].length; ++point) {
                            if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {
                                ca.__crosshairs_snap_dataset__ = dataset;
                                ca.__crosshairs_snap_point__ = point;
                            }
                        }
                    }
                } else {

                    for (var i = 0; i < obj.coords.length; ++i) {
                        for (var j = 0; j < obj.coords[i].length; ++j) {

                            // Check the mouse X coordinate
                            var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);

                            if (typeof dist != 'number' || len < dist) {

                                var dataset = i;
                                var point = j;
                                var dist = len;
                            }
                        }
                    }
                    ca.__crosshairs_snap_dataset__ = dataset;
                    ca.__crosshairs_snap_point__ = point;

                    x = obj.coords[dataset][point][0];
                    y = obj.coords[dataset][point][1];
                }
            }

            // Draw a top vertical line
            if (prop['chart.crosshairs.vline']) {
                co.moveTo(Mathround(x), Mathround(gutterTop));
                co.lineTo(Mathround(x), Mathround(height - gutterBottom));
            }

            // Draw a horizontal line
            if (prop['chart.crosshairs.hline']) {
                co.moveTo(Mathround(gutterLeft), Mathround(y));
                co.lineTo(Mathround(width - gutterRight), Mathround(y));
            }

            co.stroke();

            /**
             * Need to show the coords?
             */
            if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {

                var xCoord = (x - gutterLeft) / (width - gutterLeft - gutterRight) * (prop['chart.xmax'] - prop['chart.xmin']) + prop['chart.xmin'];
                xCoord = xCoord.toFixed(prop['chart.scale.decimals']);
                var yCoord = obj.max - (y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom) * obj.max;

                if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {
                    yCoord = (yCoord - obj.max / 2) * 2;
                }

                yCoord = yCoord.toFixed(prop['chart.scale.decimals']);

                var div = RG.Registry.get('chart.coordinates.coords.div');
                var mouseXY = RG.getMouseXY(e);
                var canvasXY = RG.getCanvasXY(ca);

                if (!div) {
                    var div = document.createElement('DIV');
                    div.__object__ = obj;
                    div.style.position = 'absolute';
                    div.style.backgroundColor = 'white';
                    div.style.border = '1px solid black';
                    div.style.fontFamily = 'Arial, Verdana, sans-serif';
                    div.style.fontSize = '10pt';
                    div.style.padding = '2px';
                    div.style.opacity = 1;
                    div.style.WebkitBorderRadius = '3px';
                    div.style.borderRadius = '3px';
                    div.style.MozBorderRadius = '3px';
                    document.body.appendChild(div);

                    RG.Registry.set('chart.coordinates.coords.div', div);
                }

                // Convert the X/Y pixel coords to correspond to the scale
                div.style.opacity = 1;
                div.style.display = 'inline';

                if (!prop['chart.crosshairs.coords.fixed']) {
                    div.style.left = ma.max(2, e.pageX - div.offsetWidth - 3) + 'px';
                    div.style.top = ma.max(2, e.pageY - div.offsetHeight - 3) + 'px';
                } else {
                    div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';
                    div.style.top = canvasXY[1] + gutterTop + 3 + 'px';
                }

                div.innerHTML = '<span style="color: #666">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style="color: #666">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;

                obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);

                ca.__crosshairs_labels__ = div;
                ca.__crosshairs_x__ = xCoord;
                ca.__crosshairs_y__ = yCoord;
            } else if (prop['chart.crosshairs.coords']) {
                alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');
            }

            /**
             * Fire the oncrosshairs custom event
             */
            RG.fireCustomEvent(obj, 'oncrosshairs');
        } else {
            RG.hideCrosshairCoords();
        }
    };

    //
    // Adds a mousemove event listener that highlights a segment based on th
    // mousemove event. Used in the Rose and the RScatter charts
    //
    //@param int segments The number of segments to allow
    //
    RG.allowSegmentHighlight = function (opt) {
        var obj = opt.object,
            count = opt.count,
            fill = opt.fill,
            stroke = opt.stroke;

        if (!RG.segmentHighlightFunction) {

            RG.segmentHighlightFunction = function (e) {

                var mouseXY = RG.getMouseXY(e);
                var angle = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);

                angle += RG.HALFPI;

                if (angle > RG.TWOPI) {
                    angle -= RG.TWOPI;
                }

                RG.redraw();

                var start = 0;
                var end = 0;
                var a = ma.PI * 2 / count;

                //
                // Radius
                //
                var r = obj.radius;

                (function () {
                    for (i = 0; i < count; i += 1) {
                        if (angle < a * (i + 1)) {
                            start = i * a;
                            end = (i + 1) * a;

                            return;
                        }
                    }
                })();

                start -= RG.HALFPI;
                end -= RG.HALFPI;

                RG.path2(obj.context, 'b m % % a % % % % % false c s % f %', obj.centerx, obj.centery, obj.centerx, obj.centery, r, start, end, stroke, fill);
            };
            obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);
        }
    };

    // End module pattern
})(window, document);

// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

RGraph = window.RGraph || { isRGraph: true };

/**
 * The bar chart constructor
 *
 * @param object canvas The canvas object
 * @param array  data   The chart data
 */
RGraph.Bar = function (conf) {
    /**
     * Allow for object config style
     */
    if (typeof conf === 'object' && typeof conf.data === 'object' && typeof conf.id === 'string') {
        var id = conf.id,
            canvas = document.getElementById(id),
            data = conf.data,
            parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)
    } else {
        var id = conf,
            canvas = document.getElementById(id),
            data = arguments[1];
    }

    // Get the canvas and context objects
    this.id = id;
    this.canvas = canvas;
    this.context = this.canvas.getContext('2d');
    this.canvas.__object__ = this;
    this.type = 'bar';
    this.max = 0;
    this.stackedOrGrouped = false;
    this.isRGraph = true;
    this.uid = RGraph.CreateUID();
    this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
    this.colorsParsed = false;
    this.original_colors = [];
    this.cachedBackgroundCanvas = null;
    this.firstDraw = true; // After the first draw this will be false


    /**
     * Compatibility with older browsers
     */
    //RGraph.OldBrowserCompat(this.context);


    // Various config type stuff
    this.properties = {
        'chart.background.barcolor1': 'rgba(0,0,0,0)',
        'chart.background.barcolor2': 'rgba(0,0,0,0)',
        'chart.background.grid': true,
        'chart.background.grid.color': '#ddd',
        'chart.background.grid.width': 1,
        'chart.background.grid.hsize': 20,
        'chart.background.grid.vsize': 20,
        'chart.background.grid.vlines': true,
        'chart.background.grid.hlines': true,
        'chart.background.grid.border': true,
        'chart.background.grid.autofit': true,
        'chart.background.grid.autofit.align': true,
        'chart.background.grid.autofit.numhlines': 5,
        'chart.background.grid.autofit.numvlines': 20,
        'chart.background.grid.dashed': false,
        'chart.background.grid.dotted': false,
        'chart.background.image.stretch': true,
        'chart.background.image.x': null,
        'chart.background.image.y': null,
        'chart.background.image.w': null,
        'chart.background.image.h': null,
        'chart.background.image.align': null,
        'chart.background.color': null,
        'chart.background.hbars': null,
        'chart.numyticks': 10,
        'chart.hmargin': 5,
        'chart.hmargin.grouped': 1,
        'chart.strokecolor': 'rgba(0,0,0,0)',
        'chart.axis.color': 'black',
        'chart.axis.linewidth': 1,
        'chart.gutter.top': 25,
        'chart.gutter.bottom': 30,
        'chart.gutter.left': 25,
        'chart.gutter.right': 25,
        'chart.labels': null,
        'chart.labels.bold': false,
        'chart.labels.color': null,
        'chart.labels.ingraph': null,
        'chart.labels.above': false,
        'chart.labels.above.decimals': 0,
        'chart.labels.above.size': null,
        'chart.labels.above.color': null,
        'chart.labels.above.background': 'rgba(0,0,0,0)',
        'chart.labels.above.angle': null,
        'chart.labels.above.offset': 4,
        'chart.labels.above.units.pre': '',
        'chart.labels.above.units.post': '',
        'chart.ylabels': true,
        'chart.ylabels.count': 5,
        'chart.ylabels.inside': false,
        'chart.ylabels.offsetx': 0,
        'chart.ylabels.offsety': 0,
        'chart.labels.offsetx': 0,
        'chart.labels.offsety': 0,
        'chart.xaxispos': 'bottom',
        'chart.yaxispos': 'left',
        'chart.text.angle': 0,
        'chart.text.color': 'black', // Gradients aren't supported for this color
        'chart.text.size': 12,
        'chart.text.font': 'Segoe UI, Arial, Verdana, sans-serif',
        'chart.text.accessible': true,
        'chart.text.accessible.overflow': 'visible',
        'chart.text.accessible.pointerevents': true,
        'chart.ymin': 0,
        'chart.ymax': null,
        'chart.title': '',
        'chart.title.font': null,
        'chart.title.background': null, // Gradients aren't supported for this color
        'chart.title.hpos': null,
        'chart.title.vpos': null,
        'chart.title.bold': true,
        'chart.title.xaxis': '',
        'chart.title.xaxis.bold': true,
        'chart.title.xaxis.size': null,
        'chart.title.xaxis.font': null,
        'chart.title.xaxis.color': null,
        'chart.title.yaxis': '',
        'chart.title.yaxis.bold': true,
        'chart.title.yaxis.size': null,
        'chart.title.yaxis.font': null,
        'chart.title.yaxis.color': null, // Gradients aren't supported for this color
        'chart.title.xaxis.pos': null,
        'chart.title.yaxis.pos': null,
        'chart.title.yaxis.x': null,
        'chart.title.yaxis.y': null,
        'chart.title.xaxis.x': null,
        'chart.title.xaxis.y': null,
        'chart.title.x': null,
        'chart.title.y': null,
        'chart.title.halign': null,
        'chart.title.valign': null,
        'chart.colors': ['red', '#0f0', 'blue', 'pink', 'orange', 'cyan', 'black', 'white', 'green', 'magenta'],
        'chart.colors.sequential': false,
        'chart.colors.reverse': false,
        'chart.grouping': 'grouped',
        'chart.variant': 'bar',
        'chart.variant.sketch.verticals': true,
        'chart.variant.threed.xaxis': true,
        'chart.variant.threed.yaxis': true,
        'chart.variant.threed.angle': 0.1,
        'chart.variant.threed.offsetx': 10,
        'chart.variant.threed.offsety': 5,
        'chart.shadow': false,
        'chart.shadow.color': '#aaa', // Gradients aren't supported for this color
        'chart.shadow.offsetx': 0,
        'chart.shadow.offsety': 0,
        'chart.shadow.blur': 15,
        'chart.tooltips': null,
        'chart.tooltips.effect': 'fade',
        'chart.tooltips.css.class': 'RGraph_tooltip',
        'chart.tooltips.event': 'onclick',
        'chart.tooltips.highlight': true,
        'chart.tooltips.hotspot.xonly': false,
        'chart.highlight.stroke': 'rgba(0,0,0,0)',
        'chart.highlight.fill': 'rgba(255,255,255,0.7)',
        'chart.key': null,
        'chart.key.background': 'white',
        'chart.key.position': 'graph',
        'chart.key.shadow': false,
        'chart.key.shadow.color': '#666',
        'chart.key.shadow.blur': 3,
        'chart.key.shadow.offsetx': 2,
        'chart.key.shadow.offsety': 2,
        'chart.key.position.gutter.boxed': false,
        'chart.key.position.x': null,
        'chart.key.position.y': null,
        'chart.key.interactive': false,
        'chart.key.interactive.highlight.chart.stroke': 'black',
        'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)',
        'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',
        'chart.key.halign': 'right',
        'chart.key.color.shape': 'square',
        'chart.key.rounded': true,
        'chart.key.text.size': 10,
        'chart.key.linewidth': 1,
        'chart.key.colors': null,
        'chart.key.text.color': 'black',
        'chart.contextmenu': null,
        'chart.units.pre': '',
        'chart.units.post': '',
        'chart.scale.decimals': 0,
        'chart.scale.point': '.',
        'chart.scale.thousand': ',',
        'chart.scale.round': false,
        'chart.scale.zerostart': true,
        'chart.crosshairs': false,
        'chart.crosshairs.color': '#333',
        'chart.crosshairs.hline': true,
        'chart.crosshairs.vline': true,
        'chart.linewidth': 1,
        'chart.annotatable': false,
        'chart.annotate.color': 'black',
        'chart.zoom.factor': 1.5,
        'chart.zoom.fade.in': true,
        'chart.zoom.fade.out': true,
        'chart.zoom.hdir': 'right',
        'chart.zoom.vdir': 'down',
        'chart.zoom.frames': 25,
        'chart.zoom.delay': 16.666,
        'chart.zoom.shadow': true,
        'chart.zoom.background': true,
        'chart.resizable': false,
        'chart.resize.handle.background': null,
        'chart.adjustable': false,
        'chart.adjustable.only': null,
        'chart.noaxes': false,
        'chart.noxaxis': false,
        'chart.noyaxis': false,
        'chart.events.click': null,
        'chart.events.mousemove': null,
        'chart.numxticks': null,
        'chart.bevel': false,
        'chart.errorbars': false,
        'chart.errorbars.color': 'black',
        'chart.errorbars.capped': true,
        'chart.errorbars.capped.width': 14,
        'chart.errorbars.linewidth': 1,
        'chart.combinedchart.effect': null,
        'chart.combinedchart.effect.options': null,
        'chart.combinedchart.effect.callback': null,
        'chart.clearto': 'rgba(0,0,0,0)'
    };

    // Check for support
    if (!this.canvas) {
        alert('[BAR] No canvas support');
        return;
    }

    //
    // Convert strings into numbers. Also converts undefined elements to null
    //
    for (var i = 0; i < data.length; ++i) {
        if (typeof data[i] === 'string') {
            data[i] = parseFloat(data[i]);
        } else if (typeof data[i] === 'object' && data[i]) {
            for (var j = 0; j < data[i].length; ++j) {
                if (typeof data[i][j] === 'string') {
                    data[i][j] = parseFloat(data[i][j]);
                }
            }
        } else if (typeof data[i] === 'undefined') {
            data[i] = null;
        }
    }

    /**
     * Determine whether the chart will contain stacked or grouped bars
     */
    for (var i = 0; i < data.length; ++i) {
        if (typeof data[i] === 'object' && !RGraph.is_null(data[i])) {
            this.stackedOrGrouped = true;
        }
    }

    /**
     * Create the dollar objects so that functions can be added to them
     */
    var linear_data = RGraph.arrayLinearize(data);

    for (var i = 0; i < linear_data.length; ++i) {
        this['$' + i] = {};
    }

    // Store the data and set the orignal_data to it
    this.data = data;
    this.original_data = RGraph.arrayClone(data);

    // Used to store the coords of the bars
    this.coords = [];
    this.coords2 = [];
    this.coordsText = [];

    /**
     * This linearises the data. Doing so can make it easier to pull
     * out the appropriate data from tooltips
     */
    this.data_arr = RGraph.arrayLinearize(this.data);

    /**
     * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
     * done already
     */
    if (!this.canvas.__rgraph_aa_translated__) {
        this.context.translate(0.5, 0.5);

        this.canvas.__rgraph_aa_translated__ = true;
    }

    // Short variable names
    var RG = RGraph,
        ca = this.canvas,
        co = ca.getContext('2d'),
        prop = this.properties,
        pa2 = RG.path2,
        win = window,
        doc = document,
        ma = Math;

    /**
     * "Decorate" the object with the generic effects if the effects library has been included
     */
    if (RG.Effects && typeof RG.Effects.decorate === 'function') {
        RG.Effects.decorate(this);
    }

    /**
     * A setter
     *
     * @param name  string The name of the property to set
     * @param value mixed  The value of the property
     */
    this.set = this.Set = function (name) {
        var value = typeof arguments[1] === 'undefined' ? null : arguments[1];

        /**
         * the number of arguments is only one and it's an
         * object - parse it for configuration data and return.
         */
        if (arguments.length === 1 && typeof arguments[0] === 'object') {
            RG.parseObjectStyleConfig(this, arguments[0]);
            return this;
        }

        /**
         * This should be done first - prepend the propertyy name with "chart." if necessary
         */
        if (name.substr(0, 6) != 'chart.') {
            name = 'chart.' + name;
        }

        // Convert uppercase letters to dot+lower case letter
        while (name.match(/([A-Z])/)) {
            name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
        }

        // BC accommodation
        if (name === 'chart.xlabels.offset') {
            name = 'chart.labels.offsety';
        }

        if (name == 'chart.labels.abovebar') {
            name = 'chart.labels.above';
        }

        if (name == 'chart.strokestyle') {
            name = 'chart.strokecolor';
        }

        /**
         * Check for xaxispos
         */
        if (name == 'chart.xaxispos') {
            if (value != 'bottom' && value != 'center' && value != 'top') {
                alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');
                value = 'center';
            }

            if (value == 'top') {
                for (var i = 0; i < this.data.length; ++i) {
                    if (typeof this.data[i] == 'number' && this.data[i] > 0) {
                        alert('[BAR] The data element with index ' + i + ' should be negative');
                    }
                }
            }
        }

        /**
         * lineWidth doesn't appear to like a zero setting
         */
        if (name.toLowerCase() == 'chart.linewidth' && value == 0) {
            value = 0.0001;
        }

        prop[name] = value;

        return this;
    };

    /**
     * A getter
     *
     * @param name  string The name of the property to get
     */
    this.get = this.Get = function (name) {
        /**
         * This should be done first - prepend the property name with "chart." if necessary
         */
        if (name.substr(0, 6) != 'chart.') {
            name = 'chart.' + name;
        }

        // Convert uppercase letters to dot+lower case letter
        while (name.match(/([A-Z])/)) {
            name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
        }

        return prop[name];
    };

    /**
     * The function you call to draw the bar chart
     */
    this.draw = this.Draw = function () {
        // MUST be the first thing done!
        if (typeof prop['chart.background.image'] == 'string') {
            RG.DrawBackgroundImage(this);
        }

        /**
         * Fire the onbeforedraw event
         */
        RG.FireCustomEvent(this, 'onbeforedraw');

        //
        // If the chart is 3d then angle it it
        //
        if (prop['chart.variant'] === '3d') {
            if (prop['chart.text.accessible']) {
                // Nada
            } else {
                co.setTransform(1, prop['chart.variant.threed.angle'], 0, 1, 0.5, 0.5);
            }
        }

        /**
         * Parse the colors. This allows for simple gradient syntax
         */
        if (!this.colorsParsed) {
            this.parseColors();

            // Don't want to do this again
            this.colorsParsed = true;
        }

        /**
         * This is new in May 2011 and facilitates indiviual gutter settings,
         * eg chart.gutter.left
         */
        this.gutterLeft = prop['chart.gutter.left'];
        this.gutterRight = prop['chart.gutter.right'];
        this.gutterTop = prop['chart.gutter.top'];
        this.gutterBottom = prop['chart.gutter.bottom'];

        // Cache this in a class variable as it's used rather a lot

        /**
         * Check for tooltips and alert the user that they're not supported
         * with pyramid charts
         */
        if ((prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot') && typeof prop['chart.tooltips'] == 'object' && prop['chart.tooltips'] && prop['chart.tooltips'].length > 0) {

            alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');
        }

        /**
         * Stop the coords arrays from growing uncontrollably
         */
        this.coords = [];
        this.coords2 = [];
        this.coordsText = [];

        /**
         * Work out a few things. They need to be here because they depend on things you can change before you
         * call Draw() but after you instantiate the object
         */
        this.max = 0;
        this.grapharea = ca.height - this.gutterTop - this.gutterBottom;
        this.halfgrapharea = this.grapharea / 2;
        this.halfTextHeight = prop['chart.text.size'] / 2;

        // Now draw the background on to the main canvas
        RG.background.Draw(this);

        //If it's a sketch chart variant, draw the axes first
        //if (prop['chart.variant'] == 'sketch') {
        //    this.DrawAxes();
        //    this.Drawbars();
        //} else {
        this.drawbars();
        this.drawAxes();
        //}

        this.DrawLabels();

        /**
         * Draw the bevel if required
         */
        if (prop['chart.bevel'] || prop['chart.bevelled']) {
            this.DrawBevel();
        }

        // Draw the key if necessary
        if (prop['chart.key'] && prop['chart.key'].length) {
            RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
        }

        /**
         * Setup the context menu if required
         */
        if (prop['chart.contextmenu']) {
            RG.ShowContext(this);
        }

        /**
         * Draw errorbars
         */
        if (prop['chart.errorbars']) {
            this.drawErrorbars();
        }

        /**
         * Draw "in graph" labels
         */
        if (prop['chart.labels.ingraph']) {
            RG.DrawInGraphLabels(this);
        }

        /**
         * This function enables resizing
         */
        if (prop['chart.resizable']) {
            RG.AllowResizing(this);
        }

        /**
         * This installs the event listeners
         */
        RG.InstallEventListeners(this);

        /**
         * Fire the onfirstdraw event
         */
        if (this.firstDraw) {
            RG.fireCustomEvent(this, 'onfirstdraw');
            this.firstDraw = false;
            this.firstDrawFunc();
        }

        /**
         * Fire the RGraph ondraw event
         */
        RG.fireCustomEvent(this, 'ondraw');

        return this;
    };

    /**
     * Used in chaining. Runs a function there and then - not waiting for
     * the events to fire (eg the onbeforedraw event)
     *
     * @param function func The function to execute
     */
    this.exec = function (func) {
        func(this);

        return this;
    };

    /**
     * Draws the charts axes
     */
    this.drawAxes = this.DrawAxes = function () {
        if (prop['chart.noaxes']) {
            return;
        }

        var xaxispos = prop['chart.xaxispos'];
        var yaxispos = prop['chart.yaxispos'];
        var isSketch = prop['chart.variant'] == 'sketch';

        co.beginPath();
        co.strokeStyle = prop['chart.axis.color'];
        co.lineWidth = prop['chart.axis.linewidth'] + 0.001;

        if (RG.ISSAFARI == -1) {
            co.lineCap = 'square';
        }

        // Draw the Y axis
        if (prop['chart.noyaxis'] == false) {
            if (yaxispos == 'right') {
                co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
            } else {
                co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));
                co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
            }
        }

        // Draw the X axis
        if (prop['chart.noxaxis'] == false) {
            if (xaxispos == 'center') {
                co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + (isSketch ? 2 : 0)));
                co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round((ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - (isSketch ? 2 : 0)));
            } else if (xaxispos == 'top') {
                co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));
            } else {
                co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ma.round(this.getYCoord(0) - (isSketch ? 2 : 0)));
                co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ma.round(this.getYCoord(0) + (isSketch ? 2 : 0)));
            }
        }

        var numYTicks = prop['chart.numyticks'];

        //
        // DRAW THE Y TICKMARKS
        //
        if (prop['chart.noyaxis'] == false && !isSketch) {

            var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;
            var xpos = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;

            if (this.properties['chart.numyticks'] > 0) {
                for (y = this.gutterTop; xaxispos == 'center' ? y <= ca.height - this.gutterBottom : y < ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0); y += yTickGap) {

                    if (xaxispos == 'center' && y == this.gutterTop + this.grapharea / 2) {
                        continue;
                    }

                    // X axis at the top
                    if (xaxispos == 'top' && y == this.gutterTop) {
                        continue;
                    }

                    co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(y));
                    co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(y));
                }

                //
                // If the X axis is offset (ie not at the bottom when xaxispos
                // is set to bottom) - draw an extra tick
                //
                if (xaxispos === 'bottom' && prop['chart.ymin'] !== 0) {
                    co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(ca.height - prop['chart.gutter.bottom']));
                    co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(ca.height - prop['chart.gutter.bottom']));
                }
            }

            /**
             * If the X axis is not being shown, draw an extra tick
             */
            if (prop['chart.noxaxis']) {
                if (xaxispos == 'center') {
                    co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));
                    co.lineTo(xpos, Math.round(ca.height / 2));
                } else if (xaxispos == 'top') {
                    co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));
                    co.lineTo(xpos, Math.round(this.gutterTop));
                } else {
                    co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));
                    co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));
                }
            }
        }

        // Draw the X tickmarks
        if (prop['chart.noxaxis'] == false && !isSketch) {

            if (typeof prop['chart.numxticks'] == 'number') {
                var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];
            } else {
                var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;
            }

            if (xaxispos == 'bottom') {
                yStart = prop['chart.ymin'] < 0 ? this.getYCoord(0) - 3 : this.getYCoord(0);
                yEnd = this.getYCoord(0) + 3;
            } else if (xaxispos == 'top') {
                yStart = this.gutterTop - 3;
                yEnd = this.gutterTop;
            } else if (xaxispos == 'center') {
                yStart = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop + 3;
                yEnd = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - 3;
            }

            //yStart = yStart;
            //yEnd   = yEnd;

            //////////////// X TICKS ////////////////
            var noEndXTick = prop['chart.noendxtick'];

            for (x = this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0), len = ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0); x < len; x += xTickGap) {

                if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {
                    co.moveTo(ma.round(x), yStart);
                    co.lineTo(ma.round(x), yEnd);
                } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < ca.width - this.gutterRight) {
                    co.moveTo(ma.round(x), yStart);
                    co.lineTo(ma.round(x), yEnd);
                } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && !noEndXTick) {
                    co.moveTo(ma.round(x), yStart);
                    co.lineTo(ma.round(x), yEnd);
                } else if (yaxispos == 'right' && x < ca.width - this.gutterRight && x > this.gutterLeft && noEndXTick) {
                    co.moveTo(ma.round(x), yStart);
                    co.lineTo(ma.round(x), yEnd);
                }
            }

            if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {
                if (typeof prop['chart.numxticks'] == 'number' && prop['chart.numxticks'] > 0) {
                    co.moveTo(Math.round(this.gutterLeft), yStart);
                    co.lineTo(Math.round(this.gutterLeft), yEnd);
                }
            }

            //////////////// X TICKS ////////////////
        }

        /**
         * If the Y axis is not being shown, draw an extra tick
         */
        if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {
            if (xaxispos == 'center') {
                co.moveTo(ma.round(this.gutterLeft), ca.height / 2 - 3);
                co.lineTo(ma.round(this.gutterLeft), ca.height / 2 + 3);
            } else {
                co.moveTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);
                co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom + 3);
            }
        }

        co.stroke();
    };

    /**
     * Draws the bars
     */
    this.drawbars = this.Drawbars = function () {
        co.lineWidth = prop['chart.linewidth'];
        co.strokeStyle = prop['chart.strokecolor'];
        co.fillStyle = prop['chart.colors'][0];

        var prevX = 0,
            prevY = 0,
            decimals = prop['chart.scale.decimals'];

        /**
         * Work out the max value
         */
        if (prop['chart.ymax']) {

            this.scale2 = RG.getScale2(this, {
                'max': prop['chart.ymax'],
                'strict': prop['chart.scale.round'] ? false : true,
                'min': prop['chart.ymin'],
                'scale.thousand': prop['chart.scale.thousand'],
                'scale.point': prop['chart.scale.point'],
                'scale.decimals': prop['chart.scale.decimals'],
                'ylabels.count': prop['chart.ylabels.count'],
                'scale.round': prop['chart.scale.round'],
                'units.pre': prop['chart.units.pre'],
                'units.post': prop['chart.units.post']
            });
        } else {

            //
            // If errorbars are given as a number then convert the nuumber to an
            // array.
            //
            var errorbars = prop['chart.errorbars'];

            if (typeof errorbars === 'number') {

                var value = errorbars;

                prop['chart.errorbars'] = [];

                for (var i = 0; i < this.data.length; ++i) {
                    if (typeof this.data[i] === 'number') {
                        prop['chart.errorbars'].push([value, null]);
                    } else if (typeof this.data[i] === 'object' && !RG.isNull(this.data[i])) {
                        for (var j = 0; j < this.data[i].length; ++j) {
                            prop['chart.errorbars'].push([value, null]);
                        }
                    }
                }

                errorbars = prop['chart.errorbars'];
            }

            for (i = 0; i < this.data.length; ++i) {
                if (typeof this.data[i] == 'object') {
                    var value = prop['chart.grouping'] === 'grouped' ? Number(RG.arrayMax(this.data[i], true)) : Number(RG.array_sum(this.data[i]));
                } else {
                    var value = Number(this.data[i]);
                }

                this.max = ma.max(ma.abs(this.max), ma.abs(value) + Number(typeof prop['chart.errorbars'] === 'object' && typeof prop['chart.errorbars'][i] === 'object' && !RG.isNull(prop['chart.errorbars'][i]) && typeof prop['chart.errorbars'][i][0] === 'number' ? prop['chart.errorbars'][i][0] : 0));
            }

            this.scale2 = RGraph.getScale2(this, {
                'max': this.max,
                'min': prop['chart.ymin'],
                'scale.thousand': prop['chart.scale.thousand'],
                'scale.point': prop['chart.scale.point'],
                'scale.decimals': prop['chart.scale.decimals'],
                'ylabels.count': prop['chart.ylabels.count'],
                'scale.round': prop['chart.scale.round'],
                'units.pre': prop['chart.units.pre'],
                'units.post': prop['chart.units.post']
            });

            this.max = this.scale2.max;
        }

        /**
         * if the chart is adjustable fix the scale so that it doesn't change.
         */
        if (prop['chart.adjustable'] && !prop['chart.ymax']) {
            this.Set('chart.ymax', this.scale2.max);
        }

        /**
         * Draw horizontal bars here
         */
        if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {
            RGraph.DrawBars(this);
        }

        var variant = prop['chart.variant'];

        /**
         * Draw the 3D axes is necessary
         */
        if (variant === '3d') {
            RG.draw3DAxes(this);
        }

        /**
         * Get the variant once, and draw the bars, be they regular, stacked or grouped
         */

        // Get these variables outside of the loop
        var xaxispos = prop['chart.xaxispos'],
            width = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length,
            orig_height = height,
            hmargin = prop['chart.hmargin'],
            shadow = prop['chart.shadow'],
            shadowColor = prop['chart.shadow.color'],
            shadowBlur = prop['chart.shadow.blur'],
            shadowOffsetX = prop['chart.shadow.offsetx'],
            shadowOffsetY = prop['chart.shadow.offsety'],
            strokeStyle = prop['chart.strokecolor'],
            colors = prop['chart.colors'],
            sequentialColorIndex = 0;

        var height;

        for (i = 0, len = this.data.length; i < len; i += 1) {

            // Work out the height
            //The width is up outside the loop
            if (RG.arraySum(this.data[i]) < 0) {
                var height = (RG.arraySum(this.data[i]) + this.scale2.min) / (this.scale2.max - this.scale2.min);
            } else {
                var height = (RG.arraySum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min);
            }

            height *= ma.abs(this.getYCoord(this.scale2.max) - this.getYCoord(this.scale2.min));

            var x = i * width + this.gutterLeft;
            var y = xaxispos == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop - height : ca.height - height - this.gutterBottom;

            // xaxispos is top
            if (xaxispos == 'top') {
                y = this.gutterTop + ma.abs(height);
            }

            // Account for negative lengths - Some browsers don't like a negative value
            if (height < 0) {
                y += height;
                height = ma.abs(height);
            }

            /**
             * Turn on the shadow if need be
             */
            if (shadow) {
                co.shadowColor = shadowColor;
                co.shadowBlur = shadowBlur;
                co.shadowOffsetX = shadowOffsetX;
                co.shadowOffsetY = shadowOffsetY;
            }

            /**
             * Draw the bar
             */
            co.beginPath();
            if (typeof this.data[i] == 'number') {

                // If the Y axis is offset change the bar start (the top of the bar)
                if (xaxispos === 'bottom' && prop['chart.ymin'] < 0) {
                    if (this.data[i] >= 0) {
                        height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));
                    } else {
                        y = this.getYCoord(0);
                        height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));
                    }
                }

                var barWidth = width - 2 * hmargin;

                /**
                 * Check for a negative bar width
                 */
                if (barWidth < 0) {
                    alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                }

                // Set the fill color
                co.strokeStyle = strokeStyle;
                co.fillStyle = colors[0];

                /**
                 * Sequential colors
                 */
                if (prop['chart.colors.sequential']) {
                    co.fillStyle = colors[i];
                }

                if (variant == 'sketch') {

                    co.lineCap = 'round';

                    var sketchOffset = 3;

                    co.beginPath();

                    co.strokeStyle = colors[0];

                    /**
                     * Sequential colors
                     */
                    if (prop['chart.colors.sequential']) {
                        co.strokeStyle = colors[i];
                    }

                    // Left side
                    co.moveTo(x + hmargin + 2, y + height - 2);
                    co.lineTo(x + hmargin - 1, y - 4);

                    // The top
                    co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));
                    co.bezierCurveTo(x + (hmargin + width) * 0.33, y + 15 + (this.data[i] < 0 ? height - 10 : 0), x + (hmargin + width) * 0.66, y + 5 + (this.data[i] < 0 ? height - 10 : 0), x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0));

                    // The right side
                    co.moveTo(x + hmargin + width - 5, y - 5);
                    co.lineTo(x + hmargin + width - 3, y + height - 3);

                    if (prop['chart.variant.sketch.verticals']) {
                        for (var r = 0.2; r <= 0.8; r += 0.2) {
                            co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - r * width, y - 1);
                            co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - r * width, y + height + (r == 0.2 ? 1 : -2));
                        }
                    }

                    co.stroke();

                    // Regular bar
                } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {

                    if (RGraph.ISOLD && shadow) {
                        this.DrawIEShadow([x + hmargin, y, barWidth, height]);
                    }

                    if (variant == 'glass') {
                        RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                        RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                    } else {
                        // On 9th April 2013 these two were swapped around so that the stroke happens SECOND so that any
                        // shadow that is cast by the fill does not overwrite the stroke

                        co.beginPath();
                        co.rect(x + hmargin, y, barWidth, height);
                        co.fill();

                        // Turn the shadow off so that the stroke doesn't cast any "extra" shadow
                        // that would show inside the bar
                        RG.NoShadow(this);

                        co.beginPath();
                        co.rect(x + hmargin, y, barWidth, height);
                        co.stroke();
                    }

                    // 3D effect
                    if (variant == '3d') {

                        var prevStrokeStyle = co.strokeStyle;
                        var prevFillStyle = co.fillStyle;

                        // Draw the top (if the value is positive - otherwise there's no point)
                        if (this.data[i] >= 0) {
                            co.beginPath();
                            co.moveTo(x + hmargin, y);
                            co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                            co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(x + hmargin + barWidth, y);
                            co.closePath();

                            co.stroke();
                            co.fill();
                        }

                        // Draw the right hand side
                        co.beginPath();
                        co.moveTo(x + hmargin + barWidth, y);
                        co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);

                        co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.gutterTop + this.getYCoord(0) ? this.getYCoord(this.data[i]) - prop['chart.variant.threed.offsety'] : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));
                        co.lineTo(x + hmargin + barWidth, y + height);
                        co.closePath();
                        co.stroke();
                        co.fill();

                        // Draw the lighter top section
                        if (this.data[i] > 0) {
                            co.beginPath();
                            co.fillStyle = 'rgba(255,255,255,0.5)';
                            co.moveTo(x + hmargin, y);
                            co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                            co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(x + hmargin + barWidth, y);
                            co.lineTo(x + hmargin, y);
                            co.closePath();
                            co.stroke();
                            co.fill();
                        }

                        // Draw the darker right side section
                        co.beginPath();
                        co.fillStyle = 'rgba(0,0,0,0.4)';
                        // TL
                        co.moveTo(x + hmargin + barWidth, y);

                        // TR
                        co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : y - prop['chart.variant.threed.offsety']);

                        // BR
                        co.lineTo(x + hmargin + barWidth + prop['chart.variant.threed.offsetx'], this.data[i] < 0 && y - prop['chart.variant.threed.offsety'] + height < this.getYCoord(0) ? this.getYCoord(0) : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom));
                        // BL
                        co.lineTo(x + hmargin + barWidth, y + height);
                        co.lineTo(x + hmargin + barWidth, y);
                        co.closePath();

                        co.stroke();
                        co.fill();

                        co.strokeStyle = prevStrokeStyle;
                        co.fillStyle = prevFillStyle;

                        // Glass variant
                    } else if (variant == 'glass') {

                        var grad = co.createLinearGradient(x + hmargin, y, x + hmargin + barWidth / 2, y);
                        grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                        grad.addColorStop(1, 'rgba(255,255,255,0.5)');

                        co.beginPath();
                        co.fillStyle = grad;
                        co.fillRect(x + hmargin + 2, y + (this.data[i] > 0 ? 2 : 0), barWidth / 2 - 2, height - 2);
                        co.fill();
                    }

                    // Dot chart
                } else if (variant == 'dot') {

                    co.beginPath();
                    co.moveTo(x + width / 2, y);
                    co.lineTo(x + width / 2, y + height);
                    co.stroke();

                    co.beginPath();
                    co.fillStyle = this.properties['chart.colors'][i];
                    co.arc(x + width / 2, y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);

                    // Set the colour for the dots
                    co.fillStyle = prop['chart.colors'][0];

                    /**
                     * Sequential colors
                     */
                    if (prop['chart.colors.sequential']) {
                        co.fillStyle = colors[i];
                    }

                    co.stroke();
                    co.fill();

                    // Unknown variant type
                } else {
                    alert('[BAR] Warning! Unknown chart.variant: ' + variant);
                }

                this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);

                if (typeof this.coords2[i] == 'undefined') {
                    this.coords2[i] = [];
                }
                this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);

                /**
                 * Stacked bar
                 */
            } else if (this.data[i] && typeof this.data[i] == 'object' && prop['chart.grouping'] == 'stacked') {

                if (this.scale2.min) {
                    alert("[ERROR] Stacked Bar charts with a Y min are not supported");
                }

                var barWidth = width - 2 * hmargin;
                var redrawCoords = []; // Necessary to draw if the shadow is enabled
                var startY = 0;
                var dataset = this.data[i];

                /**
                 * Check for a negative bar width
                 */
                if (barWidth < 0) {
                    alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                }

                for (j = 0; j < dataset.length; ++j) {

                    // Stacked bar chart and X axis pos in the middle - poitless since negative values are not permitted
                    if (xaxispos == 'center') {
                        alert("[BAR] It's pointless having the X axis position at the center on a stacked bar chart.");
                        return;
                    }

                    // Negative values not permitted for the stacked chart
                    if (this.data[i][j] < 0) {
                        alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');
                        return;
                    }

                    /**
                     * Set the fill and stroke colors
                     */
                    co.strokeStyle = strokeStyle;
                    co.fillStyle = colors[j];

                    if (prop['chart.colors.reverse']) {
                        co.fillStyle = colors[this.data[i].length - j - 1];
                    }

                    if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                        co.fillStyle = colors[sequentialColorIndex++];
                    } else if (prop['chart.colors.sequential']) {
                        co.fillStyle = colors[sequentialColorIndex - 1];
                    }

                    var height = dataset[j] / this.scale2.max * (ca.height - this.gutterTop - this.gutterBottom);

                    // If the X axis pos is in the center, we need to half the  height
                    if (xaxispos == 'center') {
                        height /= 2;
                    }

                    var totalHeight = RGraph.array_sum(dataset) / this.scale2.max * (ca.height - hmargin - this.gutterTop - this.gutterBottom);

                    /**
                     * Store the coords for tooltips
                     */
                    this.coords.push([x + hmargin, y, width - 2 * hmargin, height]);
                    if (typeof this.coords2[i] == 'undefined') {
                        this.coords2[i] = [];
                    }
                    this.coords2[i].push([x + hmargin, y, width - 2 * hmargin, height]);

                    // MSIE shadow
                    if (RGraph.ISOLD && shadow) {
                        this.DrawIEShadow([x + hmargin, y, width - 2 * hmargin, height + 1]);
                    }

                    if (height > 0) {
                        co.strokeRect(x + hmargin, y, width - 2 * hmargin, height);
                        co.fillRect(x + hmargin, y, width - 2 * hmargin, height);
                    }

                    if (j == 0) {
                        var startY = y;
                        var startX = x;
                    }

                    /**
                     * Store the redraw coords if the shadow is enabled
                     */
                    if (shadow) {
                        redrawCoords.push([x + hmargin, y, width - 2 * hmargin, height, co.fillStyle]);
                    }

                    /**
                     * Stacked 3D effect
                     */
                    if (variant == '3d') {

                        var prevFillStyle = co.fillStyle;
                        var prevStrokeStyle = co.strokeStyle;

                        // Draw the top side
                        if (j == 0) {
                            co.beginPath();
                            co.moveTo(startX + hmargin, y);
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + barWidth + hmargin, y);
                            co.closePath();

                            co.fill();
                            co.stroke();
                        }

                        // Draw the side section
                        co.beginPath();
                        co.moveTo(startX + barWidth + hmargin, y);
                        co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                        co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);
                        co.lineTo(startX + barWidth + hmargin, y + height);
                        co.closePath();

                        co.fill();
                        co.stroke();

                        // Draw the lighter top side
                        if (j == 0) {
                            co.fillStyle = 'rgba(255,255,255,0.5)';
                            co.beginPath();
                            co.moveTo(startX + hmargin, y);
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + barWidth + hmargin, y);
                            co.closePath();

                            co.fill();
                            co.stroke();
                        }

                        // Draw the darker side section
                        co.fillStyle = 'rgba(0,0,0,0.4)';
                        co.beginPath();
                        co.moveTo(startX + barWidth + hmargin, y);
                        co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                        co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);
                        co.lineTo(startX + barWidth + hmargin, y + height);
                        co.closePath();

                        co.fill();
                        co.stroke();

                        co.strokeStyle = prevStrokeStyle;
                        co.fillStyle = prevFillStyle;
                    }

                    y += height;
                }

                /**
                 * Redraw the bars if the shadow is enabled due to hem being drawn from the bottom up, and the
                 * shadow spilling over to higher up bars
                 */
                if (shadow) {

                    RGraph.NoShadow(this);

                    for (k = 0; k < redrawCoords.length; ++k) {
                        co.strokeStyle = strokeStyle;
                        co.fillStyle = redrawCoords[k][4];
                        co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);
                        co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);

                        co.stroke();
                        co.fill();
                    }

                    // Reset the redraw coords to be empty
                    redrawCoords = [];
                }

                /**
                 * Grouped bar
                 */
            } else if (this.data[i] && typeof this.data[i] == 'object' && prop['chart.grouping'] == 'grouped') {

                var redrawCoords = [];
                co.lineWidth = prop['chart.linewidth'];

                for (j = 0; j < this.data[i].length; ++j) {

                    // Set the fill and stroke colors
                    co.strokeStyle = strokeStyle;
                    co.fillStyle = colors[j];

                    /**
                     * Sequential colors
                     */
                    if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                        co.fillStyle = colors[sequentialColorIndex++];
                    } else if (prop['chart.colors.sequential']) {
                        co.fillStyle = colors[sequentialColorIndex - 1];
                    }

                    var individualBarWidth = (width - 2 * hmargin) / this.data[i].length;
                    var height = (this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : -1 * this.scale2.min)) / (this.scale2.max - this.scale2.min) * (ca.height - this.gutterTop - this.gutterBottom);
                    var groupedMargin = prop['chart.hmargin.grouped'];
                    var startX = x + hmargin + j * individualBarWidth;

                    /**
                     * Check for a negative bar width
                     */
                    if (individualBarWidth < 0) {
                        alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                    }

                    // If the X axis pos is in the center, we need to half the  height
                    if (xaxispos == 'center') {
                        height /= 2;
                    }

                    /**
                     * Determine the start positioning for the bar
                     */
                    if (xaxispos == 'top') {
                        var startY = this.gutterTop;
                        var height = Math.abs(height);
                    } else if (xaxispos == 'center') {
                        var startY = this.gutterTop + this.grapharea / 2 - height;
                    } else {
                        var startY = this.getYCoord(0); //ca.height - this.gutterBottom - height;
                        var height = ma.abs(ma.abs(this.getYCoord(this.data[i][j])) - this.getYCoord(0));

                        if (this.data[i][j] >= 0) {
                            startY -= height;
                        }
                    }

                    co.strokeRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);
                    co.fillRect(startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height);
                    y += height;

                    /**
                     * Grouped 3D effect
                     */
                    if (variant == '3d') {

                        var prevFillStyle = co.fillStyle;
                        var prevStrokeStyle = co.strokeStyle;
                        var hmarginGrouped = prop['chart.hmargin.grouped'];

                        // Draw the top side
                        if (this.data[i][j] >= 0) {

                            co.beginPath();
                            co.moveTo(startX + hmarginGrouped, startY);
                            co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);
                            co.closePath();
                            co.fill();
                            co.stroke();
                        }

                        // Draw the side section
                        co.beginPath();
                        co.moveTo(startX + individualBarWidth - hmarginGrouped - 1, startY);
                        co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);

                        co.lineTo(startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'], this.data[i][j] < 0 && startY + height - prop['chart.variant.threed.offsety'] < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);
                        co.lineTo(startX + individualBarWidth - hmarginGrouped - 1, startY + height);
                        co.closePath();
                        co.fill();
                        co.stroke();

                        // Draw the lighter top side - but only if the current value is positive
                        if (this.data[i][j] >= 0) {
                            co.fillStyle = 'rgba(255,255,255,0.5)';
                            co.beginPath();
                            // BL
                            co.moveTo(startX + hmarginGrouped, startY);

                            // BR
                            co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);

                            // TR
                            co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);

                            // TL
                            co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);
                            co.closePath();

                            co.fill();
                            co.stroke();
                        }

                        // Draw the darker side section
                        co.fillStyle = 'rgba(0,0,0,0.4)';
                        co.beginPath();
                        // TL corner
                        co.moveTo(startX + individualBarWidth - hmarginGrouped, startY);

                        co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 ? this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety'] : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']);

                        // TR corner
                        co.lineTo(startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped, this.data[i][j] < 0 && startY + height - 5 < this.gutterTop + this.halfgrapharea ? this.gutterTop + this.halfgrapharea : startY + height - prop['chart.variant.threed.offsety']);

                        // TL corner
                        co.lineTo(startX + individualBarWidth - hmarginGrouped, startY + height);
                        co.closePath();

                        co.fill();
                        co.stroke();

                        co.strokeStyle = prevStrokeStyle;
                        co.fillStyle = prevFillStyle;
                    }

                    if (height < 0) {
                        height = Math.abs(height);
                        startY = startY - height;
                    }

                    this.coords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);
                    if (typeof this.coords2[i] == 'undefined') {
                        this.coords2[i] = [];
                    }

                    this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height]);

                    // Facilitate shadows going to the left
                    if (prop['chart.shadow']) {
                        redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - 2 * groupedMargin, height, co.fillStyle]);
                    }
                }

                /**
                 * Redraw the bar if shadows are going to the left
                 */
                if (redrawCoords.length) {

                    RGraph.NoShadow(this);

                    co.lineWidth = prop['chart.linewidth'];

                    co.beginPath();
                    for (var j = 0; j < redrawCoords.length; ++j) {

                        co.fillStyle = redrawCoords[j][4];
                        co.strokeStyle = prop['chart.strokecolor'];

                        co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                        co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                    }
                    co.fill();
                    co.stroke();

                    redrawCoords = [];
                }
            } else {
                this.coords.push([]);
            }

            co.closePath();
        }

        // If 3D, redraw the right hand Y axis
        if (prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right') {
            RG.draw3DYAxis(this);
        }

        /**
         * Turn off any shadow
         */
        RGraph.noShadow(this);
    };

    /**
     * Draws the labels for the graph
     */
    this.drawLabels = this.DrawLabels = function () {
        var context = co;

        var text_angle = prop['chart.text.angle'],
            text_size = prop['chart.text.size'],
            labels = prop['chart.labels'];

        // Draw the Y axis labels:
        if (prop['chart.ylabels']) {
            if (prop['chart.xaxispos'] == 'top') this.Drawlabels_top();
            if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();
            if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();
        }

        /**
         * The X axis labels
         */
        if (typeof labels == 'object' && labels) {

            var yOffset = Number(prop['chart.labels.offsety']),
                xOffset = Number(prop['chart.labels.offsetx']),
                bold = prop['chart.labels.bold'];

            /**
             * Text angle
             */
            if (prop['chart.text.angle'] != 0) {
                var valign = 'center';
                var halign = 'right';
                var angle = 0 - prop['chart.text.angle'];
            } else {
                var valign = 'top';
                var halign = 'center';
                var angle = 0;
            }

            // Draw the X axis labels
            co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];
            // How wide is each bar
            var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;

            // Reset the xTickGap
            xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;

            // Draw the X tickmarks
            var i = 0;
            var font = prop['chart.text.font'];
            for (x = this.gutterLeft + xTickGap / 2; x <= ca.width - this.gutterRight; x += xTickGap) {
                RG.text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': x + xOffset,
                    'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + yOffset - 5 : ca.height - this.gutterBottom + yOffset + 3,
                    'bold': bold,
                    'text': String(labels[i++]),
                    'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign,
                    'halign': halign,
                    'tag': 'label',
                    'marker': false,
                    'angle': angle,
                    'tag': 'labels'
                });
            }
        }
        /**
         * Draw above labels
         */
        this.drawAboveLabels();
    };

    /**
     * Draws the X axis at the top
     */
    this.drawlabels_top = this.Drawlabels_top = function () {
        var ca = this.canvas;
        var co = this.context;
        var prop = this.properties;

        co.beginPath();
        co.fillStyle = prop['chart.text.color'];
        co.strokeStyle = 'black';

        if (prop['chart.xaxispos'] == 'top') {

            var context = co;
            var text_size = prop['chart.text.size'];
            var units_pre = prop['chart.units.pre'];
            var units_post = prop['chart.units.post'];
            var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
            var font = prop['chart.text.font'];
            var numYLabels = prop['chart.ylabels.count'];
            var ymin = prop['chart.ymin'];
            var offsetx = prop['chart.ylabels.offsetx'];
            var offsety = prop['chart.ylabels.offsety'];

            if (prop['chart.ylabels.inside'] == true) {
                var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                var boxed = true;
            } else {
                var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                var boxed = false;
            }

            /**
             * Draw specific Y labels here so that the local variables can be reused
             */
            if (typeof prop['chart.ylabels.specific'] == 'object' && prop['chart.ylabels.specific']) {

                var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);
                var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                for (var i = 0; i < labels.length; ++i) {

                    var y = this.gutterTop + grapharea * (i / labels.length) + grapharea / labels.length;

                    RG.text2(this, {
                        'font': font,
                        'size': text_size,
                        'x': xpos + offsetx,
                        'y': y + offsety,
                        'text': String(labels[i]),
                        'valign': 'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag': 'scale'
                    });
                }

                return;
            }

            /**
             * Draw the scale
             */
            var labels = this.scale2.labels;
            for (var i = 0; i < labels.length; ++i) {
                RGraph.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': this.gutterTop + this.grapharea / labels.length * (i + 1) + offsety,
                    'text': '-' + labels[i],
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }

            /**
             * Show the minimum value if its not zero
             */
            if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {

                RGraph.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': this.gutterTop + offsety,
                    'text': (this.scale2.min != 0 ? '-' : '') + RGraph.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }
        }

        co.fill();
    };

    /**
     * Draws the X axis in the middle
     */
    this.drawlabels_center = this.Drawlabels_center = function () {
        var ca = this.canvas;
        var co = this.context;
        var prop = this.properties;

        var font = prop['chart.text.font'];
        var numYLabels = prop['chart.ylabels.count'];

        co.fillStyle = prop['chart.text.color'];

        if (prop['chart.xaxispos'] == 'center') {

            /**
             * Draw the top labels
             */
            var text_size = prop['chart.text.size'];
            var units_pre = prop['chart.units.pre'];
            var units_post = prop['chart.units.post'];
            var context = co;
            var align = '';
            var xpos = 0;
            var boxed = false;
            var ymin = prop['chart.ymin'];
            var offsetx = prop['chart.ylabels.offsetx'];
            var offsety = prop['chart.ylabels.offsety'];

            co.fillStyle = prop['chart.text.color'];
            co.strokeStyle = 'black';

            if (prop['chart.ylabels.inside'] == true) {
                var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                var boxed = true;
            } else {
                var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                var boxed = false;
            }

            /**
             * Draw specific Y labels here so that the local variables can be reused
             */
            if (typeof prop['chart.ylabels.specific'] == 'object' && prop['chart.ylabels.specific']) {

                var labels = prop['chart.ylabels.specific'];
                var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                // Draw the top halves labels
                for (var i = 0; i < labels.length; ++i) {

                    var y = this.gutterTop + grapharea / 2 / (labels.length - 1) * i;

                    RGraph.Text2(this, {
                        'font': font,
                        'size': text_size,
                        'x': xpos + offsetx,
                        'y': y + offsety,
                        'text': String(labels[i]),
                        'valign': 'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag': 'scale'
                    });
                }

                // Draw the bottom halves labels
                for (var i = labels.length - 1; i >= 1; --i) {

                    var y = this.gutterTop + grapharea * (i / ((labels.length - 1) * 2)) + grapharea / 2;

                    RG.Text2(this, {
                        'font': font,
                        'size': text_size,
                        'x': xpos + offsetx,
                        'y': y + offsety,
                        'text': String(labels[labels.length - i - 1]),
                        'valign': 'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag': 'scale'
                    });
                }

                return;
            }

            /**
             * Draw the top halfs labels
             */
            for (var i = 0; i < this.scale2.labels.length; ++i) {
                var y = this.gutterTop + this.halfgrapharea - this.halfgrapharea / numYLabels * (i + 1);
                var text = this.scale2.labels[i];
                RG.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': y + offsety,
                    'text': text,
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }

            /**
             * Draw the bottom halfs labels
             */
            for (var i = this.scale2.labels.length - 1; i >= 0; --i) {
                var y = this.gutterTop + this.halfgrapharea / numYLabels * (i + 1) + this.halfgrapharea;
                var text = this.scale2.labels[i];
                RG.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': y + offsety,
                    'text': '-' + text,
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }

            /**
             * Show the minimum value if its not zero
             */
            if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {
                RG.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': this.gutterTop + this.halfgrapharea + offsety,
                    'text': RG.number_format(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),
                    'valign': 'center',
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }
        }
    };

    /**
     * Draws the X axdis at the bottom (the default)
     */
    this.drawlabels_bottom = this.Drawlabels_bottom = function () {
        var text_size = prop['chart.text.size'],
            units_pre = prop['chart.units.pre'],
            units_post = prop['chart.units.post'],
            context = this.context,
            align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left',
            font = prop['chart.text.font'],
            numYLabels = prop['chart.ylabels.count'],
            ymin = prop['chart.ymin'],
            offsetx = prop['chart.ylabels.offsetx'],
            offsety = prop['chart.ylabels.offsety'];

        co.beginPath();

        co.fillStyle = prop['chart.text.color'];
        co.strokeStyle = 'black';

        if (prop['chart.ylabels.inside'] == true) {
            var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
            var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
            var boxed = true;
        } else {
            var xpos = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
            var boxed = false;
        }

        /**
         * Draw specific Y labels here so that the local variables can be reused
         */
        if (prop['chart.ylabels.specific'] && typeof prop['chart.ylabels.specific'] == 'object') {

            var labels = prop['chart.ylabels.specific'];
            var grapharea = ca.height - this.gutterTop - this.gutterBottom;

            for (var i = 0; i < labels.length; ++i) {
                var y = this.gutterTop + grapharea * (i / (labels.length - 1));

                RGraph.Text2(this, {
                    'font': font,
                    'size': text_size,
                    'x': xpos + offsetx,
                    'y': y + offsety,
                    'text': labels[i],
                    'valign': 'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag': 'scale'
                });
            }

            return;
        }

        var gutterTop = this.gutterTop;
        var halfTextHeight = this.halfTextHeight;
        var scale = this.scale;

        for (var i = 0; i < numYLabels; ++i) {
            var text = this.scale2.labels[i];
            RGraph.Text2(this, {
                'font': font,
                'size': text_size,
                'x': xpos + offsetx,
                'y': this.gutterTop + this.grapharea - this.grapharea / numYLabels * (i + 1) + offsety,
                'text': text,
                'valign': 'center',
                'halign': align,
                'bordered': boxed,
                'tag': 'scale'
            });
        }

        /**
         * Show the minimum value if its not zero
         */
        if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {
            RG.text2(this, {
                font: font,
                size: text_size,
                x: xpos + offsetx,
                y: ca.height - this.gutterBottom + offsety,
                text: RG.numberFormat(this, this.scale2.min.toFixed(this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),
                valign: 'center',
                halign: align,
                bordered: boxed,
                tag: 'scale'
            });
        }

        co.fill();
    };

    /**
     * This function is used by MSIE only to manually draw the shadow
     *
     * @param array coords The coords for the bar
     */
    this.drawIEShadow = this.DrawIEShadow = function (coords) {
        var co = this.context;
        var ca = this.canvas;
        var prop = this.properties;

        var prevFillStyle = co.fillStyle;
        var offsetx = prop['chart.shadow.offsetx'];
        var offsety = prop['chart.shadow.offsety'];

        co.lineWidth = prop['chart.linewidth'];
        co.fillStyle = prop['chart.shadow.color'];
        co.beginPath();

        // Draw shadow here
        co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);

        co.fill();

        // Change the fillstyle back to what it was
        co.fillStyle = prevFillStyle;
    };

    /**
     * Not used by the class during creating the graph, but is used by event handlers
     * to get the coordinates (if any) of the selected bar
     *
     * @param object e The event object
     * @param object   OPTIONAL You can pass in the bar object instead of the
     *                          function using "this"
     */
    this.getShape = this.getBar = function (e) {
        // This facilitates you being able to pass in the bar object as a parameter instead of
        // the function getting it from itself
        var obj = arguments[1] ? arguments[1] : this;

        var mouseXY = RG.getMouseXY(e),
            mouseX = mouseXY[0],
            mouseY = mouseXY[1],
            canvas = obj.canvas,
            context = obj.context,
            coords = obj.coords;

        for (var i = 0, len = coords.length; i < len; i += 1) {

            if (obj.coords[i].length == 0) {
                continue;
            }

            var left = coords[i][0],
                top = coords[i][1],
                width = coords[i][2],
                height = coords[i][3],
                prop = obj.properties;

            // Old way of testing
            //if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height)) {

            // Recreate the path/rectangle so that it can be tested
            //  ** DO NOT STROKE OR FILL IT **
            if (prop['chart.tooltips.hotspot.xonly']) {
                pa2(co, 'b r % % % %', left, this.gutterTop, width, ca.height - this.gutterBottom);
            } else {
                pa2(co, 'b r % % % %', left, top, width, height);
            }

            if (co.isPointInPath(mouseX, mouseY)) {

                if (prop['chart.tooltips']) {
                    var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                }

                // Work out the dataset
                var dataset = 0,
                    idx = i;

                while (idx >= (typeof obj.data[dataset] === 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {

                    if (typeof obj.data[dataset] === 'number') {
                        idx -= 1;
                    } else if (obj.data[dataset]) {
                        // Accounts for null being an object
                        idx -= obj.data[dataset].length;
                    } else {
                        idx -= 1;
                    }

                    dataset++;
                }

                if (typeof obj.data[dataset] == 'number') {
                    idx = null;
                }

                return {
                    0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                    'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset
                };
            }
        }

        return null;
    };

    /**
     * This retrives the bar based on the X coordinate only.
     *
     * @param object e The event object
     * @param object   OPTIONAL You can pass in the bar object instead of the
     *                          function using "this"
     */
    this.getShapeByX = function (e) {
        var canvas = e.target;
        var mouseCoords = RGraph.getMouseXY(e);

        // This facilitates you being able to pass in the bar object as a parameter instead of
        // the function getting it from itself
        var obj = arguments[1] ? arguments[1] : this;

        /**
         * Loop through the bars determining if the mouse is over a bar
         */
        for (var i = 0, len = obj.coords.length; i < len; i++) {

            if (obj.coords[i].length == 0) {
                continue;
            }

            var mouseX = mouseCoords[0];
            var mouseY = mouseCoords[1];
            var left = obj.coords[i][0];
            var top = obj.coords[i][1];
            var width = obj.coords[i][2];
            var height = obj.coords[i][3];
            var prop = obj.properties;

            if (mouseX >= left && mouseX <= left + width) {

                if (prop['chart.tooltips']) {
                    var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                }

                return {
                    0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                    'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip
                };
            }
        }

        return null;
    };

    /**
     * When you click on the chart, this method can return the Y value at that point. It works for any point on the
     * chart (that is inside the gutters) - not just points within the Bars.
     *
     * EITHER:
     *
     * @param object arg The event object
     *
     * OR:
     *
     * @param object arg A two element array containing the X and Y coordinates
     */
    this.getValue = function (arg) {
        var co = this.context;
        var ca = this.canvas;
        var prop = this.properties;

        if (arg.length == 2) {
            var mouseX = arg[0];
            var mouseY = arg[1];
        } else {
            var mouseCoords = RG.getMouseXY(arg);
            var mouseX = mouseCoords[0];
            var mouseY = mouseCoords[1];
        }

        if (mouseY < prop['chart.gutter.top'] || mouseY > ca.height - prop['chart.gutter.bottom'] || mouseX < prop['chart.gutter.left'] || mouseX > ca.width - prop['chart.gutter.right']) {
            return null;
        }

        if (prop['chart.xaxispos'] == 'center') {
            var value = (this.grapharea / 2 - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);
            value *= 2;

            if (value >= 0) {
                value += this.scale2.min;
            } else {
                value -= this.scale2.min;
            }
        } else if (prop['chart.xaxispos'] == 'top') {
            var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);
            value = this.scale2.max - value;
            value = ma.abs(value) * -1;
        } else {
            var value = (this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea * (this.scale2.max - this.scale2.min);
            value += this.scale2.min;
        }

        return value;
    };

    /**
     * This function can be used when the canvas is clicked on (or similar - depending on the event)
     * to retrieve the relevant Y coordinate for a particular value.
     *
     * @param int value The value to get the Y coordinate for
     */
    this.getYCoord = function (value) {

        if (value > this.scale2.max) {
            return null;
        }

        var co = this.context,
            ca = this.canvas,
            prop = this.properties;

        var y,
            xaxispos = prop['chart.xaxispos'];

        if (xaxispos == 'top') {

            // Account for negative numbers
            if (value < 0) {
                value = ma.abs(value);
            }

            y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * this.grapharea;
            y = y + this.gutterTop;
        } else if (xaxispos == 'center') {

            y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min) * (this.grapharea / 2);
            y = this.grapharea / 2 - y;
            y += this.gutterTop;
        } else {

            if (value < this.scale2.min) {
                value = this.scale2.min;
            }

            y = (value - this.scale2.min) / (this.scale2.max - this.scale2.min);
            y *= ca.height - this.gutterTop - this.gutterBottom;

            y = ca.height - this.gutterBottom - y;
        }

        return y;
    };

    /**
     * Each object type has its own Highlight() function which highlights the appropriate shape
     *
     * @param object shape The shape to highlight
     */
    this.highlight = this.Highlight = function (shape) {
        if (typeof prop['chart.highlight.style'] === 'function') {
            prop['chart.highlight.style'](shape);
        } else {
            // Add the new highlight
            RG.Highlight.Rect(this, shape);
        }
    };

    /**
     * The getObjectByXY() worker method
     */
    this.getObjectByXY = function (e) {
        var mouseXY = RG.getMouseXY(e);

        // Adjust the mouse Y coordinate for when the bar chart is
        // a 3D variant
        if (prop['chart.variant'] === '3d') {
            var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];
            mouseXY[1] -= adjustment;
        }

        if (mouseXY[0] >= prop['chart.gutter.left'] && mouseXY[0] <= ca.width - prop['chart.gutter.right'] && mouseXY[1] >= prop['chart.gutter.top'] && mouseXY[1] <= ca.height - prop['chart.gutter.bottom']) {

            return this;
        }
    };

    /**
     * This method handles the adjusting calculation for when the mouse is moved
     *
     * @param object e The event object
     */
    this.adjusting_mousemove = this.Adjusting_mousemove = function (e) {
        /**
         * Handle adjusting for the Bar
         */
        if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {

            // Rounding the value to the given number of decimals make the chart step
            var value = Number(this.getValue(e));
            var shape = RG.Registry.Get('chart.adjusting.shape');

            if (shape) {

                RG.Registry.Set('chart.adjusting.shape', shape);

                if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {

                    var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);

                    if (typeof this.data[indexes[0]] == 'number') {
                        this.data[indexes[0]] = Number(value);
                    } else if (!RG.isNull(this.data[indexes[0]])) {
                        this.data[indexes[0]][indexes[1]] = Number(value);
                    }
                } else if (typeof this.data[shape['index']] == 'number') {

                    this.data[shape['index']] = Number(value);
                }

                RG.redrawCanvas(e.target);
                RG.fireCustomEvent(this, 'onadjust');
            }
        }
    };

    /**
     * This allows for easy specification of gradients
     */
    this.parseColors = function () {
        // Save the original colors so that they can be restored when the canvas is reset
        if (this.original_colors.length === 0) {
            this.original_colors['chart.colors'] = RGraph.array_clone(prop['chart.colors']);
            this.original_colors['chart.key.colors'] = RGraph.array_clone(prop['chart.key.colors']);
            this.original_colors['chart.crosshairs.color'] = prop['chart.crosshairs.color'];
            this.original_colors['chart.highlight.stroke'] = prop['chart.highlight.stroke'];
            this.original_colors['chart.highlight.fill'] = prop['chart.highlight.fill'];
            this.original_colors['chart.text.color'] = prop['chart.text.color'];
            this.original_colors['chart.background.barcolor1'] = prop['chart.background.barcolor1'];
            this.original_colors['chart.background.barcolor2'] = prop['chart.background.barcolor2'];
            this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];
            this.original_colors['chart.background.color'] = prop['chart.background.color'];
            this.original_colors['chart.strokecolor'] = prop['chart.strokecolor'];
            this.original_colors['chart.axis.color'] = prop['chart.axis.color'];
        }

        // chart.colors
        var colors = prop['chart.colors'];
        if (colors) {
            for (var i = 0; i < colors.length; ++i) {
                colors[i] = this.parseSingleColorForGradient(colors[i]);
            }
        }

        // chart.key.colors
        var colors = prop['chart.key.colors'];
        if (colors) {
            for (var i = 0; i < colors.length; ++i) {
                colors[i] = this.parseSingleColorForGradient(colors[i]);
            }
        }

        prop['chart.crosshairs.color'] = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);
        prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
        prop['chart.highlight.fill'] = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
        prop['chart.text.color'] = this.parseSingleColorForGradient(prop['chart.text.color']);
        prop['chart.background.barcolor1'] = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);
        prop['chart.background.barcolor2'] = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);
        prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);
        prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);
        prop['chart.strokecolor'] = this.parseSingleColorForGradient(prop['chart.strokecolor']);
        prop['chart.axis.color'] = this.parseSingleColorForGradient(prop['chart.axis.color']);
    };

    /**
     * Use this function to reset the object to the post-constructor state. Eg reset colors if
     * need be etc
     */
    this.reset = function () {};

    /**
     * This parses a single color value
     */
    this.parseSingleColorForGradient = function (color) {
        if (!color || typeof color != 'string') {
            return color;
        }

        if (color.match(/^gradient\((.*)\)$/i)) {

            var parts = RegExp.$1.split(':');

            // Create the gradient
            var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);

            var diff = 1 / (parts.length - 1);

            grad.addColorStop(0, RG.trim(parts[0]));

            for (var j = 1, len = parts.length; j < len; ++j) {
                grad.addColorStop(j * diff, RGraph.trim(parts[j]));
            }
        }

        return grad ? grad : color;
    };

    this.drawBevel = this.DrawBevel = function () {
        var coords = this.coords;
        var coords2 = this.coords2;

        var prop = this.properties;
        var co = this.context;
        var ca = this.canvas;

        if (prop['chart.grouping'] == 'stacked') {
            for (var i = 0; i < coords2.length; ++i) {
                if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {

                    var x = coords2[i][0][0];
                    var y = coords2[i][0][1];
                    var w = coords2[i][0][2];

                    var arr = [];
                    for (var j = 0; j < coords2[i].length; ++j) {
                        arr.push(coords2[i][j][3]);
                    }
                    var h = RGraph.array_sum(arr);

                    co.save();

                    co.strokeStyle = 'black';

                    // Clip to the rect
                    co.beginPath();
                    co.rect(x, y, w, h);
                    co.clip();

                    // Add the shadow
                    co.shadowColor = 'black';
                    co.shadowOffsetX = 0;
                    co.shadowOffsetY = 0;
                    co.shadowBlur = 20;

                    co.beginPath();
                    co.rect(x - 3, y - 3, w + 6, h + 100);
                    co.lineWidth = 5;
                    co.stroke();
                    co.restore();
                }
            }
        } else {

            for (var i = 0; i < coords.length; ++i) {
                if (coords[i]) {

                    var x = coords[i][0];
                    var y = coords[i][1];
                    var w = coords[i][2];
                    var h = coords[i][3];

                    var xaxispos = prop['chart.xaxispos'];
                    var xaxis_ycoord = (ca.height - this.gutterTop - this.gutterBottom) / 2 + this.gutterTop;

                    co.save();

                    co.strokeStyle = 'black';

                    // Clip to the rect
                    co.beginPath();
                    co.rect(x, y, w, h);

                    co.clip();

                    // Add the shadow
                    co.shadowColor = 'black';
                    co.shadowOffsetX = 0;
                    co.shadowOffsetY = 0;
                    co.shadowBlur = 20;

                    if (xaxispos == 'top' || xaxispos == 'center' && y + h > xaxis_ycoord) {
                        y = y - 100;
                        h = h + 100;
                    } else {
                        y = y;
                        h = h + 100;
                    }

                    co.beginPath();
                    co.rect(x - 3, y - 3, w + 6, h + 6);
                    co.lineWidth = 5;
                    co.stroke();
                    co.restore();
                }
            }
        }
    };

    /**
     * This function handles highlighting an entire data-series for the interactive
     * key
     *
     * @param int index The index of the data series to be highlighted
     */
    this.interactiveKeyHighlight = function (index) {
        this.coords2.forEach(function (value, idx, arr) {
            if (typeof value[index] == 'object' && value[index]) {

                var x = value[index][0];
                var y = value[index][1];
                var w = value[index][2];
                var h = value[index][3];

                co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];
                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
                co.lineWidth = 2;
                co.strokeRect(x, y, w, h);
                co.fillRect(x, y, w, h);
            }
        });
    };

    /**
     * Using a function to add events makes it easier to facilitate method chaining
     *
     * @param string   type The type of even to add
     * @param function func
     */
    this.on = function (type, func) {
        if (type.substr(0, 2) !== 'on') {
            type = 'on' + type;
        }

        if (typeof this[type] !== 'function') {
            this[type] = func;
        } else {
            RG.addCustomEventListener(this, type, func);
        }

        return this;
    };

    /**
     * Draws the above labels
     */
    this.drawAboveLabels = function () {
        var labels = prop['chart.labels.above'],
            specific = prop['chart.labels.above.specific'],
            color = prop['chart.labels.above.color'],
            background = prop['chart.labels.above.background'],
            decimals = prop['chart.labels.above.decimals'],
            size = prop['chart.labels.above.size'],
            angle = -1 * prop['chart.labels.above.angle'],
            unitsPre = prop['chart.labels.above.units.pre'],
            unitsPost = prop['chart.labels.above.units.post'],
            coords = this.coords,
            coords2 = this.coords2,
            data = this.data,
            ldata = RG.arrayLinearize(this.data),
            offset = prop['chart.labels.above.offset'],
            text_font = prop['chart.text.font'],
            text_size = prop['chart.text.size'],
            grouping = prop['chart.grouping'];

        // Turn off any shadow
        RG.noShadow(this);

        // Color
        co.fillStyle = typeof color === 'string' ? color : prop['chart.text.color'];

        // This bit draws the text labels that appear above the bars if requested
        if (labels && grouping === 'grouped') {
            for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {

                // Alignment for regular, positive bars
                if (typeof data[i] === 'number' && data[i] >= 0) {

                    var angle = angle;
                    var halign = angle ? 'left' : 'center';
                    var valign = angle !== 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + coords2[i][0][2] / 2,
                        'y': coords2[i][0][1] - offset,
                        'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(typeof data[i] === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'marker': false,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;

                    // Alignment for regular, negative bars
                } else if (typeof data[i] === 'number' && data[i] < 0) {

                    var angle = angle;
                    var halign = angle ? 'right' : 'center';
                    var valign = angle !== 0 ? 'center' : 'top';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + coords2[i][0][2] / 2,
                        'y': coords2[i][0][1] + coords2[i][0][3] + offset,
                        'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(typeof data[i] === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;

                    // Alignment for grouped bars
                } else if (typeof data[i] === 'object') {

                    for (var j = 0, len2 = data[i].length; j < len2; j += 1) {

                        var angle = angle;
                        var halign = data[i][j] < 0 ? 'right' : 'left';
                        halign = angle === 0 ? 'center' : halign;
                        var valign = data[i][j] < 0 ? 'top' : 'bottom';
                        valign = angle != 0 ? 'center' : valign;

                        RG.text2(this, {
                            'font': text_font,
                            'size': typeof size === 'number' ? size : text_size - 3,
                            'x': coords2[i][j][0] + coords2[i][j][2] / 2,
                            'y': coords2[i][j][1] + (data[i][j] < 0 ? coords2[i][j][3] + offset : -offset),
                            'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i][j]).toFixed(decimals), unitsPre, unitsPost),
                            'halign': halign,
                            'valign': valign,
                            'angle': angle,
                            'bounding': true,
                            'bounding.fill': background,
                            'bounding.stroke': 'rgba(0,0,0,0)',
                            'marker': false,
                            'tag': 'labels.above'
                        });
                        sequentialIndex++;
                    }
                }
            }

            /**
             * STACKED bars
             */
        } else if (labels && grouping === 'stacked') {
            for (var i = 0, len = data.length, sequentialIndex = 0; i < len; i += 1) {
                if (typeof data[i] === 'object') {

                    var angle = angle;
                    var halign = angle != 0 ? 'left' : 'center';
                    var valign = angle != 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + coords2[i][0][2] / 2,
                        'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset,
                        'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(RG.arraySum(data[i])).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex += data[i].length;

                    /**
                     * Regular numbers but in a stacked grouping
                     */
                } else {

                    var angle = angle;
                    var halign = angle != 0 ? 'left' : 'center';
                    var valign = angle != 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + coords2[i][0][2] / 2,
                        'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset,
                        'text': specific ? specific[sequentialIndex] || '' : RG.numberFormat(this, Number(data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;
                }
            }
        }
    };

    /**
     * This function runs once only
     */
    this.firstDrawFunc = function () {};

    /**
     * (new) Bar chart Wave effect. This is a rewrite that should be smoother
     * because it just uses a single loop and not setTimeout
     *
     * @param object   OPTIONAL An object map of options. You specify 'frames' here to give the number of frames in the effect
     * @param function OPTIONAL A function that will be called when the effect is complete
     */
    this.wave = function () {
        var obj = this,
            opt = arguments[0] || {},
            labelsAbove = this.get('labelsAbove');

        opt.frames = opt.frames || 60;
        opt.startFrames = [];
        opt.counters = [];

        var framesperbar = opt.frames / 3,
            frame = -1,
            callback = arguments[1] || function () {},
            original = RG.arrayClone(this.original_data);

        //
        // turn off the labelsAbove option whilst animating
        //
        this.set('labelsAbove', false);

        for (var i = 0, len = obj.data.length; i < len; i += 1) {
            opt.startFrames[i] = opt.frames / 2 / (obj.data.length - 1) * i;

            if (typeof obj.data[i] === 'object' && obj.data[i]) {
                opt.counters[i] = [];
                for (var j = 0; j < obj.data[i].length; j++) {
                    opt.counters[i][j] = 0;
                }
            } else {
                opt.counters[i] = 0;
            }
        }

        /**
         * This stops the chart from jumping
         */
        obj.draw();
        obj.Set('ymax', obj.scale2.max);
        RG.clear(obj.canvas);

        function iterator() {
            ++frame;

            for (var i = 0, len = obj.data.length; i < len; i += 1) {
                if (frame > opt.startFrames[i]) {
                    if (typeof obj.data[i] === 'number') {

                        obj.data[i] = ma.min(ma.abs(original[i]), ma.abs(original[i] * (opt.counters[i]++ / framesperbar)));

                        // Make the number negative if the original was
                        if (original[i] < 0) {
                            obj.data[i] *= -1;
                        }
                    } else if (!RG.isNull(obj.data[i])) {
                        for (var j = 0, len2 = obj.data[i].length; j < len2; j += 1) {

                            obj.data[i][j] = ma.min(ma.abs(original[i][j]), ma.abs(original[i][j] * (opt.counters[i][j]++ / framesperbar)));

                            // Make the number negative if the original was
                            if (original[i][j] < 0) {
                                obj.data[i][j] *= -1;
                            }
                        }
                    }
                } else {
                    obj.data[i] = typeof obj.data[i] === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : RG.isNull(obj.data[i]) ? null : 0;
                }
            }

            if (frame >= opt.frames) {

                if (labelsAbove) {
                    obj.set('labelsAbove', true);
                    RG.redraw();
                }

                callback(obj);
            } else {
                RG.redrawCanvas(obj.canvas);
                RG.Effects.updateCanvas(iterator);
            }
        }

        iterator();

        return this;
    };

    /**
     * Color Wave effect. This fades in color sequentially like the wave effect
     * makes the bars grow.
     *
     * @param object   OPTIONAL An object map of options. You specify 'frames'
     *                          here to give the number of frames in the effect
     * @param function OPTIONAL A function that will be called when the effect
     *                          is complete
     */
    this.colorWave = function () {
        var obj = this,
            opt = arguments[0] || {};
        opt.frames = opt.frames || 60;
        opt.startFrames = [];
        opt.counters = [], colors = obj.properties['chart.colors'];

        // If just one color is specified and colorsSequential is not, then
        // pad the colors array out
        if (colors.length <= obj.data.length) {
            obj.set('chart.colors.sequential', true);
            colors = RG.arrayPad(colors, obj.data.length, colors[colors.length - 1]);
        }

        var framesperbar = opt.frames / 2,
            frame = -1,
            callback = arguments[1] || function () {},
            originalColors = RG.arrayClone(obj.properties['chart.colors']);

        for (var i = 0, len = originalColors.length; i < len; i += 1) {
            opt.startFrames[i] = opt.frames / 2 / (originalColors.length - 1) * i;
            opt.counters[i] = 0;
        }

        function iterator() {
            ++frame;

            for (var i = 0, len = colors.length; i < len; i += 1) {
                if (frame > opt.startFrames[i] && colors[i].match(/^rgba?\(([0-9 ]+),([0-9 ]+),([0-9 ]+)(,([ 0-9.]+)?)\)/)) {

                    // DO NOT USE SPACES!
                    colors[i] = 'rgba({1},{2},{3},{4})'.format(RegExp.$1, RegExp.$2, RegExp.$3, (frame - opt.startFrames[i]) / framesperbar);
                } else {
                    colors[i] = colors[i].replace(/,[0-9. ]+\)/, ',0)');
                }
            }

            if (frame >= opt.frames) {
                callback(obj);
            } else {
                RG.redrawCanvas(obj.canvas);
                RG.Effects.updateCanvas(iterator);
            }
        }

        iterator();

        return this;
    };

    /**
     * Grow
     *
     * The Bar chart Grow effect gradually increases the values of the bars
     *
     * @param object       An object of options - eg: {frames: 30}
     * @param function     A function to call when the effect is complete
     */
    this.grow = function () {
        // Callback
        var opt = arguments[0] || {},
            frames = opt.frames || 30,
            frame = 0,
            callback = arguments[1] || function () {},
            obj = this,
            labelsAbove = this.get('labelsAbove');

        // Go through the data and change string arguments of the format +/-[0-9]
        // to absolute numbers
        if (RG.isArray(opt.data)) {

            var ymax = 0;

            for (var i = 0; i < opt.data.length; ++i) {
                if (typeof opt.data[i] === 'object') {
                    for (var j = 0; j < opt.data[i].length; ++j) {
                        if (typeof opt.data[i][j] === 'string' && opt.data[i][j].match(/(\+|\-)([0-9]+)/)) {
                            if (RegExp.$1 === '+') {
                                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);
                            } else {
                                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);
                            }
                        }

                        ymax = ma.max(ymax, opt.data[i][j]);
                    }
                } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\+|\-)([0-9]+)/)) {
                    if (RegExp.$1 === '+') {
                        opt.data[i] = this.original_data[i] + parseInt(RegExp.$2);
                    } else {
                        opt.data[i] = this.original_data[i] - parseInt(RegExp.$2);
                    }
                    ymax = ma.max(ymax, opt.data[i]);
                } else {
                    ymax = ma.max(ymax, opt.data[i]);
                }
            }

            var scale = RG.getScale2(this, { 'max': ymax });
            this.Set('chart.ymax', scale.max);
        }

        //
        // turn off the labelsAbove option whilst animating
        //
        this.set('labelsAbove', false);

        // Stop the scale from changing by setting chart.ymax (if it's not already set)
        if (prop['chart.ymax'] == null) {

            var ymax = 0;

            for (var i = 0; i < obj.data.length; ++i) {
                if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {
                    ymax = ma.max(ymax, ma.abs(RG.arraySum(this.data[i])));
                } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {

                    for (var j = 0, group = []; j < this.data[i].length; j++) {
                        group.push(ma.abs(this.data[i][j]));
                    }

                    ymax = ma.max(ymax, ma.abs(RG.arrayMax(group)));
                } else {
                    ymax = ma.max(ymax, ma.abs(this.data[i]));
                }
            }

            var scale = RG.getScale2(this, { 'max': ymax });
            this.Set('chart.ymax', scale.max);
        }

        // You can give a ymax to the grow function
        if (typeof opt.ymax === 'number') {
            obj.set('ymax', opt.ymax);
        }

        var iterator = function () {
            var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);

            // Alter the Bar chart data depending on the frame
            for (var j = 0, len = obj.original_data.length; j < len; ++j) {
                if (typeof obj.data[j] === 'object' && !RG.isNull(obj.data[j])) {
                    for (var k = 0, len2 = obj.data[j].length; k < len2; ++k) {
                        if (obj.firstDraw || !opt.data) {
                            obj.data[j][k] = easingMultiplier * obj.original_data[j][k];
                        } else if (opt.data && opt.data.length === obj.original_data.length) {
                            var diff = opt.data[j][k] - obj.original_data[j][k];
                            obj.data[j][k] = easingMultiplier * diff + obj.original_data[j][k];
                        }
                    }
                } else {

                    if (obj.firstDraw || !opt.data) {
                        obj.data[j] = easingMultiplier * obj.original_data[j];
                    } else if (opt.data && opt.data.length === obj.original_data.length) {
                        var diff = opt.data[j] - obj.original_data[j];
                        obj.data[j] = easingMultiplier * diff + obj.original_data[j];
                    }
                }
            }

            //RGraph.clear(obj.canvas);
            RG.redrawCanvas(obj.canvas);

            if (frame < frames) {
                frame += 1;

                RG.Effects.updateCanvas(iterator);

                // Call the callback function
            } else {

                // Do some housekeeping if new data was specified thats done in
                // the constructor - but needs to be redone because new data
                // has been specified
                if (RG.isArray(opt.data)) {

                    var linear_data = RG.arrayLinearize(data);

                    for (var i = 0; i < linear_data.length; ++i) {
                        if (!obj['$' + i]) {
                            obj['$' + i] = {};
                        }
                    }
                }

                obj.data = data;
                obj.original_data = RG.arrayClone(data);

                if (labelsAbove) {
                    obj.set('labelsAbove', true);
                    RG.redraw();
                }
                callback(obj);
            }
        };

        iterator();

        return this;
    };

    //
    // Draws error-bars for the Bar and Line charts
    //
    this.drawErrorbars = function () {
        var coords = this.coords,
            color = prop['chart.errorbars.color'] || 'black',
            default_halfwidth = ma.min(prop['chart.errorbars.capped.width'], coords[0][2]) / 2,
            x = 0,
            errorbars = prop['chart.errorbars'],
            length = 0;

        // If not capped set the width of the cqap to zero
        if (!prop['chart.errorbars.capped']) {
            prop['chart.errorbars.capped.width'] = 0;
            halfwidth = 0;
        }

        // Set the linewidth
        co.lineWidth = prop['chart.errorbars.linewidth'];

        for (var i = 0; i < coords.length; ++i) {

            // Default to black
            color = prop['chart.errorbars.color'] || 'black';

            // Set the perbar linewidth if the fourth option in the array
            // is specified
            if (errorbars[i] && typeof errorbars[i][3] === 'number') {
                co.lineWidth = errorbars[i][3];
            }

            // Set the halfwidth
            var halfwidth = errorbars[i] && typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;

            if (!prop['chart.errorbars.capped']) {
                halfwidth = 0;
            }

            // Calulate the pixel size
            if (typeof errorbars[i] === 'number') {

                length = ma.abs(this.getYCoord(errorbars[i]) - this.getYCoord(0));

                if (length) {
                    pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - length, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - length), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - length), color);
                }
            } else if (typeof errorbars[i] === 'object' && !RG.isNull(errorbars[i])) {

                var positiveLength = ma.abs(this.getYCoord(errorbars[i][0]) - this.getYCoord(0));

                // Color
                if (typeof errorbars[i][1] === 'string') {
                    color = errorbars[i][1];
                } else if (typeof errorbars[i][2] === 'string') {
                    color = errorbars[i][2];
                }

                // Cap width
                halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;

                if (!prop['chart.errorbars.capped']) {
                    halfwidth = 0;
                }

                if (!RG.isNull(errorbars[i][0])) {
                    pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] - positiveLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] - positiveLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] - positiveLength), color);
                }

                if (typeof errorbars[i][1] === 'number') {

                    var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));

                    pa2(co, 'b m % % l % % l % % l % % s %', coords[i][0] + coords[i][2] / 2, coords[i][1], coords[i][0] + coords[i][2] / 2, coords[i][1] + negativeLength, coords[i][0] + coords[i][2] / 2 - halfwidth, ma.round(coords[i][1] + negativeLength), coords[i][0] + coords[i][2] / 2 + halfwidth, ma.round(coords[i][1] + negativeLength), color);
                }
            }

            // Reset the perbar linewidth to the default if the fourth option
            // in the array was specified specified
            if (errorbars[i] && typeof errorbars[i][3] === 'number') {
                co.lineWidth = prop['chart.errorbars.linewidth'];
            }
        }
    };

    //
    // A per-object to test whether a particular bar is adjustable or not
    //
    // @param shape The shape object
    //
    this.isAdjustable = function (shape) {
        if (RG.isNull(prop['chart.adjustable.only']) || !RG.isArray(prop['chart.adjustable.only'])) {
            return true;
        }

        if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {
            return true;
        }

        return false;
    };

    /**
     * Register the object
     */
    RG.register(this);

    /**
     * This is the 'end' of the constructor so if the first argument
     * contains configuration dsta - handle that.
     */
    if (parseConfObjectForOptions) {
        RG.parseObjectStyleConfig(this, conf.options);
    }
};

/*********************************************************************************************************
 * This is the combined bar and Line class which makes creating bar/line combo charts a little bit easier *
 /*********************************************************************************************************/

RGraph.CombinedChart = function () {
    /**
     * Create a default empty array for the objects
     */
    this.objects = [];
    var objects = [];

    if (RGraph.isArray(arguments[0])) {
        objects = arguments[0];
    } else {

        for (var i = 0; i < arguments.length; i += 1) {

            objects[i] = arguments[i];
        }
    }

    for (var i = 0; i < objects.length; ++i) {

        this.objects[i] = objects[i];

        /**
         * Set the Line chart gutters to match the Bar chart gutters
         */
        this.objects[i].set({
            gutterLeft: this.objects[0].get('gutter.left'), // Needs to use the dot form to skirt an IE9 bug
            gutterRight: this.objects[0].get('gutter.right'), // Needs to use the dot form to skirt an IE9 bug
            gutterTop: this.objects[0].get('gutter.top'), // Needs to use the dot form to skirt an IE9 bug
            gutterBottom: this.objects[0].get('gutter.bottom') // Needs to use the dot form to skirt an IE9 bug
        });

        if (this.objects[i].type == 'line') {

            var obj = this.objects[i];

            /**
             * Set the line chart hmargin
             */
            obj.set('hmargin', (this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length / 2);

            /**
             * No labels, axes or grid on the Line chart
             */
            obj.set('noaxes', true);
            obj.set('backgroundGrid', false);
            obj.set('ylabels', false);
        }

        /**
         * Resizing
         */
        if (this.objects[i].get('chart.resizable')) {
            var resizable_object = obj;
        }
    }

    /**
     * Resizing
     */
    if (resizable_object) {
        /**
         * This recalculates the Line chart hmargin when the chart is resized
         */
        function myOnresizebeforedraw(obj) {
            var gutterLeft = obj.get('gutterLeft');
            var gutterRight = obj.get('gutterRight');

            obj.set('hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));
        }

        RGraph.AddCustomEventListener(resizable_object, 'onresizebeforedraw', myOnresizebeforedraw);
    }
};

/**
 * The Add method can be used to add methods to the CombinedChart object.
 */
RGraph.CombinedChart.prototype.add = RGraph.CombinedChart.prototype.Add = function (obj) {
    this.objects.push(obj);
};

/**
 * The Draw method goes through all of the objects drawing them (sequentially)
 */
RGraph.CombinedChart.prototype.draw = RGraph.CombinedChart.prototype.Draw = function () {
    for (var i = 0; i < this.objects.length; ++i) {
        if (this.objects[i].properties['chart.combinedchart.effect']) {

            var options = this.objects[i].properties['chart.combinedchart.effect.options'] ? eval('(' + this.objects[i].properties['chart.combinedchart.effect.options'] + ')') : null;

            this.objects[i][this.objects[i].properties['chart.combinedchart.effect']](options, this.objects[i].properties['chart.combinedchart.effect.callback']);
        } else {
            this.objects[i].draw();
        }
    }
};