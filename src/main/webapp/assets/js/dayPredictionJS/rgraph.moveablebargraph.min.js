// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

RGraph = window.RGraph || {isRGraph: true};

// Module pattern
(function (win, doc, undefined)
{
    var RG  = RGraph,
        ua  = navigator.userAgent,
        ma  = Math;




    /**
     * Initialise the various objects
     */
    RG.Highlight      = {};
    RG.Registry       = {};
    RG.Registry.store = [];
    RG.Registry.store['chart.event.handlers']       = [];
    RG.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips
    RG.Background     = {};
    RG.background     = {};
    RG.objects        = [];
    RG.Resizing       = {};
    RG.events         = [];
    RG.cursor         = [];
    RG.Effects        = RG.Effects || {};
    RG.cache          = [];

    RG.ObjectRegistry                    = {};
    RG.ObjectRegistry.objects            = {};
    RG.ObjectRegistry.objects.byUID      = [];
    RG.ObjectRegistry.objects.byCanvasID = [];
    RG.OR                                = RG.ObjectRegistry;




    /**
     * Some "constants". The ua variable is navigator.userAgent (definedabove)
     */
    RG.PI       = ma.PI;
    RG.HALFPI   = RG.PI / 2;
    RG.TWOPI    = RG.PI * 2;

    RG.ISFF     = ua.indexOf('Firefox') != -1;
    RG.ISOPERA  = ua.indexOf('Opera') != -1;
    RG.ISCHROME = ua.indexOf('Chrome') != -1;
    RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;
    RG.ISWEBKIT = ua.indexOf('WebKit') != -1;

    RG.ISIE   = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;
    RG.ISIE6  = ua.indexOf('MSIE 6') > 0;
    RG.ISIE7  = ua.indexOf('MSIE 7') > 0;
    RG.ISIE8  = ua.indexOf('MSIE 8') > 0;
    RG.ISIE9  = ua.indexOf('MSIE 9') > 0;
    RG.ISIE10 = ua.indexOf('MSIE 10') > 0;
    RG.ISOLD  = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here

    RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;
    RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;
    RG.ISIE9UP  = RG.ISIE9 || RG.ISIE10UP;




    /**
     * Returns five values which are used as a nice scale
     *
     * @param  max int    The maximum value of the graph
     * @param  obj object The graph object
     * @return     array   An appropriate scale
     */
    RG.getScale = function (max, obj)
    {
        /**
         * Special case for 0
         */
        if (max == 0) {
            return ['0.2', '0.4', '0.6', '0.8', '1.0'];
        }

        var original_max = max;

        /**
         * Manually do decimals
         */
        if (max <= 1) {
            if (max > 0.5) {
                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];

            } else if (max >= 0.1) {
                return obj.Get('chart.scale.round') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];

            } else {

                var tmp = max;
                var exp = 0;

                while (tmp < 1.01) {
                    exp += 1;
                    tmp *= 10;
                }

                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];


                if (max <= ('5e-' + exp)) {
                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];
                }

                return ret;
            }
        }

        // Take off any decimals
        if (String(max).indexOf('.') > 0) {
            max = String(max).replace(/\.\d+$/, '');
        }

        var interval = ma.pow(10, Number(String(Number(max)).length - 1));
        var topValue = interval;

        while (topValue < max) {
            topValue += (interval / 2);
        }

        // Handles cases where the max is (for example) 50.5
        if (Number(original_max) > Number(topValue)) {
            topValue += (interval / 2);
        }

        // Custom if the max is greater than 5 and less than 10
        if (max < 10) {
            topValue = (Number(original_max) <= 5 ? 5 : 10);
        }

        /**
         * Added 02/11/2010 to create "nicer" scales
         */
        if (obj && typeof(obj.Get('chart.scale.round')) == 'boolean' && obj.Get('chart.scale.round')) {
            topValue = 10 * interval;
        }

        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];
    };




    /**
     * Returns an appropriate scale. The return value is actualy an object consisting of:
     *  scale.max
     *  scale.min
     *  scale.scale
     *
     * @param  obj object  The graph object
     * @param  prop object An object consisting of configuration properties
     * @return     object  An object containg scale information
     */
    RG.getScale2 = function (obj, opt)
    {
        var ca           = obj.canvas,
            co           = obj.context,
            prop         = obj.properties,
            numlabels    = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,
            units_pre    = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',
            units_post   = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',
            max          = Number(opt['max']),
            min          = typeof opt['min'] == 'number' ? opt['min'] : 0,
            strict       = opt['strict'],
            decimals     = Number(opt['scale.decimals']), // Sometimes the default is null
            point        = opt['scale.point'], // Default is a string in all chart libraries so no need to cast it
            thousand     = opt['scale.thousand'], // Default is a string in all chart libraries so no need to cast it
            original_max = max,
            round        = opt['scale.round'],
            scale        = {max:1,labels:[],values:[]}



        /**
         * Special case for 0
         *
         * ** Must be first **
         */
        if (!max) {

            var max   = 1;

            for (var i=0; i<numlabels; ++i) {

                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);

                scale.labels.push(units_pre + label + units_post);
                scale.values.push(parseFloat(label))
            }

            /**
             * Manually do decimals
             */
        } else if (max <= 1 && !strict) {

            var arr = [
                1,0.5,
                0.10,0.05,
                0.010,0.005,
                0.0010,0.0005,
                0.00010,0.00005,
                0.000010,0.000005,
                0.0000010,0.0000005,
                0.00000010,0.00000005,
                0.000000010,0.000000005,
                0.0000000010,0.0000000005,
                0.00000000010,0.00000000005,
                0.000000000010,0.000000000005,
                0.0000000000010,0.0000000000005
            ], vals = [];



            for (var i=0; i<arr.length; ++i) {
                if (max > arr[i]) {
                    i--;
                    break;
                }
            }


            scale.max = arr[i]
            scale.labels = [];
            scale.values = [];

            for (var j=0; j<numlabels; ++j) {

                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);

                scale.values.push(value);
                scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));
            }




        } else if (!strict) {

            /**
             * Now comes the scale handling for integer values
             */

            // This accomodates decimals by rounding the max up to the next integer
            max = ma.ceil(max);

            var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)) );

            var topValue = interval;

            while (topValue < max) {
                topValue += (interval / 2);
            }

            // Handles cases where the max is (for example) 50.5
            if (Number(original_max) > Number(topValue)) {
                topValue += (interval / 2);
            }

            // Custom if the max is greater than 5 and less than 10
            if (max <= 10) {
                topValue = (Number(original_max) <= 5 ? 5 : 10);
            }


            // Added 02/11/2010 to create "nicer" scales
            if (obj && typeof(round) == 'boolean' && round) {
                topValue = 10 * interval;
            }

            scale.max = topValue;

            // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those
            //that we've been given as the number_format functuion looks at those instead of using argumrnts.
            var tmp_point    = prop['chart.scale.point'];
            var tmp_thousand = prop['chart.scale.thousand'];

            obj.Set('chart.scale.thousand', thousand);
            obj.Set('chart.scale.point', point);


            for (var i=0; i<numlabels; ++i) {
                scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals), units_pre, units_post) );
                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));
            }

            obj.Set('chart.scale.thousand', tmp_thousand);
            obj.Set('chart.scale.point', tmp_point);

        } else if (typeof(max) == 'number' && strict) {

            /**
             * ymax is set and also strict
             */
            for (var i=0; i<numlabels; ++i) {
                scale.labels.push(RG.numberFormat(
                    obj,
                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),
                    units_pre,
                    units_post
                ));

                scale.values.push(
                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)
                );
            }

            // ???
            scale.max = max;
        }


        scale.units_pre  = units_pre;
        scale.units_post = units_post;
        scale.point      = point;
        scale.decimals   = decimals;
        scale.thousand   = thousand;
        scale.numlabels  = numlabels;
        scale.round      = Boolean(round);
        scale.min        = min;

        //
        // Convert all of the scale values to numbers
        //
        for (var i=0; i<scale.values.length; ++i) {
            scale.values[i] = parseFloat(scale.values[i]);
        }

        return scale;
    };




    //
    // Converts an the truthy values to falsey values and vice-versa
    //
    RG.arrayInvert = function (arr)
    {
        for (var i=0,len=arr.length; i<len; ++i) {
            arr[i] = !arr[i];
        }

        return arr;
    };




    //
    // An array_trim function that removes the empty elements off
    //both ends
    //
    RG.arrayTrim = function (arr)
    {
        var out = [], content = false;

        // Trim the start
        for (var i=0; i<arr.length; i++) {

            if (arr[i]) {
                content = true;
            }

            if (content) {
                out.push(arr[i]);
            }
        }

        // Reverse the array and trim the start again
        out = RG.arrayReverse(out);

        var out2 = [], content = false ;
        for (var i=0; i<out.length; i++) {

            if (out[i]) {
                content = true;
            }

            if (content) {
                out2.push(out[i]);
            }
        }

        // Now reverse the array and return it
        out2 = RG.arrayReverse(out2);

        return out2;
    };




    /**
     * Makes a clone of an object
     *
     * @param obj val The object to clone
     */
    RG.arrayClone =
        RG.array_clone = function (obj)
        {
            if(obj === null || typeof obj !== 'object') {
                return obj;
            }

            var temp = [];

            for (var i=0,len=obj.length;i<len; ++i) {

                if (typeof obj[i]  === 'number') {
                    temp[i] = (function (arg) {return Number(arg);})(obj[i]);

                } else if (typeof obj[i]  === 'string') {
                    temp[i] = (function (arg) {return String(arg);})(obj[i]);

                } else if (typeof obj[i] === 'function') {
                    temp[i] = obj[i];

                } else {
                    temp[i] = RG.arrayClone(obj[i]);
                }
            }

            return temp;
        };




    /**
     * Returns the maximum numeric value which is in an array. This function IS NOT
     * recursive
     *
     * @param  array arr The array (can also be a number, in which case it's returned as-is)
     * @param  int       Whether to ignore signs (ie negative/positive)
     * @return int       The maximum value in the array
     */
    RG.arrayMax =
        RG.array_max = function (arr)
        {
            var max = null,
                ma  = Math

            if (typeof arr === 'number') {
                return arr;
            }

            if (RG.isNull(arr)) {
                return 0;
            }

            for (var i=0,len=arr.length; i<len; ++i) {
                if (typeof arr[i] === 'number') {

                    var val = arguments[1] ? ma.abs(arr[i]) : arr[i];

                    if (typeof max === 'number') {
                        max = ma.max(max, val);
                    } else {
                        max = val;
                    }
                }
            }

            return max;
        };




    /**
     * Returns the minimum numeric value which is in an array
     *
     * @param  array arr The array (can also be a number, in which case it's returned as-is)
     * @param  int       Whether to ignore signs (ie negative/positive)
     * @return int       The minimum value in the array
     */
    RG.arrayMin = function (arr)
    {
        var max = null,
            min = null,
            ma  = Math;

        if (typeof arr === 'number') {
            return arr;
        }

        if (RG.isNull(arr)) {
            return 0;
        }

        for (var i=0,len=arr.length; i<len; ++i) {
            if (typeof arr[i] === 'number') {

                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];

                if (typeof min === 'number') {
                    min = ma.min(min, val);
                } else {
                    min = val;
                }
            }
        }

        return min;
    };




    /**
     * Returns the maximum value which is in an array
     *
     * @param  array arr The array
     * @param  int   len The length to pad the array to
     * @param  mixed     The value to use to pad the array (optional)
     */
    RG.arrayPad =
        RG.array_pad = function (arr, len)
        {
            if (arr.length < len) {
                var val = arguments[2] ? arguments[2] : null;

                for (var i=arr.length; i<len; i+=1) {
                    arr[i] = val;
                }
            }

            return arr;
        };




    /**
     * An array sum function
     *
     * @param  array arr The  array to calculate the total of
     * @return int       The summed total of the arrays elements
     */
    RG.arraySum =
        RG.array_sum = function (arr)
        {
            // Allow integers
            if (typeof arr === 'number') {
                return arr;
            }

            // Account for null
            if (RG.is_null(arr)) {
                return 0;
            }

            var i, sum, len = arr.length;

            for(i=0,sum=0;i<len;sum+=arr[i++]);

            return sum;
        };




    /**
     * Takes any number of arguments and adds them to one big linear array
     * which is then returned
     *
     * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
     */
    RG.arrayLinearize =
        RG.array_linearize = function ()
        {
            var arr  = [],
                args = arguments

            for (var i=0,len=args.length; i<len; ++i) {

                if (typeof args[i] === 'object' && args[i]) {
                    for (var j=0,len2=args[i].length; j<len2; ++j) {
                        var sub = RG.array_linearize(args[i][j]);

                        for (var k=0,len3=sub.length; k<len3; ++k) {
                            arr.push(sub[k]);
                        }
                    }
                } else {
                    arr.push(args[i]);
                }
            }

            return arr;
        };




    /**
     * Takes one off the front of the given array and returns the new array.
     *
     * @param array arr The array from which to take one off the front of array
     *
     * @return array The new array
     */
    RG.arrayShift =
        RG.array_shift = function(arr)
        {
            var ret = [];

            for(var i=1,len=arr.length; i<len; ++i) {
                ret.push(arr[i]);
            }

            return ret;
        };




    /**
     * Reverses the order of an array
     *
     * @param array arr The array to reverse
     */
    RG.arrayReverse =
        RG.array_reverse = function (arr)
        {
            if (!arr) {
                return;
            }

            var newarr=[];

            for(var i=arr.length - 1; i>=0; i-=1) {
                newarr.push(arr[i]);
            }

            return newarr;
        };




    /**
     * Returns the absolute value of a number. You can also pass in an
     * array and it will run the abs() function on each element. It
     * operates recursively so sub-arrays are also traversed.
     *
     * @param array arr The number or array to work on
     */
    RG.abs = function (value)
    {
        if (typeof value === 'string') {
            value = parseFloat(value) || 0;
        }

        if (typeof value === 'number') {
            return ma.abs(value);
        }

        if (typeof value === 'object') {
            for (i in value) {
                if (   typeof i === 'string'
                    || typeof i === 'number'
                    || typeof i === 'object') {

                    value[i] = RG.abs(value[i]);
                }
            }

            return value;
        }

        return 0;
    };




    /**
     * Clears the canvas by setting the width. You can specify a colour if you wish.
     *
     * @param object canvas The canvas to clear
     * @param mixed         Usually a color string to use to clear the canvas
     *                      with - could also be a gradient object
     */
    RG.clear =
        RG.Clear = function (ca)
        {
            var obj   = ca.__object__,
                co    = ca.getContext('2d'),
                color = arguments[1] || (obj && obj.get('clearto'))

            if (!ca) {
                return;
            }

            RG.fireCustomEvent(obj, 'onbeforeclear');

            /**
             * Set the CSS display: to none for DOM text
             */
            if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {
                for (var i in RG.text2.domNodeCache[ca.id]) {

                    var el = RG.text2.domNodeCache[ca.id][i];

                    if (el && el.style) {
                        el.style.display = 'none';
                    }
                }
            }

            /**
             * Can now clear the canvas back to fully transparent
             */
            if (   !color
                || (color && color === 'rgba(0,0,0,0)' || color === 'transparent')
            ) {

                co.clearRect(-100,-100,ca.width + 200, ca.height + 200);

                // Reset the globalCompositeOperation
                co.globalCompositeOperation = 'source-over';

            } else if (color) {
                RG.path2(co, 'fs % fr -100 -100 % %',
                    color,
                    ca.width + 200,
                    ca.height + 200
                );

            } else {
                RG.path2(co, 'fs % fr -100 -100 % %',
                    obj.get('clearto'),
                    ca.width + 200,
                    ca.height + 200
                );
            }

            //if (RG.ClearAnnotations) {
            //RG.ClearAnnotations(ca.id);
            //}

            /**
             * This removes any background image that may be present
             */
            if (RG.Registry.Get('chart.background.image.' + ca.id)) {
                var img = RG.Registry.Get('chart.background.image.' + ca.id);
                img.style.position = 'absolute';
                img.style.left     = '-10000px';
                img.style.top      = '-10000px';
            }

            /**
             * This hides the tooltip that is showing IF it has the same canvas ID as
             * that which is being cleared
             */
            if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {
                RG.HideTooltip(ca);
                //RG.Redraw();
            }



            //
            // Hide all DOM text by positioning it outside the canvas
            //
            //for (i in RG.cache) {
            //    if (typeof i === 'string' && i.indexOf('-text-') > 0) {
            //        RG.cache[i].style.left = '-100px';
            //        RG.cache[i].style.top  = '-100px';
            //    }
            //}

            /**
             * Set the cursor to default
             */
            ca.style.cursor = 'default';

            RG.FireCustomEvent(obj, 'onclear');
        };




    /**
     * Draws the title of the graph
     *
     * @param object  canvas The canvas object
     * @param string  text   The title to write
     * @param integer gutter The size of the gutter
     * @param integer        The center X point (optional - if not given it will be generated from the canvas width)
     * @param integer        Size of the text. If not given it will be 14
     * @param object         An optional object which has canvas and context properties to use instead of those on
     *                       the obj argument (so as to enable caching)
     */
    RG.drawTitle =
        RG.DrawTitle = function (obj, text, gutterTop)
        {
            var ca = canvas  = obj.canvas,
                co = context = obj.context,
                prop         = obj.properties
            gutterLeft   = prop['chart.gutter.left'],
                gutterRight  = prop['chart.gutter.right'],
                gutterTop    = gutterTop,
                gutterBottom = prop['chart.gutter.bottom'],
                size         = arguments[4] ? arguments[4] : 12,
                bold         = prop['chart.title.bold'],
                italic       = prop['chart.title.italic'],
                centerx      = (arguments[3] ? arguments[3] : ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft),
                keypos       = prop['chart.key.position'],
                vpos         = prop['chart.title.vpos'],
                hpos         = prop['chart.title.hpos'],
                bgcolor      = prop['chart.title.background'],
                x            = prop['chart.title.x'],
                y            = prop['chart.title.y'],
                halign       = 'center',
                valign       = 'center'

            // Account for 3D effect by faking the key position
            if (obj.type == 'bar' && prop['chart.variant'] == '3d') {
                keypos = 'gutter';
            }

            co.beginPath();
            co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';





            /**
             * Vertically center the text if the key is not present
             */
            if (keypos && keypos != 'gutter') {
                var valign = 'center';

            } else if (!keypos) {
                var valign = 'center';

            } else {
                var valign = 'bottom';
            }





            // if chart.title.vpos is a number, use that
            if (typeof prop['chart.title.vpos'] === 'number') {
                vpos = prop['chart.title.vpos'] * gutterTop;

                if (prop['chart.xaxispos'] === 'top') {
                    vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);
                }

            } else {
                vpos = gutterTop - size - 5;

                if (prop['chart.xaxispos'] === 'top') {
                    vpos = ca.height  - gutterBottom + size + 5;
                }
            }




            // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width
            if (typeof hpos === 'number') {
                centerx = hpos * ca.width;
            }

            /**
             * Now the chart.title.x and chart.title.y settings override (is set) the above
             */
            if (typeof x === 'number') centerx = x;
            if (typeof y === 'number') vpos    = y;




            /**
             * Horizontal alignment can now (Jan 2013) be specified
             */
            if (typeof prop['chart.title.halign'] === 'string') {
                halign = prop['chart.title.halign'];
            }

            /**
             * Vertical alignment can now (Jan 2013) be specified
             */
            if (typeof prop['chart.title.valign'] === 'string') {
                valign = prop['chart.title.valign'];
            }





            // Set the colour
            if (typeof prop['chart.title.color'] !== null) {
                var oldColor = co.fillStyle
                var newColor = prop['chart.title.color'];
                co.fillStyle = newColor ? newColor : 'black';
            }




            /**
             * Default font is Arial
             */
            var font = prop['chart.text.font'];




            /**
             * Override the default font with chart.title.font
             */
            if (typeof prop['chart.title.font'] === 'string') {
                font = prop['chart.title.font'];
            }




            /**
             * Draw the title
             */

            var ret = RG.text2(obj, {
                font:font,
                size:size,
                x:centerx,
                y:vpos,
                text:text,
                valign:valign,
                halign:halign,
                bounding:bgcolor != null,
                'bounding.fill':bgcolor,
                'bold':bold,
                italic: italic,
                tag:'title',
                marker: false
            });

            // Reset the fill colour
            co.fillStyle = oldColor;
        };




    /**
     * Gets the mouse X/Y coordinates relative to the canvas
     *
     * @param object e The event object. As such this method should be used in an event listener.
     */
    RG.getMouseXY = function(e)
    {
        // This is necessary foe IE9
        if (!e.target) {
            return;
        }

        var el      = e.target;
        var ca      = el;
        var caStyle = ca.style;
        var offsetX = 0;
        var offsetY = 0;
        var x;
        var y;
        var borderLeft  = parseInt(caStyle.borderLeftWidth) || 0;
        var borderTop   = parseInt(caStyle.borderTopWidth) || 0;
        var paddingLeft = parseInt(caStyle.paddingLeft) || 0
        var paddingTop  = parseInt(caStyle.paddingTop) || 0
        var additionalX = borderLeft + paddingLeft;
        var additionalY = borderTop + paddingTop;


        if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {





            if (!RG.ISIE && !RG.ISOPERA) {
                x = e.offsetX - borderLeft - paddingLeft;
                y = e.offsetY - borderTop - paddingTop;

            } else if (RG.ISIE) {
                x = e.      offsetX - paddingLeft;
                y = e.offsetY - paddingTop;

            } else {
                x = e.offsetX;
                y = e.offsetY;
            }

        } else {

            if (typeof el.offsetParent !== 'undefined') {
                do {
                    offsetX += el.offsetLeft;
                    offsetY += el.offsetTop;
                } while ((el = el.offsetParent));
            }

            x = e.pageX - offsetX - additionalX;
            y = e.pageY - offsetY - additionalY;

            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));
            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));

            //x += (parseInt(caStyle.borderLeftWidth) || 0);
            //y += (parseInt(caStyle.borderTopWidth) || 0);
        }

        // We return a javascript array with x and y defined
        return [x, y];
    };




    /**
     * This function returns a two element array of the canvas x/y position in
     * relation to the page
     *
     * @param object canvas
     */
    RG.getCanvasXY = function (canvas)
    {
        var x  = 0;
        var y  = 0;
        var el = canvas; // !!!

        do {

            x += el.offsetLeft;
            y += el.offsetTop;

            // ACCOUNT FOR TABLES IN wEBkIT
            if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {
                x += parseInt(el.border) || 0;
                y += parseInt(el.border) || 0;
            }

            el = el.offsetParent;

        } while (el && el.tagName.toLowerCase() != 'body');


        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;
        var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;
        var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;
        var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;

        if (navigator.userAgent.indexOf('Firefox') > 0) {
            x += parseInt(document.body.style.borderLeftWidth) || 0;
            y += parseInt(document.body.style.borderTopWidth) || 0;
        }

        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
    };




    /**
     * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns
     * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).
     *
     * @return Either false or the fixed positioned element
     */
    RG.isFixed = function (canvas)
    {
        var obj = canvas;
        var i = 0;

        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {

            if (obj.style.position == 'fixed') {
                return obj;
            }

            obj = obj.offsetParent;
        }

        return false;
    };




    /**
     * Registers a graph object (used when the canvas is redrawn)
     *
     * @param object obj The object to be registered
     */
    RG.register =
        RG.Register = function (obj)
        {
            // Checking this property ensures the object is only registered once
            if (!obj.Get('chart.noregister')) {
                // As of 21st/1/2012 the object registry is now used
                RGraph.ObjectRegistry.Add(obj);
                obj.Set('chart.noregister', true);
            }
        };




    /**
     * Causes all registered objects to be redrawn
     *
     * @param string An optional color to use to clear the canvas
     */
    RG.redraw =
        RG.Redraw = function ()
        {
            var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;

            // Get all of the canvas tags on the page
            var tags = document.getElementsByTagName('canvas');

            for (var i=0,len=tags.length; i<len; ++i) {
                if (tags[i].__object__ && tags[i].__object__.isRGraph) {

                    // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects
                    if (!tags[i].noclear) {
                        RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);
                    }
                }
            }

            // Go through the object registry and redraw *all* of the canvas'es that have been registered
            for (var i=0,len=objectRegistry.length; i<len; ++i) {
                if (objectRegistry[i]) {
                    var id = objectRegistry[i][0];
                    objectRegistry[i][1].Draw();
                }
            }
        };




    /**
     * Causes all registered objects ON THE GIVEN CANVAS to be redrawn
     *
     * @param canvas object The canvas object to redraw
     * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas
     */
    RG.redrawCanvas =
        RG.RedrawCanvas = function (ca)
        {
            var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);

            /**
             * First clear the canvas
             */
            if (!arguments[1] || (typeof arguments[1] === 'boolean' && !arguments[1] == false) ) {
                var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';
                RG.clear(ca, color);
            }

            /**
             * Now redraw all the charts associated with that canvas
             */
            for (var i=0,len=objects.length; i<len; ++i) {
                if (objects[i]) {
                    if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??
                        objects[i].Draw();
                    }
                }
            }
        };




    /**
     * This function draws the background for the bar chart, line chart and scatter chart.
     *
     * @param  object obj The graph object
     */
    RG.Background.draw =
        RG.background.draw =
            RG.background.Draw = function (obj)
            {
                var ca   = obj.canvas,
                    co   = obj.context,
                    prop = obj.properties,
                    height       = 0,
                    gutterLeft   = obj.gutterLeft,
                    gutterRight  = obj.gutterRight,
                    gutterTop    = obj.gutterTop,
                    gutterBottom = obj.gutterBottom,
                    variant      = prop['chart.variant']


                co.fillStyle = prop['chart.text.color'];

                // If it's a bar and 3D variant, translate
                if (variant == '3d') {
                    co.save();
                    co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);
                }

                // X axis title
                if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {

                    var size = prop['chart.text.size'] + 2;
                    var font = prop['chart.text.font'];
                    var bold = prop['chart.title.xaxis.bold'];

                    if (typeof(prop['chart.title.xaxis.size']) == 'number') {
                        size = prop['chart.title.xaxis.size'];
                    }

                    if (typeof(prop['chart.title.xaxis.font']) == 'string') {
                        font = prop['chart.title.xaxis.font'];
                    }

                    var hpos = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
                    var vpos = ca.height - gutterBottom + 25;

                    if (typeof prop['chart.title.xaxis.pos'] === 'number') {
                        vpos = ca.height - (gutterBottom * prop['chart.title.xaxis.pos']);
                    }




                    // Specifically specified X/Y positions
                    if (typeof prop['chart.title.xaxis.x'] === 'number') {
                        hpos = prop['chart.title.xaxis.x'];
                    }

                    if (typeof prop['chart.title.xaxis.y'] === 'number') {
                        vpos = prop['chart.title.xaxis.y'];
                    }



                    RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {
                        font:font,
                        size:size,
                        x:hpos,
                        y:vpos,
                        text:prop['chart.title.xaxis'],
                        halign:'center',
                        valign:'center',
                        bold:bold,
                        color: prop['chart.title.xaxis.color'] || 'black',
                        tag: 'title xaxis'
                    });
                }

                // Y axis title
                if (typeof(prop['chart.title.yaxis']) == 'string' && prop['chart.title.yaxis'].length) {

                    var size  = prop['chart.text.size'] + 2;
                    var font  = prop['chart.text.font'];
                    var angle = 270;
                    var bold  = prop['chart.title.yaxis.bold'];
                    var color = prop['chart.title.yaxis.color'];

                    if (typeof(prop['chart.title.yaxis.pos']) == 'number') {
                        var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;
                    } else {
                        var yaxis_title_pos = ((gutterLeft - 25) / gutterLeft) * gutterLeft;
                    }

                    if (typeof prop['chart.title.yaxis.size'] === 'number') {
                        size = prop['chart.title.yaxis.size'];
                    }

                    if (typeof prop['chart.title.yaxis.font'] === 'string') {
                        font = prop['chart.title.yaxis.font'];
                    }

                    if (   prop['chart.title.yaxis.align'] == 'right'
                        || prop['chart.title.yaxis.position'] == 'right'
                        || (obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined')
                    ) {

                        angle = 90;
                        yaxis_title_pos = prop['chart.title.yaxis.pos'] ? (ca.width - gutterRight) + (prop['chart.title.yaxis.pos'] * gutterRight) :
                            ca.width - gutterRight + prop['chart.text.size'] + 5;
                    } else {
                        yaxis_title_pos = yaxis_title_pos;
                    }

                    var y = ((ca.height - gutterTop - gutterBottom) / 2) + gutterTop;

                    // Specifically specified X/Y positions
                    if (typeof prop['chart.title.yaxis.x'] === 'number') {
                        yaxis_title_pos = prop['chart.title.yaxis.x'];
                    }

                    if (typeof prop['chart.title.yaxis.y'] === 'number') {
                        y = prop['chart.title.yaxis.y'];
                    }

                    co.fillStyle = color;
                    RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {
                        'font':font,
                        'size':size,
                        'x':yaxis_title_pos,
                        'y':y,
                        'valign':'center',
                        'halign':'center',
                        'angle':angle,
                        'bold':bold,
                        'text':prop['chart.title.yaxis'],
                        'tag':'title yaxis',
                        accessible: false
                    });
                }

                /**
                 * If the background color is spec ified - draw that. It's a rectangle that fills the
                 * entire area within the gutters
                 */
                var bgcolor = prop['chart.background.color'];
                if (bgcolor) {
                    co.fillStyle = bgcolor;
                    co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
                }



















                /**
                 * Draw horizontal background bars
                 */
                var numbars   = (prop['chart.ylabels.count'] || 5);
                var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;

                co.beginPath();
                co.fillStyle   = prop['chart.background.barcolor1'];
                co.strokeStyle = co.fillStyle;
                height = (ca.height - gutterBottom);

                for (var i=0; i<numbars; i+=2) {
                    co.rect(gutterLeft,
                        (i * barHeight) + gutterTop,
                        ca.width - gutterLeft - gutterRight,
                        barHeight
                    );
                }
                co.fill();



                co.beginPath();
                co.fillStyle   = prop['chart.background.barcolor2'];
                co.strokeStyle = co.fillStyle;

                for (var i=1; i<numbars; i+=2) {
                    co.rect(
                        gutterLeft,
                        (i * barHeight) + gutterTop,
                        ca.width - gutterLeft - gutterRight,
                        barHeight
                    );
                }

                co.fill();

                // Close any errantly open path
                co.beginPath();




                //
                // The background grid is cached
                //
                var func = function (obj, cacheCanvas, cacheContext)
                {
                    // Draw the background grid
                    if (prop['chart.background.grid']) {

                        prop['chart.background.grid.autofit.numhlines'] += 0.0001;

                        // If autofit is specified, use the .numhlines and .numvlines along with the width to work
                        // out the hsize and vsize
                        if (prop['chart.background.grid.autofit']) {

                            /**
                             * Align the grid to the tickmarks
                             */
                            if (prop['chart.background.grid.autofit.align']) {

                                // Align the horizontal lines
                                if (obj.type === 'hbar') {
                                    obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                                }

                                // Align the vertical lines for the line
                                if (obj.type === 'line') {
                                    if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {
                                        // Nada
                                    } else if (prop['chart.labels'] && prop['chart.labels'].length) {
                                        obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);
                                    } else {
                                        obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);
                                    }
                                } else if (obj.type === 'waterfall') {
                                    obj.set(
                                        'backgroundGridAutofitNumvlines',
                                        obj.data.length + (prop['chart.total'] ? 1 : 0)
                                    );

                                    // Align the vertical lines for the bar, Scatter
                                } else if ( (
                                        obj.type === 'bar' ||
                                        obj.type === 'scatter'
                                    )

                                    && (
                                        (prop['chart.labels'] && prop['chart.labels'].length)
                                        || obj.type === 'bar'
                                    )
                                ) {

                                    var len = (prop['chart.labels'] && prop['chart.labels'].length) || obj.data.length;


                                    obj.set({
                                        backgroundGridAutofitNumvlines: len
                                    });

                                    // Gantt
                                } else if (obj.type === 'gantt') {

                                    if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {
                                        // Nothing to do here
                                    } else {
                                        obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);
                                    }

                                    obj.set('chart.background.grid.autofit.numhlines', obj.data.length);

                                    // HBar
                                } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines']) ) {
                                    obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                                }
                            }

                            var vsize = ((cacheCanvas.width - gutterLeft - gutterRight)) / prop['chart.background.grid.autofit.numvlines'];
                            var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];

                            obj.Set('chart.background.grid.vsize', vsize);
                            obj.Set('chart.background.grid.hsize', hsize);
                        }

                        co.beginPath();
                        cacheContext.lineWidth   = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;
                        cacheContext.strokeStyle = prop['chart.background.grid.color'];

                        // Dashed background grid
                        if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {
                            cacheContext.setLineDash([3,5]);
                        }

                        // Dotted background grid
                        if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {
                            cacheContext.setLineDash([1,3]);
                        }

                        co.beginPath();


                        // Draw the horizontal lines
                        if (prop['chart.background.grid.hlines']) {
                            height = (cacheCanvas.height - gutterBottom)
                            var hsize = prop['chart.background.grid.hsize'];
                            for (y=gutterTop; y<=height; y+=hsize) {
                                cacheContext.moveTo(gutterLeft, ma.round(y));
                                cacheContext.lineTo(ca.width - gutterRight, ma.round(y));
                            }
                        }

                        if (prop['chart.background.grid.vlines']) {
                            // Draw the vertical lines
                            var width = (cacheCanvas.width - gutterRight);
                            var vsize = prop['chart.background.grid.vsize'];

                            for (x=gutterLeft; ma.round(x)<=width; x+=vsize) {
                                cacheContext.moveTo(ma.round(x), gutterTop);
                                cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);
                            }
                        }

                        if (prop['chart.background.grid.border']) {
                            // Make sure a rectangle, the same colour as the grid goes around the graph
                            cacheContext.strokeStyle = prop['chart.background.grid.color'];
                            cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
                        }
                    }

                    cacheContext.stroke();



                    // Ensure the grids drawn before continuing
                    cacheContext.beginPath();
                    cacheContext.closePath();
                }

                // Now a cached draw in newer browsers
                RG.cachedDraw(obj, obj.uid + '_background', func);







                // If it's a bar and 3D variant, translate
                if (variant == '3d') {
                    co.restore();
                }

                // Reset the line dash
                if (typeof co.setLineDash == 'function') {
                    co.setLineDash([1,0]);
                }

                co.stroke();



                // Draw the title if one is set
                if ( typeof(obj.properties['chart.title']) == 'string') {

                    var prop = obj.properties;

                    RG.drawTitle(
                        obj,
                        prop['chart.title'],
                        obj.gutterTop,
                        null,
                        prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2,
                        obj
                    );
                }
            };




    /**
     * Formats a number with thousand seperators so it's easier to read
     *
     * @param  integer obj The chart object
     * @param  integer num The number to format
     * @param  string      The (optional) string to prepend to the string
     * @param  string      The (optional) string to append to the string
     * @return string      The formatted number
     */
    RG.numberFormat =
        RG.number_format = function (obj, num)
        {
            var ca   = obj.canvas;
            var co   = obj.context;
            var prop = obj.properties;

            var i;
            var prepend = arguments[2] ? String(arguments[2]) : '';
            var append  = arguments[3] ? String(arguments[3]) : '';
            var output  = '';
            var decimal = '';
            var decimal_seperator  = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';
            var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';
            RegExp.$1   = '';
            var i,j;

            if (typeof prop['chart.scale.formatter'] === 'function') {
                return prop['chart.scale.formatter'](obj, num);
            }

            // Ignore the preformatted version of "1e-2"
            if (String(num).indexOf('e') > 0) {
                return String(prepend + String(num) + append);
            }

            // We need then number as a string
            num = String(num);

            // Take off the decimal part - we re-append it later
            if (num.indexOf('.') > 0) {
                var tmp = num;
                num     = num.replace(/\.(.*)/, ''); // The front part of the number
                decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
            }

            // Thousand seperator
            //var seperator = arguments[1] ? String(arguments[1]) : ',';
            var seperator = thousand_seperator;

            /**
             * Work backwards adding the thousand seperators
             */
            var foundPoint;
            for (i=(num.length - 1),j=0; i>=0; j++,i--) {
                var character = num.charAt(i);

                if ( j % 3 == 0 && j != 0) {
                    output += seperator;
                }

                /**
                 * Build the output
                 */
                output += character;
            }

            /**
             * Now need to reverse the string
             */
            var rev = output;
            output = '';
            for (i=(rev.length - 1); i>=0; i--) {
                output += rev.charAt(i);
            }

            // Tidy up
            //output = output.replace(/^-,/, '-');
            if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {
                output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);
            }

            // Reappend the decimal
            if (decimal.length) {
                output =  output + decimal_seperator + decimal;
                decimal = '';
                RegExp.$1 = '';
            }

            // Minor bugette
            if (output.charAt(0) == '-') {
                output = output.replace(/-/, '');
                prepend = '-' + prepend;
            }

            return prepend + output + append;
        };




    /**
     * Draws horizontal coloured bars on something like the bar, line or scatter
     */
    RG.drawBars =
        RG.DrawBars = function (obj)
        {
            var prop  = obj.properties;
            var co    = obj.context;
            var ca    = obj.canvas;
            var hbars = prop['chart.background.hbars'];

            if (hbars === null) {
                return;
            }

            /**
             * Draws a horizontal bar
             */
            co.beginPath();

            for (i=0,len=hbars.length; i<len; ++i) {

                var start  = hbars[i][0];
                var length = hbars[i][1];
                var color  = hbars[i][2];


                // Perform some bounds checking
                if(RG.is_null(start))start = obj.scale2.max
                if (start > obj.scale2.max) start = obj.scale2.max;
                if (RG.is_null(length)) length = obj.scale2.max - start;
                if (start + length > obj.scale2.max) length = obj.scale2.max - start;
                if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;

                if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {
                    length = obj.scale2.max * -2;
                }


                /**
                 * Draw the bar
                 */
                var x = prop['chart.gutter.left'];
                var y = obj.getYCoord(start);
                var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
                var h = obj.getYCoord(start + length) - y;

                // Accommodate Opera :-/
                if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {
                    h *= -1;
                    y = y - h;
                }

                /**
                 * Account for X axis at the top
                 */
                if (prop['chart.xaxispos'] == 'top') {
                    y  = ca.height - y;
                    h *= -1;
                }

                co.fillStyle = color;
                co.fillRect(x, y, w, h);
            }
            /*





             // If the X axis is at the bottom, and a negative max is given, warn the user
             if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {
             alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');
             }

             var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));
             //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;
             var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);

             // Account for the X axis being in the center
             if (obj.Get('chart.xaxispos') == 'center') {
             ystart /= 2;
             //height /= 2;
             }

             ystart += obj.Get('chart.gutter.top')

             var x = obj.Get('chart.gutter.left');
             var y = ystart - height;
             var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');
             var h = height;

             // Accommodate Opera :-/
             if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {
             h *= -1;
             y = y - h;
             }

             /**
             * Account for X axis at the top
             */
            //if (obj.Get('chart.xaxispos') == 'top') {
            //    y  = obj.canvas.height - y;
            //    h *= -1;
            //}

            //obj.context.fillStyle = hbars[i][2];
            //obj.context.fillRect(x, y, w, h);
            //}
        };




    /**
     * Draws in-graph labels.
     *
     * @param object obj The graph object
     */
    RG.drawInGraphLabels =
        RG.DrawInGraphLabels = function (obj)
        {
            var ca      = obj.canvas;
            var co      = obj.context;
            var prop    = obj.properties;
            var labels  = prop['chart.labels.ingraph'];
            var labels_processed = [];

            // Defaults
            var fgcolor   = 'black';
            var bgcolor   = 'white';
            var direction = 1;

            if (!labels) {
                return;
            }

            /**
             * Preprocess the labels array. Numbers are expanded
             */
            for (var i=0,len=labels.length; i<len; i+=1) {
                if (typeof labels[i] === 'number') {
                    for (var j=0; j<labels[i]; ++j) {
                        labels_processed.push(null);
                    }
                } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {
                    labels_processed.push(labels[i]);

                } else {
                    labels_processed.push('');
                }
            }

            /**
             * Turn off any shadow
             */
            RG.noShadow(obj);

            if (labels_processed && labels_processed.length > 0) {

                for (var i=0,len=labels_processed.length; i<len; i+=1) {
                    if (labels_processed[i]) {
                        var coords = obj.coords[i];

                        if (coords && coords.length > 0) {
                            var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);
                            var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);
                            var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;

                            co.beginPath();
                            co.fillStyle   = 'black';
                            co.strokeStyle = 'black';


                            if (obj.type === 'bar') {

                                /**
                                 * X axis at the top
                                 */
                                if (obj.Get('chart.xaxispos') == 'top') {
                                    length *= -1;
                                }

                                if (prop['chart.variant'] == 'dot') {
                                    co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                    co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);

                                    var text_x = ma.round(x);
                                    var text_y = obj.coords[i][1] - 5 - length;

                                } else if (prop['chart.variant'] == 'arrow') {
                                    co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                    co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);

                                    var text_x = ma.round(x);
                                    var text_y = obj.coords[i][1] - 5 - length;

                                } else {

                                    co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);
                                    co.moveTo(ma.round(x), y);
                                    co.lineTo(ma.round(x), y - length);

                                    var text_x = ma.round(x);
                                    var text_y = y - length;
                                }

                                co.stroke();
                                co.fill();


                            } else {

                                if (
                                    typeof labels_processed[i] == 'object' &&
                                    typeof labels_processed[i][3] == 'number' &&
                                    labels_processed[i][3] == -1
                                ) {

                                    co.moveTo(ma.round(x), y + 5);
                                    co.lineTo(ma.round(x), y + 5 + length);

                                    co.stroke();
                                    co.beginPath();

                                    // This draws the arrow
                                    co.moveTo(ma.round(x), y + 5);
                                    co.lineTo(ma.round(x) - 3, y + 10);
                                    co.lineTo(ma.round(x) + 3, y + 10);
                                    co.closePath();

                                    var text_x = x;
                                    var text_y = y + 5 + length;

                                } else {

                                    var text_x = x;
                                    var text_y = y - 5 - length;

                                    co.moveTo(ma.round(x), y - 5);
                                    co.lineTo(ma.round(x), y - 5 - length);

                                    co.stroke();
                                    co.beginPath();

                                    // This draws the arrow
                                    co.moveTo(ma.round(x), y - 5);
                                    co.lineTo(ma.round(x) - 3, y - 10);
                                    co.lineTo(ma.round(x) + 3, y - 10);
                                    co.closePath();
                                }

                                co.fill();
                            }

                            // Taken out on the 10th Nov 2010 - unnecessary
                            //var width = context.measureText(labels[i]).width;

                            co.beginPath();

                            // Fore ground color
                            co.fillStyle = (typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string') ? labels_processed[i][1] : 'black';

                            RG.text2(obj,{
                                'font':prop['chart.text.font'],
                                'size':prop['chart.text.size'],
                                'x':text_x,
                                'y':text_y + (obj.properties['chart.text.accessible'] ? 2 : 0),
                                'text': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string') ? labels_processed[i][0] : labels_processed[i],
                                'valign': 'bottom',
                                'halign':'center',
                                'bounding':true,
                                'bounding.fill': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string') ? labels_processed[i][2] : 'white',
                                'tag':'labels ingraph'
                            });
                            co.fill();
                        }
                    }
                }
            }
        };




    /**
     * This function "fills in" key missing properties that various implementations lack
     *
     * @param object e The event object
     */
    RG.fixEventObject =
        RG.FixEventObject = function (e)
        {
            if (RG.ISOLD) {
                var e = event;

                e.pageX  = (event.clientX + doc.body.scrollLeft);
                e.pageY  = (event.clientY + doc.body.scrollTop);
                e.target = event.srcElement;

                if (!doc.body.scrollTop && doc.documentElement.scrollTop) {
                    e.pageX += parseInt(doc.documentElement.scrollLeft);
                    e.pageY += parseInt(doc.documentElement.scrollTop);
                }
            }


            // Any browser that doesn't implement stopPropagation() (MSIE)
            if (!e.stopPropagation) {
                e.stopPropagation = function () {window.event.cancelBubble = true;}
            }

            return e;
        };




    /**
     * Thisz function hides the crosshairs coordinates
     */
    RG.hideCrosshairCoords =
        RG.HideCrosshairCoords = function ()
        {
            var div = RG.Registry.Get('chart.coordinates.coords.div');

            if (   div
                && div.style.opacity == 1
                && div.__object__.Get('chart.crosshairs.coords.fadeout')
            ) {

                var style = RG.Registry.Get('chart.coordinates.coords.div').style;

                setTimeout(function() {style.opacity = 0.9;}, 25);
                setTimeout(function() {style.opacity = 0.8;}, 50);
                setTimeout(function() {style.opacity = 0.7;}, 75);
                setTimeout(function() {style.opacity = 0.6;}, 100);
                setTimeout(function() {style.opacity = 0.5;}, 125);
                setTimeout(function() {style.opacity = 0.4;}, 150);
                setTimeout(function() {style.opacity = 0.3;}, 175);
                setTimeout(function() {style.opacity = 0.2;}, 200);
                setTimeout(function() {style.opacity = 0.1;}, 225);
                setTimeout(function() {style.opacity = 0;}, 250);
                setTimeout(function() {style.display = 'none';}, 275);
            }
        };




    /**
     * Draws the3D axes/background
     *
     * @param object obj The chart object
     */
    RG.draw3DAxes =
        RG.Draw3DAxes = function (obj)
        {
            var prop = obj.properties,
                co   = obj.context,
                ca   = obj.canvas;

            var gutterLeft    = obj.gutterLeft,
                gutterRight   = obj.gutterRight,
                gutterTop     = obj.gutterTop,
                gutterBottom  = obj.gutterBottom,
                xaxispos      = prop['chart.xaxispos'],
                graphArea     = ca.height - gutterTop - gutterBottom,
                halfGraphArea = graphArea / 2,
                offsetx       = prop['chart.variant.threed.offsetx'],
                offsety       = prop['chart.variant.threed.offsety'],
                xaxis         = prop['chart.variant.threed.xaxis'],
                yaxis         = prop['chart.variant.threed.yaxis']


            //
            // Draw the 3D Y axis
            //
            if (yaxis) {
                RG.draw3DYAxis(obj);
            }



            // X axis
            if (xaxis) {
                if (xaxispos === 'center') {
                    RG.path2(
                        co,
                        'b m % % l % % l % % l % % c s #aaa f #ddd',
                        gutterLeft,gutterTop + halfGraphArea,
                        gutterLeft + offsetx,gutterTop + halfGraphArea - offsety,
                        ca.width - gutterRight + offsetx,gutterTop + halfGraphArea - offsety,
                        ca.width - gutterRight,gutterTop + halfGraphArea
                    );

                } else {

                    if (obj.type === 'hbar') {
                        var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];
                    } else {
                        var xaxisYCoord = obj.getYCoord(0);
                    }

                    RG.path2(
                        co,
                        'm % % l % % l % % l % % c s #aaa f #ddd',
                        gutterLeft,xaxisYCoord,
                        gutterLeft + offsetx,xaxisYCoord - offsety,
                        ca.width - gutterRight + offsetx,xaxisYCoord - offsety,
                        ca.width - gutterRight,xaxisYCoord
                    );
                }
            }
        };




    /**
     * Draws the3D Y axis/background
     *
     * @param object obj The chart object
     */
    RG.draw3DYAxis = function (obj)
    {
        var prop = obj.properties,
            co   = obj.context,
            ca   = obj.canvas;

        var gutterLeft    = obj.gutterLeft,
            gutterRight   = obj.gutterRight,
            gutterTop     = obj.gutterTop,
            gutterBottom  = obj.gutterBottom,
            xaxispos      = prop['chart.xaxispos'],
            graphArea     = ca.height - gutterTop - gutterBottom,
            halfGraphArea = graphArea / 2,
            offsetx       = prop['chart.variant.threed.offsetx'],
            offsety       = prop['chart.variant.threed.offsety']



        // Y axis
        // Commented out the if condition because of drawing oddities
        //if (!prop['chart.noaxes'] && !prop['chart.noyaxis']) {

        if ( (obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {
            var x = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
        } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {
            var x = ca.width - gutterRight;
        } else {
            var x = gutterLeft;
        }

        RG.path2(
            co,
            'b m % % l % % l % % l % % s #aaa f #ddd',
            x,gutterTop,
            x + offsetx,gutterTop - offsety,
            x + offsetx,ca.height - gutterBottom - offsety,
            x,ca.height - gutterBottom
        );
        //}
    };




    /**
     * Draws a rectangle with curvy corners
     *
     * @param co object The context
     * @param x number The X coordinate (top left of the square)
     * @param y number The Y coordinate (top left of the square)
     * @param w number The width of the rectangle
     * @param h number The height of the rectangle
     * @param   number The radius of the curved corners
     * @param   boolean Whether the top left corner is curvy
     * @param   boolean Whether the top right corner is curvy
     * @param   boolean Whether the bottom right corner is curvy
     * @param   boolean Whether the bottom left corner is curvy
     */
    RG.strokedCurvyRect = function (co, x, y, w, h)
    {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

        co.beginPath();

        // Top left side
        co.moveTo(x + (corner_tl ? r : 0), y);
        co.lineTo(x + w - (corner_tr ? r : 0), y);

        // Top right corner
        if (corner_tr) {
            co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);
        }

        // Top right side
        co.lineTo(x + w, y + h - (corner_br ? r : 0) );

        // Bottom right corner
        if (corner_br) {
            co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);
        }

        // Bottom right side
        co.lineTo(x + (corner_bl ? r : 0), y + h);

        // Bottom left corner
        if (corner_bl) {
            co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
        }

        // Bottom left side
        co.lineTo(x, y + (corner_tl ? r : 0) );

        // Top left corner
        if (corner_tl) {
            co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
        }

        co.stroke();
    };




    /**
     * Draws a filled rectangle with curvy corners
     *
     * @param context object The context
     * @param x       number The X coordinate (top left of the square)
     * @param y       number The Y coordinate (top left of the square)
     * @param w       number The width of the rectangle
     * @param h       number The height of the rectangle
     * @param         number The radius of the curved corners
     * @param         boolean Whether the top left corner is curvy
     * @param         boolean Whether the top right corner is curvy
     * @param         boolean Whether the bottom right corner is curvy
     * @param         boolean Whether the bottom left corner is curvy
     */
    RG.filledCurvyRect = function (co, x, y, w, h)
    {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

        co.beginPath();

        // First draw the corners

        // Top left corner
        if (corner_tl) {
            co.moveTo(x + r, y + r);
            co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
        } else {
            co.fillRect(x, y, r, r);
        }

        // Top right corner
        if (corner_tr) {
            co.moveTo(x + w - r, y + r);
            co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);
        } else {
            co.moveTo(x + w - r, y);
            co.fillRect(x + w - r, y, r, r);
        }


        // Bottom right corner
        if (corner_br) {
            co.moveTo(x + w - r, y + h - r);
            co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);
        } else {
            co.moveTo(x + w - r, y + h - r);
            co.fillRect(x + w - r, y + h - r, r, r);
        }

        // Bottom left corner
        if (corner_bl) {
            co.moveTo(x + r, y + h - r);
            co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
        } else {
            co.moveTo(x, y + h - r);
            co.fillRect(x, y + h - r, r, r);
        }

        // Now fill it in
        co.fillRect(x + r, y, w - r - r, h);
        co.fillRect(x, y + r, r + 1, h - r - r);
        co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);

        co.fill();
    };




    /**
     * Hides the zoomed canvas
     */
    RG.hideZoomedCanvas =
        RG.HideZoomedCanvas = function ()
        {
            var interval = 10;
            var frames   = 15;

            if (typeof RG.zoom_image === 'object') {
                var obj  = RG.zoom_image.obj;
                var prop = obj.properties;
            } else {
                return;
            }

            if (prop['chart.zoom.fade.out']) {
                for (var i=frames,j=1; i>=0; --i, ++j) {
                    if (typeof RG.zoom_image === 'object') {
                        setTimeout("RGraph.zoom_image.style.opacity = " + String(i / 10), j * interval);
                    }
                }

                if (typeof RG.zoom_background === 'object') {
                    setTimeout("RGraph.zoom_background.style.opacity = " + String(i / frames), j * interval);
                }
            }

            if (typeof RG.zoom_image === 'object') {
                setTimeout("RGraph.zoom_image.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
            }

            if (typeof RG.zoom_background === 'object') {
                setTimeout("RGraph.zoom_background.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
            }
        };




    /**
     * Adds an event handler
     *
     * @param object obj   The graph object
     * @param string event The name of the event, eg ontooltip
     * @param object func  The callback function
     */
    RG.addCustomEventListener =
        RG.AddCustomEventListener = function (obj, name, func)
        {
            // Initialise the events array if necessary
            if (typeof RG.events[obj.uid] === 'undefined') {
                RG.events[obj.uid] = [];
            }

            // Prepend "on" if necessary
            if (name.substr(0, 2) !== 'on') {
                name = 'on' + name;
            }

            RG.events[obj.uid].push([obj, name, func]);

            return RG.events[obj.uid].length - 1;
        };




    /**
     * Used to fire one of the RGraph custom events
     *
     * @param object obj   The graph object that fires the event
     * @param string event The name of the event to fire
     */
    RG.fireCustomEvent =
        RG.FireCustomEvent = function (obj, name)
        {
            if (obj && obj.isRGraph) {

                // This allows the eventsMouseout property to work
                // (for some reason...)
                if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {
                    (obj.properties['chart.events.mouseout'])(obj);
                }

                // DOM1 style of adding custom events
                if (obj[name]) {
                    (obj[name])(obj);
                }

                var uid = obj.uid;

                if (   typeof uid === 'string'
                    && typeof RG.events === 'object'
                    && typeof RG.events[uid] === 'object'
                    && RG.events[uid].length > 0) {

                    for(var j=0; j<RG.events[uid].length; ++j) {
                        if (RG.events[uid][j] && RG.events[uid][j][1] === name) {
                            RG.events[uid][j][2](obj);
                        }
                    }
                }
            }
        };




    /**
     * Clears all the custom event listeners that have been registered
     *
     * @param    string Limits the clearing to this object ID
     */
    RGraph.removeAllCustomEventListeners =
        RGraph.RemoveAllCustomEventListeners = function ()
        {
            var id = arguments[0];

            if (id && RG.events[id]) {
                RG.events[id] = [];
            } else {
                RG.events = [];
            }
        };




    /**
     * Clears a particular custom event listener
     *
     * @param object obj The graph object
     * @param number i   This is the index that is return by .AddCustomEventListener()
     */
    RG.removeCustomEventListener =
        RG.RemoveCustomEventListener = function (obj, i)
        {
            if (   typeof RG.events === 'object'
                && typeof RG.events[obj.id] === 'object'
                && typeof RG.events[obj.id][i] === 'object') {

                RG.events[obj.id][i] = null;
            }
        };




    /**
     * This draws the background
     *
     * @param object obj The graph object
     */
    RG.drawBackgroundImage =
        RG.DrawBackgroundImage = function (obj)
        {
            var prop = obj.properties;
            var ca   = obj.canvas;
            var co   = obj.context;

            if (typeof prop['chart.background.image'] === 'string') {
                if (typeof ca.__rgraph_background_image__ === 'undefined') {
                    var img = new Image();
                    img.__object__  = obj;
                    img.__canvas__  = ca;
                    img.__context__ = co;
                    img.src         = obj.Get('chart.background.image');

                    ca.__rgraph_background_image__ = img;
                } else {
                    img = ca.__rgraph_background_image__;
                }

                // When the image has loaded - redraw the canvas
                img.onload = function ()
                {
                    obj.__rgraph_background_image_loaded__ = true;
                    RG.clear(ca);
                    RG.redrawCanvas(ca);
                }

                var gutterLeft   = obj.gutterLeft;
                var gutterRight  = obj.gutterRight;
                var gutterTop    = obj.gutterTop;
                var gutterBottom = obj.gutterBottom;
                var stretch      = prop['chart.background.image.stretch'];
                var align        = prop['chart.background.image.align'];

                // Handle chart.background.image.align
                if (typeof align === 'string') {
                    if (align.indexOf('right') != -1) {
                        var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;
                    } else {
                        var x = gutterLeft;
                    }

                    if (align.indexOf('bottom') != -1) {
                        var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;
                    } else {
                        var y = gutterTop;
                    }
                } else {
                    var x = gutterLeft || 25;
                    var y = gutterTop || 25;
                }

                // X/Y coords take precedence over the align
                var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;
                var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;
                var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;
                var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;

                /**
                 * You can now specify the width and height of the image
                 */
                if (typeof prop['chart.background.image.w'] === 'number') w  = prop['chart.background.image.w'];
                if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];

                var oldAlpha = co.globalAlpha;
                co.globalAlpha = prop['chart.background.image.alpha'];
                co.drawImage(img,x,y,w, h);
                co.globalAlpha = oldAlpha;
            }
        };




    /**
     * This function determines wshether an object has tooltips or not
     *
     * @param object obj The chart object
     */
    RG.hasTooltips = function (obj)
    {
        var prop = obj.properties;

        if (typeof prop['chart.tooltips'] == 'object' && prop['chart.tooltips']) {
            for (var i=0,len=prop['chart.tooltips'].length; i<len; ++i) {
                if (!RG.is_null(obj.Get('chart.tooltips')[i])) {
                    return true;
                }
            }
        } else if (typeof prop['chart.tooltips'] === 'function') {
            return true;
        }

        return false;
    };




    /**
     * This function creates a (G)UID which can be used to identify objects.
     *
     * @return string (g)uid The (G)UID
     */
    RG.createUID =
        RG.CreateUID = function ()
        {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)
            {
                var r = ma.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
                return v.toString(16);
            });
        };



    /**
     * This is the new object registry, used to facilitate multiple objects per canvas.
     *
     * @param object obj The object to register
     */
    RG.OR.add =
        RG.OR.Add = function (obj)
        {
            var uid = obj.uid;
            var id  = obj.canvas.id;

            /**
             * Index the objects by UID
             */
            RG.ObjectRegistry.objects.byUID.push([uid, obj]);

            /**
             * Index the objects by the canvas that they're drawn on
             */
            RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);
        };




    /**
     * Remove an object from the object registry
     *
     * @param object obj The object to remove.
     */
    RG.OR.remove =
        RG.OR.Remove = function (obj)
        {
            var id  = obj.id;
            var uid = obj.uid;

            for (var i=0; i<RG.ObjectRegistry.objects.byUID.length; ++i) {
                if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {
                    RG.ObjectRegistry.objects.byUID[i] = null;
                }
            }


            for (var i=0; i<RG.ObjectRegistry.objects.byCanvasID.length; ++i) {
                if (   RG.ObjectRegistry.objects.byCanvasID[i]
                    && RG.ObjectRegistry.objects.byCanvasID[i][1]
                    && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {

                    RG.ObjectRegistry.objects.byCanvasID[i] = null;
                }
            }
        };




    /**
     * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,
     * or the canvas itself, then only objects pertaining to that canvas are cleared.
     *
     * @param mixed   Either a canvas object (as returned by document.getElementById()
     *                or the ID of a canvas (ie a string)
     */
    RG.OR.clear =
        RG.OR.Clear = function ()
        {
            // If an ID is supplied restrict the learing to that
            if (arguments[0]) {
                var id      = (typeof arguments[0] === 'object' ? arguments[0].id : arguments[0]);
                var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);

                for (var i=0,len=objects.length; i<len; ++i) {
                    RG.ObjectRegistry.remove(objects[i]);
                }

            } else {

                RG.ObjectRegistry.objects            = {};
                RG.ObjectRegistry.objects.byUID      = [];
                RG.ObjectRegistry.objects.byCanvasID = [];
            }
        };




    /**
     * Lists all objects in the ObjectRegistry
     *
     * @param boolean ret Whether to return the list or alert() it
     */
    RG.OR.list =
        RG.OR.List = function ()
        {
            var list = [];

            for (var i=0,len=RG.ObjectRegistry.objects.byUID.length; i<len; ++i) {
                if (RG.ObjectRegistry.objects.byUID[i]) {
                    list.push(RG.ObjectRegistry.objects.byUID[i][1].type);
                }
            }

            if (arguments[0]) {
                return list;
            } else {
                $p(list);
            }
        };




    /**
     * Clears the ObjectRegistry of objects that are of a certain given type
     *
     * @param type string The type to clear
     */
    RG.OR.clearByType =
        RG.OR.ClearByType = function (type)
        {
            var objects = RG.ObjectRegistry.objects.byUID;

            for (var i=0,len=objects.length; i<len; ++i) {
                if (objects[i]) {
                    var uid = objects[i][0];
                    var obj = objects[i][1];

                    if (obj && obj.type == type) {
                        RG.ObjectRegistry.remove(obj);
                    }
                }
            }
        };




    /**
     * This function provides an easy way to go through all of the objects that are held in the
     * Registry
     *
     * @param func function This function is run for every object. Its passed the object as an argument
     * @param string type Optionally, you can pass a type of object to look for
     */
    RG.OR.iterate =
        RG.OR.Iterate = function (func)
        {
            var objects = RGraph.ObjectRegistry.objects.byUID;

            for (var i=0,len=objects.length; i<len; ++i) {

                if (typeof arguments[1] === 'string') {

                    var types = arguments[1].split(/,/);

                    for (var j=0,len2=types.length; j<len2; ++j) {
                        if (types[j] == objects[i][1].type) {
                            func(objects[i][1]);
                        }
                    }
                } else {
                    func(objects[i][1]);
                }
            }
        };




    /**
     * Retrieves all objects for a given canvas id
     *
     * @patarm id string The canvas ID to get objects for.
     */
    RG.OR.getObjectsByCanvasID = function (id)
    {
        var store = RG.ObjectRegistry.objects.byCanvasID;
        var ret = [];

        // Loop through all of the objects and return the appropriate ones
        for (var i=0,len=store.length; i<len; ++i) {
            if (store[i] && store[i][0] == id ) {
                ret.push(store[i][1]);
            }
        }

        return ret;
    };




    /**
     * Retrieves the relevant object based on the X/Y position.
     *
     * @param  object e The event object
     * @return object   The applicable (if any) object
     */
    RG.OR.firstbyxy =
        RG.OR.getFirstObjectByXY =
            RG.OR.getObjectByXY = function (e)
            {
                var canvas  = e.target;
                var ret     = null;
                var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

                for (var i=(objects.length - 1); i>=0; --i) {

                    var obj = objects[i].getObjectByXY(e);

                    if (obj) {
                        return obj;
                    }
                }
            };




    /**
     * Retrieves the relevant objects based on the X/Y position.
     * NOTE This function returns an array of objects
     *
     * @param  object e The event object
     * @return          An array of pertinent objects. Note the there may be only one object
     */
    RG.OR.getObjectsByXY = function (e)
    {
        var canvas  = e.target;
        var ret     = [];
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

        // Retrieve objects "front to back"
        for (var i=(objects.length - 1); i>=0; --i) {

            var obj = objects[i].getObjectByXY(e);

            if (obj) {
                ret.push(obj);
            }
        }

        return ret;
    };




    /**
     * Retrieves the object with the corresponding UID
     *
     * @param string uid The UID to get the relevant object for
     */
    RG.OR.get =
        RG.OR.getObjectByUID = function (uid)
        {
            var objects = RG.ObjectRegistry.objects.byUID;

            for (var i=0,len=objects.length; i<len; ++i) {
                if (objects[i] && objects[i][1].uid == uid) {
                    return objects[i][1];
                }
            }
        };




    /**
     * Brings a chart to the front of the ObjectRegistry by
     * removing it and then readding it at the end and then
     * redrawing the canvas
     *
     * @param object  obj    The object to bring to the front
     * @param boolean redraw Whether to redraw the canvas after the
     *                       object has been moved
     */
    RG.OR.bringToFront = function (obj)
    {
        var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];

        RG.ObjectRegistry.remove(obj);
        RG.ObjectRegistry.add(obj);

        if (redraw) {
            RG.redrawCanvas(obj.canvas);
        }
    };




    /**
     * Retrieves the objects that are the given type
     *
     * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID
     * @param  string type   The type to look for
     * @return array         An array of one or more objects
     */
    RG.OR.type =
        RG.OR.getObjectsByType = function (type)
        {
            var objects = RG.ObjectRegistry.objects.byUID;
            var ret     = [];

            for (var i=0,len=objects.length; i<len; ++i) {

                if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {
                    ret.push(objects[i][1]);
                }
            }

            return ret;
        };




    /**
     * Retrieves the FIRST object that matches the given type
     *
     * @param  string type   The type of object to look for
     * @return object        The FIRST object that matches the given type
     */
    RG.OR.first =
        RG.OR.getFirstObjectByType = function (type)
        {
            var objects = RG.ObjectRegistry.objects.byUID;

            for (var i=0,len=objects.length; i<len; ++i) {
                if (objects[i] && objects[i][1] && objects[i][1].type == type) {
                    return objects[i][1];
                }
            }

            return null;
        };




    /**
     * This takes centerx, centery, x and y coordinates and returns the
     * appropriate angle relative to the canvas angle system. Remember
     * that the canvas angle system starts at the EAST axis
     *
     * @param  number cx  The centerx coordinate
     * @param  number cy  The centery coordinate
     * @param  number x   The X coordinate (eg the mouseX if coming from a click)
     * @param  number y   The Y coordinate (eg the mouseY if coming from a click)
     * @return number     The relevant angle (measured in in RADIANS)
     */
    RG.getAngleByXY = function (cx, cy, x, y)
    {
        var angle = ma.atan((y - cy) / (x - cx));
        angle = ma.abs(angle)

        if (x >= cx && y >= cy) {
            angle += RG.TWOPI;

        } else if (x >= cx && y < cy) {
            angle = (RG.HALFPI - angle) + (RG.PI + RG.HALFPI);

        } else if (x < cx && y < cy) {
            angle += RG.PI;

        } else {
            angle = RG.PI - angle;
        }

        /**
         * Upper and lower limit checking
         */
        if (angle > RG.TWOPI) {
            angle -= RG.TWOPI;
        }

        return angle;
    };




    /**
     * This function returns the distance between two points. In effect the
     * radius of an imaginary circle that is centered on x1 and y1. The name
     * of this function is derived from the word "Hypoteneuse", which in
     * trigonmetry is the longest side of a triangle
     *
     * @param number x1 The original X coordinate
     * @param number y1 The original Y coordinate
     * @param number x2 The target X coordinate
     * @param number y2 The target Y  coordinate
     */
    RG.getHypLength = function (x1, y1, x2, y2)
    {
        var ret = ma.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

        return ret;
    };




    /**
     * This function gets the end point (X/Y coordinates) of a given radius.
     * You pass it the center X/Y and the radius and this function will return
     * the endpoint X/Y coordinates.
     *
     * @param number cx The center X coord
     * @param number cy The center Y coord
     * @param number r  The lrngth of the radius
     */
    RG.getRadiusEndPoint = function (cx, cy, angle, radius)
    {
        var x = cx + (ma.cos(angle) * radius);
        var y = cy + (ma.sin(angle) * radius);

        return [x, y];
    };




    /**
     * This installs all of the event listeners
     *
     * @param object obj The chart object
     */
    RG.installEventListeners =
        RG.InstallEventListeners = function (obj)
        {
            var prop = obj.properties;

            /**
             * Don't attempt to install event listeners for older versions of MSIE
             */
            if (RG.ISOLD) {
                return;
            }

            /**
             * If this function exists, then the dynamic file has been included.
             */
            if (RG.installCanvasClickListener) {

                RG.installWindowMousedownListener(obj);
                RG.installWindowMouseupListener(obj);
                RG.installCanvasMousemoveListener(obj);
                RG.installCanvasMouseupListener(obj);
                RG.installCanvasMousedownListener(obj);
                RG.installCanvasClickListener(obj);

            } else if (   RG.hasTooltips(obj)
                || prop['chart.adjustable']
                || prop['chart.annotatable']
                || prop['chart.contextmenu']
                || prop['chart.resizable']
                || prop['chart.key.interactive']
                || prop['chart.events.click']
                || prop['chart.events.mousemove']
                || typeof obj.onclick === 'function'
                || typeof obj.onmousemove === 'function'
            ) {

                alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');
            }
        };




    /**
     * Loosly mimicks the PHP function print_r();
     */
    RG.pr = function (obj)
    {
        var indent = (arguments[2] ? arguments[2] : '    ');
        var str    = '';

        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;

        if (counter >= 5) {
            return '';
        }

        switch (typeof obj) {

            case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;
            case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;
            case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;
            case 'function':  str += 'function () {}'; break;
            case 'undefined': str += 'undefined'; break;
            case 'null':      str += 'null'; break;

            case 'object':
                // In case of null
                if (RGraph.is_null(obj)) {
                    str += indent + 'null\n';
                } else {
                    str += indent + 'Object {' + '\n'
                    for (j in obj) {
                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\n';
                    }
                    str += indent + '}';
                }
                break;


            default:
                str += 'Unknown type: ' + typeof obj + '';
                break;
        }


        /**
         * Finished, now either return if we're in a recursed call, or alert()
         * if we're not.
         */
        if (!arguments[1]) {
            alert(str);
        }

        return str;
    };




    /**
     * Produces a dashed line
     *
     * @param object co The 2D context
     * @param number x1 The start X coordinate
     * @param number y1 The start Y coordinate
     * @param number x2 The end X coordinate
     * @param number y2 The end Y coordinate
     */
    RG.dashedLine =
        RG.DashedLine = function(co, x1, y1, x2, y2)
        {
            /**
             * This is the size of the dashes
             */
            var size = 5;

            /**
             * The optional fifth argument can be the size of the dashes
             */
            if (typeof arguments[5] === 'number') {
                size = arguments[5];
            }

            var dx  = x2 - x1;
            var dy  = y2 - y1;
            var num = ma.floor(ma.sqrt((dx * dx) + (dy * dy)) / size);

            var xLen = dx / num;
            var yLen = dy / num;

            var count = 0;

            do {
                (count % 2 == 0 && count > 0) ? co.lineTo(x1, y1) : co.moveTo(x1, y1);

                x1 += xLen;
                y1 += yLen;
            } while(count++ <= num);
        };




    /**
     * Makes an AJAX call. It calls the given callback (a function) when ready
     *
     * @param string   url      The URL to retrieve
     * @param function callback A function that is called when the response is ready, there's an example below
     *                          called "myCallback".
     */
    RG.AJAX = function (url, callback)
    {
        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

            // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }

        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;

                this.__user_callback__(this.responseText);
            }
        }

        httpRequest.open('GET', url, true);
        httpRequest.send();
    };




    /**
     * Makes an AJAX POST request. It calls the given callback (a function) when ready
     *
     * @param string   url      The URL to retrieve
     * @param object   data     The POST data
     * @param function callback A function that is called when the response is ready, there's an example below
     *                          called "myCallback".
     */
    RG.AJAX.POST = function (url, data, callback)
    {
        // Used when building the POST string
        var crumbs = [];






        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

            // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }





        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;
                this.__user_callback__(this.responseText);
            }
        }

        httpRequest.open('POST', url, true);
        httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");

        for (i in data) {
            if (typeof i == 'string') {
                crumbs.push(i + '=' + encodeURIComponent(data[i]));
            }
        }

        httpRequest.send(crumbs.join('&'));
    };




    /**
     * Uses the above function but calls the call back passing a number as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the number as an argument)
     */
    RG.AJAX.getNumber = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var num = parseFloat(this.responseText);

            callback(num);
        });
    };




    /**
     * Uses the above function but calls the call back passing a string as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the string as an argument)
     */
    RG.AJAX.getString = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var str = String(this.responseText);

            callback(str);
        });
    };




    /**
     * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the JSON object as an argument)
     */
    RG.AJAX.getJSON = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var json = eval('(' + this.responseText + ')');

            callback(json);
        });
    };




    /**
     * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
     * Useful if you're retrieving CSV data
     *
     * @param url string The URL to fetch
     * @param callback function Your callback function (which is passed the CSV/array as an argument)
     */
    RG.AJAX.getCSV = function (url, callback)
    {
        var seperator = arguments[2] ? arguments[2] : ',';

        RG.AJAX(url, function ()
        {
            var regexp = new RegExp(seperator);
            var arr = this.responseText.split(regexp);

            // Convert the strings to numbers
            for (var i=0,len=arr.length;i<len;++i) {
                arr[i] = parseFloat(arr[i]);
            }

            callback(arr);
        });
    };




    /**
     * Rotates the canvas
     *
     * @param object canvas The canvas to rotate
     * @param  int   x      The X coordinate about which to rotate the canvas
     * @param  int   y      The Y coordinate about which to rotate the canvas
     * @param  int   angle  The angle(in RADIANS) to rotate the canvas by
     */
    RG.rotateCanvas =
        RG.RotateCanvas = function (ca, x, y, angle)
        {
            var co = ca.getContext('2d');

            co.translate(x, y);
            co.rotate(angle);
            co.translate(0 - x, 0 - y);
        };




    /**
     * Measures text by creating a DIV in the document and adding the relevant text to it.
     * Then checking the .offsetWidth and .offsetHeight.
     *
     * @param  string text   The text to measure
     * @param  bool   bold   Whether the text is bold or not
     * @param  string font   The font to use
     * @param  size   number The size of the text (in pts)
     * @return array         A two element array of the width and height of the text
     */
    RG.measureText =
        RG.MeasureText = function (text, bold, font, size)
        {
            // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
            if (typeof RG.measuretext_cache === 'undefined') {
                RG.measuretext_cache = [];
            }

            var str = text + ':' + bold + ':' + font + ':' + size;
            if (typeof RG.measuretext_cache == 'object' && RG.measuretext_cache[str]) {
                return RG.measuretext_cache[str];
            }

            if (!RG.measuretext_cache['text-div']) {
                var div = document.createElement('DIV');
                div.style.position = 'absolute';
                div.style.top = '-100px';
                div.style.left = '-100px';
                document.body.appendChild(div);

                // Now store the newly created DIV
                RG.measuretext_cache['text-div'] = div;

            } else if (RG.measuretext_cache['text-div']) {
                var div = RG.measuretext_cache['text-div'];
            }

            div.innerHTML        = text.replace(/\r\n/g, '<br />');
            div.style.fontFamily = font;
            div.style.fontWeight = bold ? 'bold' : 'normal';
            div.style.fontSize   = (size || 12) + 'pt';

            var size = [div.offsetWidth, div.offsetHeight];

            //document.body.removeChild(div);
            RG.measuretext_cache[str] = size;

            return size;
        };




    /* New text function. Accepts two arguments:
     *  o obj - The chart object
     *  o opt - An object/hash/map of properties. This can consist of:
     *          x                The X coordinate (REQUIRED)
     *          y                The Y coordinate (REQUIRED)
     *          text             The text to show (REQUIRED)
     *          font             The font to use
     *          size             The size of the text (in pt)
     *          italic           Whether the text should be italic or not
     *          bold             Whether the text shouldd be bold or not
     *          marker           Whether to show a marker that indicates the X/Y coordinates
     *          valign           The vertical alignment
     *          halign           The horizontal alignment
     *          bounding         Whether to draw a bounding box for the text
     *          boundingStroke   The strokeStyle of the bounding box
     *          boundingFill     The fillStyle of the bounding box
     *          accessible       If false this will cause the text to be
     *                           rendered as native canvas text. DOM text otherwise
     */
    RG.text2 =
        RG.Text2 = function (obj, opt)
        {
            /**
             * Use DOM nodes to get better quality text. This option is BETA quality
             * code and most likely and will not work if you use 3D or if you use
             * your own transformations.
             */
            function domtext ()
            {
                /**
                 * Check the font property to see if it contains the italic keyword,
                 * and if it does then take it out and set the italic property
                 */
                if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {
                    opt.size = opt.size.replace(/ *italic +/, '');
                    opt.italic = true;
                }



                // Used for caching the DOM node
                var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;



                // Wrap the canvas in a DIV
                if (!ca.rgraph_domtext_wrapper) {
                    var wrapper = document.createElement('div');
                    wrapper.id        = ca.id + '_rgraph_domtext_wrapper';
                    wrapper.className = 'rgraph_domtext_wrapper';

                    // The wrapper can be configured to hide or show the
                    // overflow with the textAccessibleOverflow option
                    wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';

                    wrapper.style.width    = ca.offsetWidth + 'px';
                    wrapper.style.height   = ca.offsetHeight + 'px';

                    wrapper.style.cssFloat = ca.style.cssFloat;
                    wrapper.style.display  = ca.style.display || 'inline-block';
                    wrapper.style.position = ca.style.position || 'relative';
                    wrapper.style.left     = ca.style.left;
                    wrapper.style.top      = ca.style.top;
                    wrapper.style.width    = ca.width + 'px';
                    wrapper.style.height   = ca.height + 'px';

                    ca.style.position      = 'absolute';
                    ca.style.left          = 0;
                    ca.style.top           = 0;
                    ca.style.display       = 'inline';
                    ca.style.cssFloat      = 'none';


                    if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {
                        wrapper.style.transform = 'skewY(5.7deg)';
                    }

                    ca.parentNode.insertBefore(wrapper, ca);

                    // Remove the canvas from the DOM and put it in the wrapper
                    ca.parentNode.removeChild(ca);
                    wrapper.appendChild(ca);

                    ca.rgraph_domtext_wrapper = wrapper;

                    // TODO Add a subwrapper here

                } else {
                    wrapper = ca.rgraph_domtext_wrapper;
                }


                var defaults = {
                    size: 12,
                    font: 'Arial',
                    italic: 'normal',
                    bold: 'normal',
                    valign: 'bottom',
                    halign: 'left',
                    marker: true,
                    color: co.fillStyle,
                    bounding: {
                        enabled: false,
                        fill: 'rgba(255,255,255,0.7)',
                        stroke: '#666'
                    }
                }

                // Transform \n to the string [[RETURN]] which is then replaced
                // further down
                opt.text = String(opt.text).replace(/\r?\n/g, '[[RETURN]]');


                // Create the node cache array that nodes
                // already created are stored in
                if (typeof RG.text2.domNodeCache === 'undefined') {
                    RG.text2.domNodeCache = new Array();
                }

                if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {
                    RG.text2.domNodeCache[obj.id] = new Array();
                }

                // Create the dimension cache array that node
                // dimensions are stored in
                if (typeof RG.text2.domNodeDimensionCache === 'undefined') {
                    RG.text2.domNodeDimensionCache = new Array();
                }

                if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {
                    RG.text2.domNodeDimensionCache[obj.id] = new Array();
                }



                // Create the DOM node
                if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {

                    var span = document.createElement('span');
                    span.style.position   = 'absolute';
                    span.style.display    = 'inline';

                    span.style.left       = (opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width))) + 'px';
                    span.style.top        = (opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)))  + 'px';
                    span.style.color      = opt.color || defaults.color;
                    span.style.fontFamily = opt.font || defaults.font;
                    span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;
                    span.style.fontStyle  = opt.italic ? 'italic' : defaults.italic;
                    span.style.fontSize   = (opt.size || defaults.size) + 'pt';
                    span.style.whiteSpace = 'nowrap';
                    span.tag              = opt.tag;


                    // CSS angled text. This should be conasidered BETA quality code at the moment,
                    // but it seems to be OK. You may need to use the labelsOffsety when using this
                    // option.
                    if (typeof opt.angle === 'number' && opt.angle !== 0) {

                        var coords = RG.measureText(
                            opt.text,
                            opt.bold,
                            opt.font,
                            opt.size
                        );

                        //span.style.left = parseFloat(span.style.left) - coords[0] + 'px';
                        span.style.transformOrigin = '100% 50%';
                        span.style.transform       = 'rotate(' + opt.angle + 'deg)';
                    }




                    // Shadow
                    span.style.textShadow = '{1}px {2}px {3}px {4}'.format(
                        co.shadowOffsetX,
                        co.shadowOffsetY,
                        co.shadowBlur,
                        co.shadowColor
                    );


                    if (opt.bounding) {
                        span.style.border          = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);
                        span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;
                    }
                    // Pointer events
                    if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' ||
                        obj.properties['chart.text.accessible.pointerevents']) &&
                        obj.properties['chart.text.accessible.pointerevents'] !== 'none') {

                        span.style.pointerEvents =  'auto';
                    } else {
                        span.style.pointerEvents =  'none';
                    }

                    span.style.padding = opt.bounding ? '2px' : null;
                    span.__text__      = opt.text
                    span.innerHTML     = opt.text.replace('&', '&amp;')
                        .replace('<', '&lt;')
                        .replace('>', '&gt;');

                    // Now replace the string [[RETURN]] with a <br />
                    span.innerHTML = span.innerHTML.replace(/\[\[RETURN\]\]/g, '<br />');

                    wrapper.appendChild(span);

                    // Alignment defaults
                    opt.halign = opt.halign || 'left';
                    opt.valign = opt.valign || 'bottom';

                    // Horizontal alignment
                    if (opt.halign === 'right') {
                        span.style.left      = parseFloat(span.style.left) - span.offsetWidth + 'px';
                        span.style.textAlign = 'right';
                    } else if (opt.halign === 'center') {
                        span.style.left      = parseFloat(span.style.left) - (span.offsetWidth  / 2) + 'px';
                        span.style.textAlign = 'center';
                    }

                    // Vertical alignment
                    if (opt.valign === 'top') {
                        // Nothing to do here
                    } else if (opt.valign === 'center') {
                        span.style.top = parseFloat(span.style.top) - (span.offsetHeight / 2) + 'px';
                    } else {
                        span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';
                    }


                    var offsetWidth  = parseFloat(span.offsetWidth),
                        offsetHeight = parseFloat(span.offsetHeight),
                        top          = parseFloat(span.style.top),
                        left         = parseFloat(span.style.left);

                    RG.text2.domNodeCache[obj.id][cacheKey] = span;
                    RG.text2.domNodeDimensionCache[obj.id][cacheKey] = {
                        left: left,
                        top: top,
                        width: offsetWidth,
                        height: offsetHeight
                    };
                    span.id = cacheKey;



                } else {
                    span = RG.text2.domNodeCache[obj.id][cacheKey];
                    span.style.display = 'inline';

                    var offsetWidth  = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,
                        offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,
                        top          = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,
                        left         = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;
                }






                // If requested, draw a marker to indicate the coords
                if (opt.marker) {
                    RG.path2(context, 'b m % % l % % m % % l % % s',
                        opt.x - 5, opt.y,
                        opt.x + 5, opt.y,
                        opt.x, opt.y - 5,
                        opt.x, opt.y + 5
                    );
                }

                /**
                 * If its a drawing API text object then allow
                 * for events and tooltips
                 */
                if (obj.type === 'drawing.text') {
                    // Mousemove
                    if (obj.properties['chart.events.mousemove']) {
                        span.addEventListener('mousemove', function (e) {(obj.properties['chart.events.mousemove'])(e, obj);}, false);
                    }

                    // Click
                    if (obj.properties['chart.events.click']) {
                        span.addEventListener('click', function (e) {(obj.properties['chart.events.click'])(e, obj);}, false);
                    }

                    // Tooltips
                    if (obj.properties['chart.tooltips']) {
                        span.addEventListener(
                            obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click',
                            function (e)
                            {
                                if (   !RG.Registry.get('chart.tooltip')
                                    || RG.Registry.get('chart.tooltip').__index__ !== 0
                                    || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid
                                ) {

                                    RG.hideTooltip();
                                    RG.redraw();
                                    RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);
                                }
                            },
                            false
                        );
                    }
                }

                // Build the return value
                var ret    = {};
                ret.x      = left;
                ret.y      = top;
                ret.width  = offsetWidth;
                ret.height = offsetHeight;
                ret.object = obj;
                ret.text   = opt.text;
                ret.tag    = opt.tag;


                // The reset() function clears the domNodeCache
                ////
                // @param object OPTIONAL You can pass in the canvas to limit the
                //                        clearing to that canvas.
                RG.text2.domNodeCache.reset = function ()
                {
                    // Limit the clearing to a single canvas tag
                    if (arguments[0]) {

                        var nodes = RG.text2.domNodeCache[arguments[0].id];
                        for (j in nodes) {
                            var node = RG.text2.domNodeCache[arguments[0].id][j];

                            if (node && node.parentNode) {
                                node.parentNode.removeChild(node);
                            }
                        }

                        // Clear all DOM text from all tags
                    } else {
                        for (i in RG.text2.domNodeCache) {
                            for (j in RG.text2.domNodeCache[i]) {
                                if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {
                                    RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);
                                }
                            }
                        }
                    }
                };



                //
                // Helps you get hold of the SPAN tag nodes that hold the text on the chart
                //
                RG.text2.find = function (opt)
                {
                    var span, nodes = [];
                    var id = typeof opt.id === 'string' ? opt.id : opt.object.id;
                    for (i in RG.text2.domNodeCache[id]) {

                        span = RG.text2.domNodeCache[id][i];

                        // A full tag is given
                        if (typeof opt.tag === 'string' && opt.tag === span.tag) {
                            nodes.push(span);
                            continue;
                        }



                        // A regex is given as the tag
                        if (typeof opt.tag === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {

                            var regexp = new RegExp(opt.tag);

                            if (regexp.test(span.tag)) {
                                nodes.push(span);
                                continue;
                            }
                        }



                        // A full text is given
                        if (typeof opt.text === 'string' && opt.text === span.__text__) {
                            nodes.push(span);
                            continue;
                        }



                        // Regex for the text is given
                        // A regex is given as the tag
                        if (typeof opt.text === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {

                            var regexp = new RegExp(opt.text);

                            if (regexp.test(span.__text__)) {
                                nodes.push(span);

                                continue;
                            }
                        }
                    }

                    return nodes;
                };




                //
                // Add the SPAN tag to the return value
                //
                ret.node = span;


                /**
                 * Save and then return the details of the text (but oly
                 * if it's an RGraph object that was given)
                 */
                if (obj && obj.isRGraph && obj.coordsText) {
                    obj.coordsText.push(ret);
                }


                return ret;
            }



            /**
             * An RGraph object can be given, or a string or the 2D rendering context
             * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function
             * still returns the cooords though in all cases.
             */
            if (obj && obj.isRGraph) {
                var obj = obj;
                var co  = obj.context;
                var ca  = obj.canvas;
            } else if (typeof obj == 'string') {
                var ca  = document.getElementById(obj);
                var co  = ca.getContext('2d');
                var obj = ca.__object__;
            } else if (typeof obj.getContext === 'function') {
                var ca = obj;
                var co = ca.getContext('2d');
                var obj = ca.__object__;
            } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {
                var co  = obj;
                var ca  = obj.canvas;
                var obj = ca.__object__;

                // IE7/8
            } else if (RG.ISOLD && obj.fillText) {
                var co  = obj;
                var ca  = obj.canvas;
                var obj = ca.__object__;
            }


            /**
             * Changed the name of boundingFill/boundingStroke - this allows you to still use those names
             */
            if (typeof opt.boundingFill === 'string')   opt['bounding.fill']   = opt.boundingFill;
            if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;



            if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {
                return domtext();
            }




            var x              = opt.x,
                y              = opt.y,
                originalX      = x,
                originalY      = y,
                text           = opt.text,
                text_multiline = typeof text === 'string' ? text.split(/\r?\n/g) : '',
                numlines       = text_multiline.length,
                font           = opt.font ? opt.font : 'Arial',
                size           = opt.size ? opt.size : 10,
                size_pixels    = size * 1.5,
                bold           = opt.bold,
                italic         = opt.italic,
                halign         = opt.halign ? opt.halign : 'left',
                valign         = opt.valign ? opt.valign : 'bottom',
                tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',
                marker         = opt.marker,
                angle          = opt.angle || 0


























            var bounding                = opt.bounding,
                bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',
                bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',
                bounding_shadow         = opt['bounding.shadow'],
                bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc',
                bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3,
                bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,
                bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,
                bounding_linewidth      = opt['bounding.linewidth'] || 1;



            /**
             * Initialize the return value to an empty object
             */
            var ret = {};

            //
            // Color
            //
            if (typeof opt.color === 'string') {
                var orig_fillstyle = co.fillStyle;
                co.fillStyle = opt.color;
            }



            /**
             * The text arg must be a string or a number
             */
            if (typeof text == 'number') {
                text = String(text);
            }

            if (typeof text !== 'string') {
                return;
            }



            /**
             * This facilitates vertical text
             */
            if (angle != 0) {
                co.save();
                co.translate(x, y);
                co.rotate((ma.PI / 180) * angle)
                x = 0;
                y = 0;
            }



            /**
             * Set the font
             */
            co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;



            /**
             * Measure the width/height. This must be done AFTER the font has been set
             */
            var width=0;
            for (var i=0; i<numlines; ++i) {
                width = ma.max(width, co.measureText(text_multiline[i]).width);
            }
            var height = size_pixels * numlines;




            /**
             * Accommodate old MSIE 7/8
             */
            //if (document.all && RGraph.ISOLD) {
            //y += 2;
            //}


            /**
             * If marker is specified draw a marker at the X/Y coordinates
             */
            if (opt.marker) {
                var marker_size = 10;
                var strokestyle = co.strokeStyle;
                co.beginPath();
                co.strokeStyle = 'red';
                co.moveTo(x, y - marker_size);
                co.lineTo(x, y + marker_size);
                co.moveTo(x - marker_size, y);
                co.lineTo(x + marker_size, y);
                co.stroke();
                co.strokeStyle = strokestyle;
            }



            /**
             * Set the horizontal alignment
             */
            if (halign == 'center') {
                co.textAlign = 'center';
                var boundingX = x - 2 - (width / 2);
            } else if (halign == 'right') {
                co.textAlign = 'right';
                var boundingX = x - 2 - width;
            } else {
                co.textAlign = 'left';
                var boundingX = x - 2;
            }


            /**
             * Set the vertical alignment
             */
            if (valign == 'center') {

                co.textBaseline = 'middle';
                // Move the text slightly
                y -= 1;

                y -= ((numlines - 1) / 2) * size_pixels;
                var boundingY = y - (size_pixels / 2) - 2;

            } else if (valign == 'top') {
                co.textBaseline = 'top';

                var boundingY = y - 2;

            } else {

                co.textBaseline = 'bottom';

                // Move the Y coord if multiline text
                if (numlines > 1) {
                    y -= ((numlines - 1) * size_pixels);
                }

                var boundingY = y - size_pixels - 2;
            }

            var boundingW = width + 4;
            var boundingH = height + 4;



            /**
             * Draw a bounding box if required
             */
            if (bounding) {

                var pre_bounding_linewidth     = co.lineWidth;
                var pre_bounding_strokestyle   = co.strokeStyle;
                var pre_bounding_fillstyle     = co.fillStyle;
                var pre_bounding_shadowcolor   = co.shadowColor;
                var pre_bounding_shadowblur    = co.shadowBlur;
                var pre_bounding_shadowoffsetx = co.shadowOffsetX;
                var pre_bounding_shadowoffsety = co.shadowOffsetY;

                co.lineWidth   = bounding_linewidth;
                co.strokeStyle = bounding_stroke;
                co.fillStyle   = bounding_fill;

                if (bounding_shadow) {
                    co.shadowColor   = bounding_shadow_color;
                    co.shadowBlur    = bounding_shadow_blur;
                    co.shadowOffsetX = bounding_shadow_offsetx;
                    co.shadowOffsetY = bounding_shadow_offsety;
                }

                //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
                //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
                co.strokeRect(boundingX, boundingY, boundingW, boundingH);
                co.fillRect(boundingX, boundingY, boundingW, boundingH);

                // Reset the linewidth,colors and shadow to it's original setting
                co.lineWidth     = pre_bounding_linewidth;
                co.strokeStyle   = pre_bounding_strokestyle;
                co.fillStyle     = pre_bounding_fillstyle;
                co.shadowColor   = pre_bounding_shadowcolor
                co.shadowBlur    = pre_bounding_shadowblur
                co.shadowOffsetX = pre_bounding_shadowoffsetx
                co.shadowOffsetY = pre_bounding_shadowoffsety
            }



            /**
             * Draw the text
             */
            if (numlines > 1) {
                for (var i=0; i<numlines; ++i) {
                    co.fillText(text_multiline[i], x, y + (size_pixels * i));
                }
            } else {
                co.fillText(text, x + 0.5, y + 0.5);
            }



            /**
             * If the text is at 90 degrees restore() the canvas - getting rid of the rotation
             * and the translate that we did
             */
            if (angle != 0) {
                if (angle == 90) {
                    if (halign == 'left') {
                        if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}

                    } else if (halign == 'center') {
                        if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}

                    } else if (halign == 'right') {
                        if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                    }

                } else if (angle == 180) {

                    if (halign == 'left') {
                        if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}

                    } else if (halign == 'center') {
                        if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}

                    } else if (halign == 'right') {
                        if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                        if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
                    }

                } else if (angle == 270) {

                    if (halign == 'left') {
                        if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}

                    } else if (halign == 'center') {
                        if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}

                    } else if (halign == 'right') {
                        if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                        if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                    }
                }

                co.restore();
            }




            /**
             * Reset the text alignment so that text rendered after this text function is not affected
             */
            co.textBaseline = 'alphabetic';
            co.textAlign    = 'left';





            /**
             * Fill the ret variable with details of the text
             */
            ret.x      = boundingX;
            ret.y      = boundingY;
            ret.width  = boundingW;
            ret.height = boundingH
            ret.object = obj;
            ret.text   = text;
            ret.tag    = tag;



            /**
             * Save and then return the details of the text (but oly
             * if it's an RGraph object that was given)
             */
            if (obj && obj.isRGraph && obj.coordsText) {
                obj.coordsText.push(ret);
            }

            //
            // Restore the original fillstyle
            //
            if (typeof orig_fillstyle === 'string') {
                co.fillStyle = orig_fillstyle;
            }

            return ret;
        };




    /**
     * Takes a sequential index abd returns the group/index variation of it. Eg if you have a
     * sequential index from a grouped bar chart this function can be used to convert that into
     * an appropriate group/index combination
     *
     * @param nindex number The sequential index
     * @param data   array  The original data (which is grouped)
     * @return              The group/index information
     */
    RG.sequentialIndexToGrouped = function (index, data)
    {
        var group         = 0;
        var grouped_index = 0;

        while (--index >= 0) {

            if (RG.is_null(data[group])) {
                group++;
                grouped_index = 0;
                continue;
            }

            // Allow for numbers as well as arrays in the dataset
            if (typeof data[group] == 'number') {
                group++
                grouped_index = 0;
                continue;
            }


            grouped_index++;

            if (grouped_index >= data[group].length) {
                group++;
                grouped_index = 0;
            }
        }

        return [group, grouped_index];
    };




    /**
     * This function highlights a rectangle
     *
     * @param object obj    The chart object
     * @param number shape  The coordinates of the rect to highlight
     */
    RG.Highlight.rect =
        RG.Highlight.Rect = function (obj, shape)
        {
            var ca   = obj.canvas;
            var co   = obj.context;
            var prop = obj.properties;

            if (prop['chart.tooltips.highlight']) {


                // Safari seems to need this
                co.lineWidth = 1;

                /**
                 * Draw a rectangle on the canvas to highlight the appropriate area
                 */
                co.beginPath();

                co.strokeStyle = prop['chart.highlight.stroke'];
                co.fillStyle   = prop['chart.highlight.fill'];

                co.rect(shape['x'],shape['y'],shape['width'],shape['height']);
                //co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);
                co.stroke();
                co.fill();
            }
        };




    /**
     * This function highlights a point
     *
     * @param object obj    The chart object
     * @param number shape  The coordinates of the rect to highlight
     */
    RG.Highlight.point =
        RG.Highlight.Point = function (obj, shape)
        {
            var prop = obj.properties;
            var ca   = obj.canvas;
            var co   = obj.context;

            if (prop['chart.tooltips.highlight']) {

                /**
                 * Draw a rectangle on the canvas to highlight the appropriate area
                 */
                co.beginPath();
                co.strokeStyle = prop['chart.highlight.stroke'];
                co.fillStyle   = prop['chart.highlight.fill'];
                var radius   = prop['chart.highlight.point.radius'] || 2;
                co.arc(shape['x'],shape['y'],radius, 0, RG.TWOPI, 0);
                co.stroke();
                co.fill();
            }
        };




    /**
     * This is the same as Date.parse - though a little more flexible.
     *
     * @param string str The date string to parse
     * @return Returns the same thing as Date.parse
     */
    RG.parseDate = function (str)
    {

        str = RG.trim(str);

        // Allow for: now (just the word "now")
        if (str === 'now') {
            str = (new Date()).toString();
        }


        // Allow for: 22-11-2013
        // Allow for: 22/11/2013
        // Allow for: 22-11-2013 12:09:09
        // Allow for: 22/11/2013 12:09:09
        if (str.match(/^(\d\d)(?:-|\/)(\d\d)(?:-|\/)(\d\d\d\d)(.*)$/)) {
            str = '{1}/{2}/{3}{4}'.format(
                RegExp.$3,
                RegExp.$2,
                RegExp.$1,
                RegExp.$4
            );
        }

        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12
        if (str.match(/^(\d\d\d\d)(-|\/)(\d\d)(-|\/)(\d\d)( |T)(\d\d):(\d\d):(\d\d)$/)) {
            str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;
        }

        // Allow for: 2013-11-22
        if (str.match(/^\d\d\d\d-\d\d-\d\d$/)) {
            str = str.replace(/-/g, '/');
        }


        // Allow for: 12:09:44 (time only using todays date)
        if (str.match(/^\d\d:\d\d:\d\d$/)) {

            var dateObj  = new Date();
            var date     = dateObj.getDate();
            var month    = dateObj.getMonth() + 1;
            var year     = dateObj.getFullYear();

            // Pad the date/month with a zero if it's not two characters
            if (String(month).length === 1) month = '0' + month;
            if (String(date).length === 1) date = '0' + date;

            str = (year + '/' + month + '/' + date) + ' ' + str;
        }

        return Date.parse(str);
    };




    /**
     * Reset all of the color values to their original values
     *
     * @param object
     */
    RG.resetColorsToOriginalValues = function (obj)
    {
        if (obj.original_colors) {
            // Reset the colors to their original values
            for (var j in obj.original_colors) {
                if (typeof j === 'string' && j.substr(0,6) === 'chart.') {
                    obj.properties[j] = RG.arrayClone(obj.original_colors[j]);
                }
            }
        }



        /**
         * If the function is present on the object to reset specific colors - use that
         */
        if (typeof obj.resetColorsToOriginalValues === 'function') {
            obj.resetColorsToOriginalValues();
        }



        // Reset the colorsParsed flag so that they're parsed for gradients again
        obj.colorsParsed = false;
    };




    /**
     * Creates a Linear gradient
     *
     * @param object obj The chart object
     * @param number x1 The start X coordinate
     * @param number x2 The end X coordinate
     * @param number y1 The start Y coordinate
     * @param number y2 The end Y coordinate
     * @param string color1 The start color
     * @param string color2 The end color
     */
    RG.linearGradient =
        RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2)
        {
            var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);
            var numColors=arguments.length-5;

            for (var i=5; i<arguments.length; ++i) {

                var color = arguments[i];
                var stop = (i - 5) / (numColors - 1);

                gradient.addColorStop(stop, color);
            }

            return gradient;
        };




    /**
     * Creates a Radial gradient
     *
     * @param object obj The chart object
     * @param number x1 The start X coordinate
     * @param number x2 The end X coordinate
     * @param number y1 The start Y coordinate
     * @param number y2 The end Y coordinate
     * @param string color1 The start color
     * @param string color2 The end color
     */
    RG.radialGradient =
        RG.RadialGradient = function(obj, x1, y1, r1, x2, y2, r2, color1, color2)
        {
            var gradient  = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);
            var numColors = arguments.length-7;

            for(var i=7; i<arguments.length; ++i) {

                var color = arguments[i];
                var stop  = (i-7) / (numColors-1);

                gradient.addColorStop(stop, color);
            }

            return gradient;
        };




    /**
     * Adds an event listener to RGraphs internal array so that RGraph can track them.
     * This DOESN'T add the event listener to the canvas/window.
     *
     * 5/1/14 TODO Used in the tooltips file, but is it necessary any more?
     */
    RG.addEventListener =
        RG.AddEventListener = function (id, e, func)
        {
            var type = arguments[3] ? arguments[3] : 'unknown';

            RG.Registry.get('chart.event.handlers').push([id,e,func,type]);
        };




    /**
     * Clears event listeners that have been installed by RGraph
     *
     * @param string id The ID of the canvas to clear event listeners for - or 'window' to clear
     *                  the event listeners attached to the window
     */
    RG.clearEventListeners =
        RG.ClearEventListeners = function(id)
        {
            if (id && id == 'window') {

                window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);
                window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);

            } else {

                var canvas = document.getElementById(id);

                canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);
                canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);
                canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);
                canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);
            }
        };




    /**
     * Hides the annotating palette. It's here because it can be called
     * from code other than the annotating code.
     */
    RG.hidePalette =
        RG.HidePalette = function ()
        {
            var div = RG.Registry.get('palette');

            if(typeof div == 'object' && div) {

                div.style.visibility = 'hidden';
                div.style.display = 'none';

                RG.Registry.set('palette', null);
            }
        };




    /**
     * Generates a random number between the minimum and maximum
     *
     * @param number min The minimum value
     * @param number max The maximum value
     * @param number     OPTIONAL Number of decimal places
     */
    RG.random = function (min, max)
    {
        var dp = arguments[2] ? arguments[2] : 0;
        var r  = ma.random();

        return Number((((max - min) * r) + min).toFixed(dp));
    };




    /**
     *
     */
    RG.arrayRand =
        RG.arrayRandom =
            RG.random.array = function (num, min, max)
            {
                for(var i=0,arr=[]; i<num; i+=1) {
                    arr.push(RG.random(min,max, arguments[3]));
                }

                return arr;
            };




    /**
     * Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.
     *
     * @param object obj The chart object
     */
    RG.noShadow =
        RG.NoShadow = function (obj)
        {
            var co = obj.context;

            co.shadowColor   = 'rgba(0,0,0,0)';
            co.shadowBlur    = 0;
            co.shadowOffsetX = 0;
            co.shadowOffsetY = 0;
        };




    /**
     * Sets the various shadow properties
     *
     * @param object obj     The chart object
     * @param string color   The color of the shadow
     * @param number offsetx The offsetX value for the shadow
     * @param number offsety The offsetY value for the shadow
     * @param number blur    The blurring value for the shadow
     */
    RG.setShadow =
        RG.SetShadow = function (obj, color, offsetx, offsety, blur)
        {
            var co = obj.context;

            co.shadowColor   = color;
            co.shadowOffsetX = offsetx;
            co.shadowOffsetY = offsety;
            co.shadowBlur    = blur;

        };




    /**
     * Sets an object in the RGraph registry
     *
     * @param string name The name of the value to set
     */
    RG.Registry.set =
        RG.Registry.Set = function (name, value)
        {
            // Convert uppercase letters to dot+lower case letter
            name = name.replace(/([A-Z])/g, function (str)
            {
                return '.' + String(RegExp.$1).toLowerCase();
            });

            // Ensure there is the chart. prefix
            if (name.substr(0,6) !== 'chart.') {
                name = 'chart.' + name;
            }

            RG.Registry.store[name] = value;

            return value;
        };




    /**
     * Gets an object from the RGraph registry
     *
     * @param string name The name of the value to fetch
     */
    RG.Registry.get =
        RG.Registry.Get = function (name)
        {
            // Convert uppercase letters to dot+lower case letter
            name = name.replace(/([A-Z])/g, function (str)
            {
                return '.' + String(RegExp.$1).toLowerCase();
            });

            // Ensure there is the chart. prefix
            if (name.substr(0,6) !== 'chart.') {
                name = 'chart.' + name;
            }


            return RG.Registry.store[name];
        };




    /**
     * Converts the given number of degrees to radians. Angles in canvas are measured in radians
     *
     * @param number deg The value to convert
     */
    RG.degrees2Radians = function (deg)
    {
        return deg * (RG.PI / 180);
    };




    /**
     * Generates logs for... ...log charts
     *
     * @param number n    The number to generate the log for
     * @param number base The base to use
     */
    RG.log = function (n,base)
    {
        return ma.log(n) / (base ? ma.log(base) : 1);
    };




    /**
     * Determines if the given object is an array or not
     *
     * @param mixed obj The variable to test
     */
    RG.isArray =
        RG.is_array = function (obj)
        {
            if (obj && obj.constructor) {
                var pos = obj.constructor.toString().indexOf('Array');
            } else {
                return false;
            }

            return obj != null &&
                typeof pos === 'number' &&
                pos > 0 &&
                pos < 20;
        };




    /**
     * Removes white-space from the start aqnd end of a string
     *
     * @param string str The string to trim
     */
    RG.trim = function (str)
    {
        return RG.ltrim(RG.rtrim(str));
    };




    /**
     * Trims the white-space from the start of a string
     *
     * @param string str The string to trim
     */
    RG.ltrim = function (str)
    {
        return str.replace(/^(\s|\0)+/, '');
    };




    /**
     * Trims the white-space off of the end of a string
     *
     * @param string str The string to trim
     */
    RG.rtrim = function (str)
    {
        return str.replace(/(\s|\0)+$/, '');
    };



    /**
     * Returns true/false as to whether the given variable is null or not
     *
     * @param mixed arg The argument to check
     */
    RG.isNull =
        RG.is_null = function (arg)
        {
            // must BE DOUBLE EQUALS - NOT TRIPLE
            if (arg == null || typeof arg === 'object' && !arg) {
                return true;
            }

            return false;
        };




    /**
     * This function facilitates a very limited way of making your charts
     * whilst letting the rest of page continue - using  the setTimeout function
     *
     * @param function func The function to run that creates the chart
     */
    RG.async =
        RG.Async = function (func)
        {
            return setTimeout(func, arguments[1] ? arguments[1] : 1);
        };




    /**
     * Resets (more than just clears) the canvas and clears any pertinent objects
     * from the ObjectRegistry
     *
     * @param object ca The canvas object (as returned by document.getElementById() ).
     */
    RG.reset =
        RG.Reset = function (ca)
        {
            ca.width = ca.width;

            RG.ObjectRegistry.clear(ca);

            ca.__rgraph_aa_translated__ = false;

            if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {
                RG.text2.domNodeCache.reset(ca);
            }

            // Create the node and dimension caches if they don't already exist
            if (!RG.text2.domNodeCache)          { RG.text2.domNodeCache          = []; }
            if (!RG.text2.domNodeDimensionCache) { RG.text2.domNodeDimensionCache = []; }

            // Create/reset the specific canvas arrays in the caches
            RG.text2.domNodeCache[ca.id]          = [];
            RG.text2.domNodeDimensionCache[ca.id] = [];
        };




    /**
     * NOT USED ANY MORE
     */
    RG.att = function (ca){}



    /**
     * This function is due to be removed.
     *
     * @param string id The ID of what can be either the canvas tag or a DIV tag
     */
    RG.getCanvasTag = function (id)
    {
        id = typeof id === 'object' ? id.id : id;
        var canvas = doc.getElementById(id);

        return [id, canvas];
    };




    /**
     * A wrapper function that encapsulate requestAnimationFrame
     *
     * @param function func The animation function
     */
    RG.Effects.updateCanvas =
        RG.Effects.UpdateCanvas = function (func)
        {
            win.requestAnimationFrame =    win.requestAnimationFrame
                || win.webkitRequestAnimationFrame
                || win.msRequestAnimationFrame
                || win.mozRequestAnimationFrame
                || (function (func){setTimeout(func, 16.666);});

            win.requestAnimationFrame(func);
        };




    /**
     * This function returns an easing multiplier for effects so they eas out towards the
     * end of the effect.
     *
     * @param number frames The total number of frames
     * @param number frame  The frame number
     */
    RG.Effects.getEasingMultiplier = function (frames, frame)
    {
        return ma.pow(ma.sin((frame / frames) * RG.HALFPI), 3);
    };




    /**
     * This function converts an array of strings to an array of numbers. Its used by the meter/gauge
     * style charts so that if you want you can pass in a string. It supports various formats:
     *
     * '45.2'
     * '-45.2'
     * ['45.2']
     * ['-45.2']
     * '45.2,45.2,45.2' // A CSV style string
     *
     * @param number frames The string or array to parse
     */
    RG.stringsToNumbers = function (str)
    {
        // An optional seperator to use intead of a comma
        var sep = arguments[1] || ',';


        // If it's already a number just return it
        if (typeof str === 'number') {
            return str;
        }





        if (typeof str === 'string') {
            if (str.indexOf(sep) != -1) {
                str = str.split(sep);
            } else {
                str = parseFloat(str);
            }
        }





        if (typeof str === 'object') {
            for (var i=0,len=str.length; i<len; i+=1) {
                str[i] = parseFloat(str[i]);
            }
        }

        return str;
    };




    /**
     * Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it
     * and then subsequent calls use that  instead of repeatedly drawing the same thing.
     *
     * @param object   obj  The graph object
     * @param string   id   An ID string used to identify the relevant entry in the cache
     * @param function func The drawing function. This will be called to do the draw.
     */
    RG.cachedDraw = function (obj, id, func)
    {
        //If the cache entry exists - just copy it across to the main canvas
        if (!RG.cache[id]) {

            RG.cache[id] = {};

            RG.cache[id].object = obj;
            RG.cache[id].canvas = document.createElement('canvas');

            RG.cache[id].canvas.setAttribute('width', obj.canvas.width);
            RG.cache[id].canvas.setAttribute('height', obj.canvas.height);
            RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);

            RG.cache[id].canvas.__object__ = obj;
            RG.cache[id].context = RG.cache[id].canvas.getContext('2d');

            // Antialiasing on the cache canvas
            RG.cache[id].context.translate(0.5,0.5);

            // Call the function
            func(obj, RG.cache[id].canvas, RG.cache[id].context);
        }

        // Now copy the contents of the cached canvas over to the main one.
        // The coordinates are -0.5 because of the anti-aliasing effect in
        // use on the main canvas
        obj.context.drawImage(RG.cache[id].canvas,-0.5,-0.5);
    };




    /**
     * The function that runs through the supplied configuration and
     * converts it to the RGraph stylee.
     *
     * @param object conf The config
     * @param object      The settings for the object
     */
    RG.parseObjectStyleConfig = function (obj, config)
    {
        /**
         * The recursion function
         */
        var recurse = function (obj, config, name, settings)
        {
            var i;

            for (key in config) {

                // Allow for functions in the configuration. Run them immediately
                if (key.match(/^exec[0-9]*$/)) {
                    (config[key])(obj, settings);
                    continue;
                }

                var isObject = false; // Default value
                var isArray  = false; // Default value
                var value    = config[key];

                // Change caps to dots. Eg textSize => text.size
                while(key.match(/([A-Z])/)) {
                    key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
                }

                if (!RG.isNull(value) && value.constructor) {
                    isObject = value.constructor.toString().indexOf('Object') > 0;
                    isArray  = value.constructor.toString().indexOf('Array') > 0;
                }

                if (isObject && !isArray) {
                    recurse(obj, config[key], name + '.' + key, settings);

                } else if (key === 'self') {
                    settings[name] = value;

                } else {
                    settings[name + '.' + key] = value;
                }
            }

            return settings;
        };




        /**
         * Go through the settings that we've been given
         */
        var settings = recurse(obj, config, 'chart', {});

        /**
         * Go through the settings and set them on the object
         */
        for (key in settings) {
            if (typeof key === 'string') {
                obj.set(key, settings[key]);
            }
        }
    };




    /**
     * This function is a short-cut for the canvas path syntax (which can be rather
     * verbose). You can read a description of it (which details all of the
     * various options) on the RGraph blog (www.rgraph.net/blog). The function is
     * added to the CanvasRenderingContext2D object so it becomes a context function.
     *
     * So you can use it like these examples show:
     *
     * 1. RG.path2(context, 'b r 0 0 50 50 f red');
     * 2. RG.path2(context, 'b a 50 50 50 0 3.14 false f red');
     * 3. RG.path2(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');
     * 4. RG.path2(context, 'b m 5 100 at 50 0 95 100 50 s red');
     * 5. RG.path2(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');
     * 6. RG.path2(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');
     * 7. RG.path2(context, 'ga 0.25 b r 5 5 590 240 f red');
     *
     * @param   array p  The path details
     */
    RG.path2 = function (co, p)
    {
        // Save this functions arguments
        var args = arguments;


        // If the path was a string - split it then collapse quoted bits together
        if (typeof p === 'string') {
            p = splitstring(p);
        }

        // Store the last path on the RGraph object
        RG.path2.last = RG.arrayClone(p);

        // Go through the path information.
        for (var i=0,len=p.length; i<len; i+=1) {

            switch (p[i]) {
                case 'b':co.beginPath();break;
                case 'c':co.closePath();break;
                case 'm':co.moveTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 'l':co.lineTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 's':if(p[i+1])co.strokeStyle=p[i+1];co.stroke();i++;break;
                case 'f':if(p[i+1]){co.fillStyle=p[i+1];}co.fill();i++;break;
                case 'qc':co.quadraticCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'bc':co.bezierCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'r':co.rect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'a':co.arc(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),p[i+6]==='true'||p[i+6]===true||p[i+6]===1||p[i+6]==='1'?true:false);i+=6;break;
                case 'at':co.arcTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]));i+=5;break;
                case 'lw':co.lineWidth=parseFloat(p[i+1]);i++;break;
                case 'e':co.ellipse(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]),parseFloat(p[i+7]),p[i+8] === 'true' ? true : false);i+=8;break;
                case 'lj':co.lineJoin=p[i+1];i++;break;
                case 'lc':co.lineCap=p[i+1];i++;break;
                case 'sc':co.shadowColor=p[i+1];i++;break;
                case 'sb':co.shadowBlur=parseFloat(p[i+1]);i++;break;
                case 'sx':co.shadowOffsetX=parseFloat(p[i+1]);i++;break;
                case 'sy':co.shadowOffsetY=parseFloat(p[i+1]);i++;break;
                case 'fs':co.fillStyle=p[i+1];i++;break;
                case 'ss':co.strokeStyle=p[i+1];i++;break;
                case 'fr':co.fillRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'sr':co.strokeRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'cl':co.clip();break;
                case 'sa':co.save();break;
                case 'rs':co.restore();break;
                case 'tr':co.translate(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 'sl':co.scale(parseFloat(p[i+1]), parseFloat(p[i+2]));i+=2;break;
                case 'ro':co.rotate(parseFloat(p[i+1]));i++;break;
                case 'tf':co.transform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'stf':co.setTransform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'cr':co.clearRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'ld':var parts = p[i+1];co.setLineDash(parts);i+=1;break;
                case 'ldo':co.lineDashOffset=p[i+1];i++;break;
                case 'fo':co.font=p[i+1];i++;break;
                case 'ft':co.fillText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;
                case 'st':co.strokeText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;
                case 'ta':co.textAlign=p[i+1];i++;break;
                case 'tbl':co.textBaseline=p[i+1];i++;break;
                case 'ga':co.globalAlpha=parseFloat(p[i+1]);i++;break;
                case 'gco':co.globalCompositeOperation=p[i+1];i++;break;
                case 'fu':(p[i+1])(co.canvas.__object__);i++;break;

                // Empty option - ignore it
                case '':break;

                // Unknown option
                default: alert('[ERROR] Unknown option: ' + p[i]);
            }
        }

        function splitstring (p)
        {
            var ret = [], buffer = '', inquote = false, quote = '', substitutionIndex = 2;

            for (var i=0; i<p.length; i+=1) {

                var chr = p[i],
                    isWS = chr.match(/ /);

                if (isWS) {
                    if (!inquote) {

                        // Get rid of any enclosing quotes
                        if (buffer[0] === '"' || buffer[0] === "'") {
                            buffer = buffer.substr(1, buffer.length - 2);
                        }


                        // String substitution
                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {
                            buffer = args[substitutionIndex++];
                        }

                        ret.push(buffer);
                        buffer = '';
                    } else {
                        buffer += chr;
                    }
                } else {
                    if (chr === "'" || chr === '"') {
                        inquote = !inquote;
                    }

                    buffer += chr;
                }
            }

            // Do the last bit (including substitution)
            if (buffer.trim() === '%' && args[substitutionIndex]) {
                buffer = args[substitutionIndex++];
            }

            ret.push(buffer);

            return ret;
        }
    };




    //
    // Wraps the canvas in a DIV to allow DOM text to be used
    //
    // NOT USED ANY MORE
    //
    RG.wrap = function () {};




// End module pattern
})(window, document);




/**
 * Uses the alert() function to show the structure of the given variable
 *
 * @param mixed v The variable to print/alert the structure of
 */
window.$p = function (v)
{
    RGraph.pr(arguments[0], arguments[1], arguments[3]);
};




/**
 * A shorthand for the default alert() function
 */
window.$a = function (v)
{
    alert(v);
};




/**
 * Short-hand for console.log
 *
 * @param mixed v The variable to log to the console
 */
window.$cl = function (v)
{
    return console.log(v);
};




/**
 * A basic string formatting function. Use it like this:
 *
 * var str = '{0} {1} {2}'.format('a', 'b', 'c');
 *
 * Outputs: a b c
 */
if (!String.prototype.format) {
    String.prototype.format = function()
    {
        var args = arguments;

        return this.replace(/{(\d+)}/g, function(str, idx)
        {
            return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;
        });
    };
}

// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

/**
 * Initialise the various objects
 */
RGraph = window.RGraph || {isRGraph: true};

// Module pattern
(function (win, doc, undefined)
{
    var RG = RGraph,
        ua = navigator.userAgent,
        ma = Math;




    /**
     * This is the window click event listener. It redraws all canvas tags on the page.
     */
    RG.installWindowMousedownListener =
        RG.InstallWindowMousedownListener = function (obj)
        {
            if (!RG.window_mousedown_event_listener) {

                RG.window_mousedown_event_listener = function (e)
                {
                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;

                    e = RG.fixEventObject(e);


                    if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {
                        RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);
                        RG.redraw();
                        RG.hideTooltip();
                    }
                };
                win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);
            }
        };




    /**
     * This is the window click event listener. It redraws all canvas tags on the page.
     */
    RG.installWindowMouseupListener =
        RG.InstallWindowMouseupListener = function (obj)
        {
            if (!RG.window_mouseup_event_listener) {
                RG.window_mouseup_event_listener = function (e)
                {
                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;

                    e = RG.fixEventObject(e);


                    /**
                     * Stop any annotating that may be going on
                     */
                    if (RG.annotating_window_onmouseup) {
                        RG.annotating_window_onmouseup(e);
                        return;
                    }

                    /**
                     * End adjusting
                     */
                    if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {

                        var obj = RG.Registry.Get('chart.adjusting');

                        // If it's a line chart update the data_arr variable
                        if (obj && obj.type === 'line') {
                            obj.data_arr = RG.arrayLinearize(obj.data);
                        }

                        RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');
                    }

                    RG.Registry.set('chart.adjusting', null);
                    RG.Registry.set('chart.adjusting.shape', null);
                    RG.Registry.set('chart.adjusting.gantt', null);


                    // ==============================================
                    // Finally, redraw the chart
                    // ==============================================

                    var tags = document.getElementsByTagName('canvas');
                    for (var i=0; i<tags.length; ++i) {
                        if (tags[i].__object__ && tags[i].__object__.isRGraph) {
                            if (!tags[i].__object__.get('chart.annotatable')) {
                                if (!tags[i].__rgraph_trace_cover__ && !noredraw) {
                                    RG.clear(tags[i]);
                                } else {
                                    var noredraw = true;
                                }
                            }
                        }
                    }

                    if (!noredraw) {
                        RG.redraw();
                    }
                };
                win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);
            }
        };




    /**
     * This is the canvas mouseup event listener. It installs the mouseup event for the
     * canvas. The mouseup event then checks the relevant object.
     *
     * @param object obj The chart object
     *
     * RGraph.window_mouseup_event_listener
     */
    RG.installCanvasMouseupListener =
        RG.InstallCanvasMouseupListener = function (obj)
        {
            if (!obj.canvas.rgraph_mouseup_event_listener) {
                obj.canvas.rgraph_mouseup_event_listener = function (e)
                {
                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                    e = RG.fixEventObject(e);


                    // *************************************************************************
                    // Tooltips
                    // *************************************************************************


                    // This causes things at the edge of the chart area - eg line chart hotspots - not to fire because the
                    // cursor is out of the chart area
                    var objects = RG.ObjectRegistry.getObjectsByXY(e);
                    //var objects = RG.ObjectRegistry.getObjectsByCanvasID(e.target.id);

                    if (objects) {
                        for (var i=0,len=objects.length; i<len; i+=1) {

                            var obj = objects[i],
                                id  = objects[i].id;


                            // =========================================================================
                            // The drawing API text object supports chart.link
                            // ========================================================================
                            var link = obj.Get('link');

                            if (obj.type == 'drawing.text' && typeof link === 'string') {

                                var link_target  = obj.get('link.target');
                                var link_options = obj.get('link.options');

                                window.open(link, link_target ? link_target : null, link_options);
                            }


                            // ========================================================================
                            // Tooltips
                            // ========================================================================


                            if (!RG.isNull(obj) && RG.tooltip) {

                                var shape = obj.getShape(e);

                                if (shape && shape['tooltip']) {

                                    var text = shape['tooltip'];

                                    if (text) {

                                        var type = shape['object'].type;

                                        RG.clear(obj.canvas);
                                        RG.redraw();
                                        RG.Registry.set('chart.tooltip.shape', shape);

                                        // Note that tooltips are positioned at the pointer
                                        // now; and thats done within the .tooltip() function
                                        RG.tooltip(obj, text, 0, 0, shape['index'], e);

                                        obj.highlight(shape);

                                        // Add the shape that triggered the tooltip
                                        if (RG.Registry.get('chart.tooltip')) {

                                            RG.Registry.get('chart.tooltip').__shape__ = shape;

                                            RG.evaluateCursor(e);
                                        }

                                        e.cancelBubble = true;
                                        e.stopPropagation();
                                        return false;
                                    }
                                }
                            }





                            // =========================================================================
                            // Adjusting
                            // ========================================================================



                            if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {

                                //var obj = RG.Registry.get('chart.adjusting');

                                // If it's a line chart update the data_arr variable
                                if (obj && obj.type === 'line') {
                                    obj.data_arr = RG.arrayLinearize(obj.data);
                                }

                                RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');
                            }

                            RG.Registry.set('chart.adjusting', null);
                            RG.Registry.set('chart.adjusting.shape', null);
                            RG.Registry.set('chart.adjusting.gantt', null);

                            /**
                             * If the mouse pointer is over a "front" chart this prevents charts behind it
                             * from firing their events.
                             */
                            if (shape || (obj.overChartArea && obj.overChartArea(e)) ) {
                                break;
                            }
                        }
                    }
                };
                obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);
            }
        };




    /**
     * This is the canvas mousemove event listener.
     *
     * @param object obj The chart object
     */
    RG.installCanvasMousemoveListener =
        RG.InstallCanvasMousemoveListener = function (obj)
        {
            if (!obj.canvas.rgraph_mousemove_event_listener) {
                obj.canvas.rgraph_mousemove_event_listener = function (e)
                {

                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;
                    e = RG.fixEventObject(e);




                    /**
                     * Go through all the objects and check them to see if anything needs doing
                     */
                    var objects = RG.OR.getObjectsByXY(e);

                    // Necessary to track which objects have had the mouseover
                    // triggered on them
                    var uids = [];

                    if (objects && objects.length > 0) {

                        for (var i=0,len=objects.length; i<len; i+=1) {

                            var obj = objects[i];
                            var id  = obj.id;


                            // Record the uid
                            uids[obj.uid] = true;


                            if (!obj.getShape) {
                                continue;
                            }


                            var shape = obj.getShape(e);

                            // Fire the onmouseout event if necessary
                            if (
                                (!shape && typeof obj.__mouseover_shape_index__ === 'number') ||
                                (shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__)
                            ) {

                                RG.fireCustomEvent(obj, 'onmouseout');
                            }







                            //
                            // If the mouse is over a key element add the details
                            // of it to the Registry
                            //
                            if (obj.coords && obj.coords.key && obj.coords.key.length) {

                                var mouseXY = RG.getMouseXY(e);

                                for (var i=0,overkey=false; i<obj.coords.key.length; ++i) {

                                    if (
                                        mouseXY[0] >= obj.coords.key[i][0]
                                        && mouseXY[0] <= (obj.coords.key[i][0] + obj.coords.key[i][2])
                                        && mouseXY[1] >= obj.coords.key[i][1]
                                        && mouseXY[1] <= (obj.coords.key[i][1] + obj.coords.key[i][3])
                                    ) {

                                        RG.Registry.set('key-element', obj.coords.key[i]);
                                        overkey = true;
                                    }

                                    if (!overkey) {
                                        RG.Registry.set('key-element', null);
                                    }
                                }
                            }




                            // ================================================================================================ //
                            // This facilitates the chart.events.mousemove option
                            // ================================================================================================ //

                            var func = obj.get('chart.events.mousemove');

                            if (!func && typeof obj.onmousemove == 'function') {
                                var func = obj.onmousemove;
                            }

                            /**
                             *
                             */
                            if (shape) {
                                var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];
                                if (typeof(obj['$' + index]) == 'object' && typeof(obj['$' + index].onmousemove) == 'function') {
                                    var func2 = obj['$' + index].onmousemove;
                                }
                            }

                            /**
                             * This bit saves the current pointer style if there isn't one already saved
                             */
                            if (shape && (typeof(func) == 'function' || typeof(func2) == 'function' || typeof obj.Get('link') === 'string')) {

                                if (obj.Get('chart.events.mousemove.revertto') == null) {
                                    obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);
                                }

                                if (typeof(func)  == 'function')  RGraph.custom_events_mousemove_pointer = func(e, shape);
                                if (typeof(func2) == 'function') RGraph.custom_events_mousemove_pointer  = RGraph.custom_events_mousemove_pointer || func2(e, shape);

                                // Go through the RGraph.events array looking for more
                                // event listeners
                                if (   typeof RG.events === 'object'
                                    && typeof RG.events[obj.uid] === 'object') {

                                    for (i in RG.events[obj.uid]) {

                                        if (   typeof i === 'string'
                                            && typeof RG.events[obj.uid][i] === 'object'
                                            && RG.events[obj.uid][i][1] === 'onmousemove'
                                            && typeof RG.events[obj.uid][i][2] === 'function') {

                                            (RG.events[obj.uid][i][2])(obj);
                                        }
                                    }
                                }
                                //return;

                            } else if (typeof(obj.Get('chart.events.mousemove.revertto')) == 'string') {

                                RG.cursor.push('default');
                                obj.Set('chart.events.mousemove.revertto', null);
                            }





















                            // ======================================================
                            // This bit of code facilitates the onmouseover event
                            // ======================================================



                            var func = obj.properties['chart.events.mouseover'];

                            if (!func && typeof obj.onmouseover === 'function') {
                                func = obj.onmouseover;
                            }


                            // Allow for individually index functions to be specified
                            if (shape) {

                                var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];

                                if (typeof(obj['$' + index]) == 'object' && typeof(obj['$' + index].onmouseover) == 'function') {
                                    var func2 = obj['$' + index].onmouseover;
                                }
                            } else {

                                obj.__mouseover_shape_index__ = null;
                                RG.__mouseover_objects__      = [];
                            }

                            if (typeof RG.__mouseover_objects__ === 'undefined') {
                                RG.__mouseover_objects__ = [];
                            }


                            if (shape) {
                                if ((obj.__mouseover_shape_index__ === shape.index) === false) {

                                    obj.__mouseover_shape_index__ = shape.index;
                                    RG.__mouseover_objects__.push(obj);

                                    if (func) func(e, shape);
                                    if (func2) func2(e, shape);

                                    // Go through the RGraph.events array looking for more
                                    // event listeners
                                    if (   typeof RG.events === 'object'
                                        && typeof RG.events[obj.uid] === 'object') {

                                        for (i in RG.events[obj.uid]) {

                                            if (   typeof i === 'string'
                                                && typeof RG.events[obj.uid][i] === 'object'
                                                && RG.events[obj.uid][i][1] === 'onmouseover'
                                                && typeof RG.events[obj.uid][i][2] === 'function') {

                                                (RG.events[obj.uid][i][2])(obj);
                                            }
                                        }
                                    }
                                }
                            } else {
                                obj.__mouseover_shape_index__ = null;
                                RG.__mouseover_objects__      = [];
                            }























                            // ================================================================================================ //
                            // Tooltips
                            // ================================================================================================ //
                            var current_tooltip = RG.Registry.get('chart.tooltip');
                            var tooltips        = obj.get('chart.tooltips');
                            var tooltips_event  = obj.Get('chart.tooltips.event');


                            if (   shape
                                && (tooltips && tooltips[shape['index']] || shape['tooltip'])
                                && tooltips_event.indexOf('mousemove')  !== -1
                                && (   RG.isNull(current_tooltip) // Is there a tooltip being shown?
                                    || obj.uid != current_tooltip.__object__.uid // Same object?
                                    || (current_tooltip.__index__ != shape['index']) // Same tooltip index?
                                    || (typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])
                                )
                            ) {

                                RG.clear(obj.canvas);
                                RG.hideTooltip();
                                RG.redraw();
                                obj.canvas.rgraph_mouseup_event_listener(e);

                                return;
                            }


                            // ================================================================================================ //
                            // Adjusting
                            // ================================================================================================ //


                            if (obj && obj.get('chart.adjustable')) {
                                obj.Adjusting_mousemove(e);
                            }


                            /**
                             * This facilitates breaking out of the loop when a shape has been found -
                             * ie the cursor is over a shape an upper chart
                             */
                            if (shape || (obj.overChartArea && obj.overChartArea(e) )) {
                                break;
                            }
                        }

                        //
                        // For all objects that are NOT mouseover'ed, reset the
                        // mouseover flag back to null
                        //
                        var objects = RG.OR.getObjectsByCanvasID(e.target.id);

                        for (var i=0; i<objects.length; ++i) {
                            if (!uids[objects[i].uid]) {
                                objects[i].__mouseover_shape_index__ = null;
                            }
                        }

                    } else {

                        // Reset the mouseover flag on all of this canvas tags objects
                        var objects = RG.OR.getObjectsByCanvasID(e.target.id);

                        for (var i=0; i<objects.length; i++) {

                            if (typeof objects[i].__mouseover_shape_index__ === 'number') {
                                RG.fireCustomEvent(objects[i], 'onmouseout');
                            }

                            objects[i].__mouseover_shape_index__ = null;
                        }

                        RG.__mouseover_objects__ = [];
                    }







                    // ================================================================================================ //
                    // Crosshairs
                    // ================================================================================================ //


                    if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {
                        RG.drawCrosshairs(e, e.target.__object__);
                    }


                    // ================================================================================================ //
                    // Interactive key No LONGER REQUIRED
                    // ================================================================================================ //


                    //if (typeof InteractiveKey_line_mousemove == 'function') InteractiveKey_line_mousemove(e);
                    //if (typeof InteractiveKey_pie_mousemove == 'function') InteractiveKey_pie_mousemove(e);


                    // ================================================================================================ //
                    // Annotating
                    // ================================================================================================ //


                    if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {
                        RG.annotating_canvas_onmousemove(e);
                    }



                    /**
                     * Determine the pointer
                     */
                    RG.evaluateCursor(e);
                };
                obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);
            }
        };




    /**
     * This is the canvas mousedown event listener.
     *
     * @param object obj The chart object
     */
    RG.installCanvasMousedownListener =
        RG.InstallCanvasMousedownListener = function (obj)
        {
            if (!obj.canvas.rgraph_mousedown_event_listener) {
                obj.canvas.rgraph_mousedown_event_listener = function (e)
                {
                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                    e = RG.fixEventObject(e);


                    /**
                     * Annotating
                     */
                    if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {
                        RG.annotating_canvas_onmousedown(e);
                        return;
                    }

                    var obj = RG.ObjectRegistry.getObjectByXY(e);

                    if (obj) {

                        var id = obj.id;



                        /*************************************************************
                         * Handle adjusting for all object types
                         *************************************************************/
                        if (obj && obj.isRGraph && obj.get('chart.adjustable')) {

                            /**
                             * Check the cursor is in the correct area
                             */
                            var obj = RG.OR.getObjectByXY(e);

                            if (obj && obj.isRGraph) {

                                // If applicable, get the appropriate shape and store it in the registry
                                switch (obj.type) {
                                    case 'bar':   var shape = obj.getShapeByX(e); break;
                                    case 'gantt':

                                        var shape = obj.getShape(e);
                                        var data = typeof shape.subindex === 'number' ?  obj.data[shape.index][shape.subindex] : obj.data[shape.index];

                                        if (shape) {

                                            var mouseXY = RG.getMouseXY(e);

                                            RG.Registry.set('chart.adjusting.gantt', {
                                                index: shape.index,
                                                subindex: shape.subindex,
                                                object: obj,
                                                mousex: mouseXY[0],
                                                mousey: mouseXY[1],
                                                event: data,
                                                event_start: data[0],
                                                event_duration: data[1],
                                                mode: (mouseXY[0] > (shape['x'] + shape['width'] - 5) ? 'resize' : 'move'),
                                                shape: shape
                                            });
                                        }
                                        break;
                                    case 'line':  var shape = obj.getShape(e); break;
                                    case 'hbar':  var shape = obj.getShapeByY(e); break;
                                    default:      var shape = null;
                                }

                                //
                                // Added 30/9/2016
                                // Now check the index in the chart.adjusting.limitto property
                                // If that property is an object and the appropriate index is
                                // truthy then allow adjusting, otherwise don't.
                                //
                                if (
                                    RG.isNull(obj.properties['chart.adjustable.only'])
                                    || typeof obj.properties['chart.adjustable.only'] === 'undefined'
                                    ||
                                    (
                                        RG.isArray(obj.properties['chart.adjustable.only'])
                                        && obj.isAdjustable
                                        && obj.isAdjustable(shape)
                                    )
                                ) {

                                    RG.Registry.set('chart.adjusting.shape', shape);


                                    // Fire the onadjustbegin event
                                    RG.fireCustomEvent(obj, 'onadjustbegin');

                                    RG.Registry.set('chart.adjusting', obj);


                                    // Liberally redraw the canvas
                                    RG.clear(obj.canvas);
                                    RG.redraw();

                                    // Call the mousemove event listener so that the canvas
                                    // is adjusted even though the mouse isn't moved
                                    obj.canvas.rgraph_mousemove_event_listener(e);
                                }
                            }
                        }


                        RG.clear(obj.canvas);
                        RG.redraw();
                    }
                };
                obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);
            }
        };




    /**
     * This is the canvas click event listener. Used by the pseudo event listener
     *
     * @param object obj The chart object
     */
    RG.installCanvasClickListener =
        RG.InstallCanvasClickListener = function (obj)
        {
            if (!obj.canvas.rgraph_click_event_listener) {
                obj.canvas.rgraph_click_event_listener = function (e)
                {
                    /**
                     * For firefox add the window.event object
                     */
                    if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;

                    e = RG.fixEventObject(e);

                    var objects = RG.ObjectRegistry.getObjectsByXY(e);

                    for (var i=0,len=objects.length; i<len; i+=1) {

                        var obj   = objects[i];
                        var id    = obj.id;
                        var shape = obj.getShape(e);

                        /**
                         * This bit saves the current pointer style if there isn't one already saved
                         */
                        var func = obj.get('chart.events.click');

                        if (!func && typeof(obj.onclick) == 'function') {
                            func = obj.onclick;
                        }

                        if (shape && typeof func == 'function') {

                            func(e, shape);

                            // Go through the RGraph.events array looking for more
                            // event listeners

                            if (   typeof RG.events === 'object'
                                && typeof RG.events[obj.uid] === 'object') {

                                for (i in RG.events[obj.uid]) {

                                    if (   typeof i === 'string'
                                        && typeof RG.events[obj.uid][i] === 'object'
                                        && RG.events[obj.uid][i][1] === 'onclick'
                                        && typeof RG.events[obj.uid][i][2] === 'function') {

                                        (RG.events[obj.uid][i][2])(obj);
                                    }
                                }
                            }

                            /**
                             * If objects are layered on top of each other this return
                             * stops objects underneath from firing once the "top"
                             * objects user event has fired
                             */
                            return;
                        }



                        //
                        // Handle the key click event
                        //
                        var key = RG.Registry.get('key-element');
                        if (key) {
                            RG.fireCustomEvent(obj, 'onkeyclick');
                        }





                        /**
                         * The property takes priority over this.
                         */
                        if (shape) {

                            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];

                            if (typeof(index) == 'number' && obj['$' + index]) {

                                var func = obj['$' + index].onclick;

                                if (typeof(func) == 'function') {

                                    func(e, shape);

                                    /**
                                     * If objects are layered on top of each other this return
                                     * stops objects underneath from firing once the "top"
                                     * objects user event has fired
                                     */
                                    return;
                                }
                            }
                        }

                        /**
                         * This facilitates breaking out of the loop when a shape has been found -
                         * ie the cursor is over a shape an upper chart
                         */
                        if (shape || (obj.overChartArea && obj.overChartArea(e)) ) {
                            break;
                        }
                    }
                };
                obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);
            }
        };




    /**
     * This function evaluates the various cursor settings and if there's one for pointer, changes it to that
     */
    RG.evaluateCursor =
        RG.EvaluateCursor = function (e)
        {
            var obj     = null;
            var mouseXY = RG.getMouseXY(e);
            var mouseX  = mouseXY[0];
            var mouseY  = mouseXY[1];
            var canvas  = e.target;

            /**
             * Tooltips cause the mouse pointer to change
             */
            var objects = RG.OR.getObjectsByCanvasID(canvas.id);

            for (var i=0,len=objects.length; i<len; i+=1) {
                if ((objects[i].getShape && objects[i].getShape(e)) || (objects[i].overChartArea && objects[i].overChartArea(e))) {
                    var obj = objects[i];
                    var id  = obj.id;
                }
            }

            if (!RG.isNull(obj)) {
                if (obj.getShape && obj.getShape(e)) {

                    var shape = obj.getShape(e);

                    if (obj.get('chart.tooltips')) {

                        var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);

                        if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {
                            text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);
                        }

                        /**
                         * This essentially makes front charts "hide" the back charts
                         */
                        if (text) {
                            var pointer = true;
                        }
                    }
                }

                /**
                 * Now go through the key coords and see if it's over that.
                 */
                if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {
                    for (var j=0; j<obj.coords.key.length; ++j) {
                        if (mouseX > obj.coords.key[j][0] && mouseX < (obj.coords.key[j][0] + obj.coords.key[j][2]) && mouseY > obj.coords.key[j][1] && mouseY < (obj.coords.key[j][1] + obj.coords.key[j][3])) {
                            var pointer = true;
                        }
                    }
                }
            }

            /**
             * It can be specified in the user mousemove event - remember it can now
             * be specified in THREE ways
             */
            if (RGraph.custom_events_mousemove_pointer) {
                var pointer = true;
                RGraph.custom_events_mousemove_pointer = false;
            }
            /*


             var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];
             if (!RG.isNull(obj['$' + index]) && typeof(obj['$' + index].onmousemove) == 'function') {
             var str = (obj['$' + index].onmousemove).toString();
             if (str.match(/pointer/) && str.match(/cursor/) && str.match(/style/)) {
             var pointer = true;
             }
             }
             }
             */

            /**
             * Is the chart resizable? Go through all the objects again
             */
            var objects = RG.OR.objects.byCanvasID;

            for (var i=0,len=objects.length; i<len; i+=1) {
                if (objects[i] && objects[i][1].Get('chart.resizable')) {
                    var resizable = true;
                }
            }

            if (resizable && mouseX > (e.target.width - 32) && mouseY > (e.target.height - 16)) {
                pointer = true;
            }


            if (pointer) {
                e.target.style.cursor = 'pointer';
            } else if (e.target.style.cursor == 'pointer') {
                e.target.style.cursor = 'default';
            } else {
                e.target.style.cursor = null;
            }



            // =========================================================================
            // Resize cursor - check mouseis in bottom left corner and if it is change it
            // =========================================================================


            if (resizable && mouseX >= (e.target.width - 15) && mouseY >= (e.target.height - 15)) {
                e.target.style.cursor = 'move';

            } else if (e.target.style.cursor === 'move') {
                e.target.style.cursor = 'default';
            }


            // =========================================================================
            // Interactive key
            // =========================================================================



            if (typeof mouse_over_key == 'boolean' && mouse_over_key) {
                e.target.style.cursor = 'pointer';
            }


            // =========================================================================
            // Gantt chart adjusting
            // =========================================================================

            //if (obj && obj.type == 'gantt' && obj.get('chart.adjustable')) {
            //    if (obj.getShape && obj.getShape(e)) {
            //        e.target.style.cursor = 'ew-resize';
            //    } else {
            //        e.target.style.cursor = 'default';
            //    }
            //} else if (!obj || !obj.type) {
            //    e.target.style.cursor = cursor;
            //}


            // =========================================================================
            // Line chart adjusting
            // =========================================================================


            if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {
                if (obj.getShape) {

                    var shape = obj.getShape(e);

                    if (shape && obj.isAdjustable(shape)) {
                        e.target.style.cursor = 'ns-resize';
                    }
                } else {
                    e.target.style.cursor = 'default';
                }
            }


            // =========================================================================
            // Annotatable
            // =========================================================================


            if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {
                e.target.style.cursor = 'crosshair';
            }


            // =========================================================================
            // Drawing API link
            // =========================================================================


            if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {
                e.target.style.cursor = 'pointer';
            }
        };




    /**
     * This function handles the tooltip text being a string, function
     *
     * @param mixed tooltip This could be a string or a function. If it's a function it's called and
     *                       the return value is used as the tooltip text
     * @param numbr idx The index of the tooltip.
     */
    RG.parseTooltipText = function (tooltips, idx)
    {
        // No tooltips
        if (!tooltips) {
            return null;
        }

        // Get the tooltip text
        if (typeof tooltips == 'function') {
            var text = tooltips(idx);

            // A single tooltip. Only supported by the Scatter chart
        } else if (typeof tooltips == 'string') {
            var text = tooltips;

        } else if (typeof tooltips == 'object' && typeof tooltips[idx] == 'function') {
            var text = tooltips[idx](idx);

        } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {
            var text = tooltips[idx];

        } else {
            var text = '';
        }

        if (text == 'undefined') {
            text = '';
        } else if (text == 'null') {
            text = '';
        }

        // Conditional in case the tooltip file isn't included
        return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;
    };




    /**
     * Draw crosshairs if enabled
     *
     * @param object obj The graph object (from which we can get the context and canvas as required)
     */
    RG.drawCrosshairs =
        RG.DrawCrosshairs = function (e, obj)
        {
            var e            = RG.fixEventObject(e),
                width        = obj.canvas.width,
                height       = obj.canvas.height,
                mouseXY      = RG.getMouseXY(e),
                x            = mouseXY[0],
                y            = mouseXY[1],
                gutterLeft   = obj.gutterLeft,
                gutterRight  = obj.gutterRight,
                gutterTop    = obj.gutterTop,
                gutterBottom = obj.gutterBottom,
                Mathround    = Math.round,
                prop         = obj.properties,
                co           = obj.context,
                ca           = obj.canvas

            RG.redrawCanvas(ca);

            if (   x >= gutterLeft
                && y >= gutterTop
                && x <= (width - gutterRight)
                && y <= (height - gutterBottom)
            ) {

                var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;
                co.lineWidth = linewidth ? linewidth : 1;

                co.beginPath();
                co.strokeStyle = prop['chart.crosshairs.color'];





                /**
                 * The chart.crosshairs.snap option
                 */
                if (prop['chart.crosshairs.snap']) {

                    // Linear search for the closest point
                    var point = null;
                    var dist  = null;
                    var len   = null;

                    if (obj.type == 'line') {

                        for (var i=0; i<obj.coords.length; ++i) {

                            var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);

                            // Check the mouse X coordinate
                            if (typeof dist != 'number' || length < dist) {
                                var point = i;
                                var dist = length;
                            }
                        }

                        x = obj.coords[point][0];
                        y = obj.coords[point][1];

                        // Get the dataset
                        for (var dataset=0; dataset<obj.coords2.length; ++dataset) {
                            for (var point=0; point<obj.coords2[dataset].length; ++point) {
                                if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {
                                    ca.__crosshairs_snap_dataset__ = dataset;
                                    ca.__crosshairs_snap_point__   = point;
                                }
                            }
                        }

                    } else {

                        for (var i=0; i<obj.coords.length; ++i) {
                            for (var j=0; j<obj.coords[i].length; ++j) {

                                // Check the mouse X coordinate
                                var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);

                                if (typeof(dist) != 'number' || len < dist) {

                                    var dataset = i;
                                    var point   = j;
                                    var dist   = len;
                                }
                            }

                        }
                        ca.__crosshairs_snap_dataset__ = dataset;
                        ca.__crosshairs_snap_point__   = point;


                        x = obj.coords[dataset][point][0];
                        y = obj.coords[dataset][point][1];
                    }
                }






                // Draw a top vertical line
                if (prop['chart.crosshairs.vline']) {
                    co.moveTo(Mathround(x), Mathround(gutterTop));
                    co.lineTo(Mathround(x), Mathround(height - gutterBottom));
                }

                // Draw a horizontal line
                if (prop['chart.crosshairs.hline']) {
                    co.moveTo(Mathround(gutterLeft), Mathround(y));
                    co.lineTo(Mathround(width - gutterRight), Mathround(y));
                }

                co.stroke();


                /**
                 * Need to show the coords?
                 */
                if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {

                    var xCoord = (((x - gutterLeft) / (width - gutterLeft - gutterRight)) * (prop['chart.xmax'] - prop['chart.xmin'])) + prop['chart.xmin'];
                    xCoord = xCoord.toFixed(prop['chart.scale.decimals']);
                    var yCoord = obj.max - (((y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom)) * obj.max);

                    if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {
                        yCoord = (yCoord - (obj.max / 2)) * 2;
                    }

                    yCoord = yCoord.toFixed(prop['chart.scale.decimals']);

                    var div      = RG.Registry.get('chart.coordinates.coords.div');
                    var mouseXY  = RG.getMouseXY(e);
                    var canvasXY = RG.getCanvasXY(ca);

                    if (!div) {
                        var div = document.createElement('DIV');
                        div.__object__               = obj;
                        div.style.position           = 'absolute';
                        div.style.backgroundColor    = 'white';
                        div.style.border             = '1px solid black';
                        div.style.fontFamily         = 'Arial, Verdana, sans-serif';
                        div.style.fontSize           = '10pt'
                        div.style.padding            = '2px';
                        div.style.opacity            = 1;
                        div.style.WebkitBorderRadius = '3px';
                        div.style.borderRadius       = '3px';
                        div.style.MozBorderRadius    = '3px';
                        document.body.appendChild(div);

                        RG.Registry.set('chart.coordinates.coords.div', div);
                    }

                    // Convert the X/Y pixel coords to correspond to the scale
                    div.style.opacity = 1;
                    div.style.display = 'inline';

                    if (!prop['chart.crosshairs.coords.fixed']) {
                        div.style.left = ma.max(2, (e.pageX - div.offsetWidth - 3)) + 'px';
                        div.style.top = ma.max(2, (e.pageY - div.offsetHeight - 3))  + 'px';
                    } else {
                        div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';
                        div.style.top  = canvasXY[1] + gutterTop + 3 + 'px';
                    }

                    div.innerHTML = '<span style="color: #666">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style="color: #666">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;

                    obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);

                    ca.__crosshairs_labels__ = div;
                    ca.__crosshairs_x__ = xCoord;
                    ca.__crosshairs_y__ = yCoord;

                } else if (prop['chart.crosshairs.coords']) {
                    alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');
                }

                /**
                 * Fire the oncrosshairs custom event
                 */
                RG.fireCustomEvent(obj, 'oncrosshairs');

            } else {
                RG.hideCrosshairCoords();
            }
        };




    //
    // Adds a mousemove event listener that highlights a segment based on th
    // mousemove event. Used in the Rose and the RScatter charts
    //
    //@param int segments The number of segments to allow
    //
    RG.allowSegmentHighlight = function (opt)
    {
        var obj    = opt.object,
            count  = opt.count,
            fill   = opt.fill,
            stroke = opt.stroke

        if (!RG.segmentHighlightFunction) {

            RG.segmentHighlightFunction = function (e)
            {

                var mouseXY = RG.getMouseXY(e);
                var angle   = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);

                angle += RG.HALFPI;

                if (angle > RG.TWOPI) {
                    angle -= RG.TWOPI;
                }

                RG.redraw();

                var start = 0;
                var end   = 0;
                var a     = (ma.PI * 2) / count;

                //
                // Radius
                //
                var r = obj.radius;


                (function ()
                {
                    for (i=0; i<count; i+=1) {
                        if (angle < (a * (i + 1))) {
                            start = i * a;
                            end   = (i + 1) * a;

                            return;
                        }
                    }
                })();

                start -= RG.HALFPI;
                end   -= RG.HALFPI;


                RG.path2(
                    obj.context,
                    'b m % % a % % % % % false c s % f %',
                    obj.centerx, obj.centery,
                    obj.centerx,obj.centery,r,start,end,
                    stroke,
                    fill
                );

            };
            obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);
        }
    }




// End module pattern
})(window, document);

// version: 2017-01-02
/**
 * o--------------------------------------------------------------------------------o
 * | This file is part of the RGraph package - you can learn more at:               |
 * |                                                                                |
 * |                          http://www.rgraph.net                                 |
 * |                                                                                |
 * | RGraph is licensed under the Open Source MIT license. That means that it's     |
 * | totally free to use!                                                           |
 * o--------------------------------------------------------------------------------o
 */

RGraph = window.RGraph || {isRGraph: true};




/**
 * The bar chart constructor
 *
 * @param object canvas The canvas object
 * @param array  data   The chart data
 */
RGraph.Bar = function (conf)
{
    /**
     * Allow for object config style
     */
    if (typeof conf === 'object' && typeof conf.data === 'object'&& typeof conf.id === 'string') {
        var id                        = conf.id,
            canvas                    = document.getElementById(id),
            data                      = conf.data,
            parseConfObjectForOptions = true // Set this so the config is parsed (at the end of the constructor)
    } else {
        var id     = conf,
            canvas = document.getElementById(id),
            data   = arguments[1]
    }




    // Get the canvas and context objects
    this.id                     = id;
    this.canvas                 = canvas;
    this.context                = this.canvas.getContext('2d');
    this.canvas.__object__      = this;
    this.type                   = 'bar';
    this.max                    = 0;
    this.stackedOrGrouped       = false;
    this.isRGraph               = true;
    this.uid                    = RGraph.CreateUID();
    this.canvas.uid             = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
    this.colorsParsed           = false;
    this.original_colors        = [];
    this.cachedBackgroundCanvas = null;
    this.firstDraw              = true; // After the first draw this will be false


    /**
     * Compatibility with older browsers
     */
    //RGraph.OldBrowserCompat(this.context);


    // Various config type stuff
    this.properties =
        {
            'chart.background.barcolor1':   'rgba(0,0,0,0)',
            'chart.background.barcolor2':   'rgba(0,0,0,0)',
            'chart.background.grid':        true,
            'chart.background.grid.color':  '#ddd',
            'chart.background.grid.width':  1,
            'chart.background.grid.hsize':  20,
            'chart.background.grid.vsize':  20,
            'chart.background.grid.vlines': true,
            'chart.background.grid.hlines': true,
            'chart.background.grid.border': true,
            'chart.background.grid.autofit':true,
            'chart.background.grid.autofit.align': true,
            'chart.background.grid.autofit.numhlines': 5,
            'chart.background.grid.autofit.numvlines': 20,
            'chart.background.grid.dashed': false,
            'chart.background.grid.dotted': false,
            'chart.background.image.stretch': true,
            'chart.background.image.x':     null,
            'chart.background.image.y':     null,
            'chart.background.image.w':     null,
            'chart.background.image.h':     null,
            'chart.background.image.align': null,
            'chart.background.color':       null,
            'chart.background.hbars':       null,
            'chart.numyticks':              10,
            'chart.hmargin':                5,
            'chart.hmargin.grouped':        1,
            'chart.strokecolor':            'rgba(0,0,0,0)',
            'chart.axis.color':             'black',
            'chart.axis.linewidth':         1,
            'chart.gutter.top':             25,
            'chart.gutter.bottom':          30,
            'chart.gutter.left':            25,
            'chart.gutter.right':           25,
            'chart.labels':                 null,
            'chart.labels.bold':            false,
            'chart.labels.color':           null,
            'chart.labels.ingraph':         null,
            'chart.labels.above':           false,
            'chart.labels.above.decimals':  0,
            'chart.labels.above.size':      null,
            'chart.labels.above.color':     null,
            'chart.labels.above.background':'rgba(0,0,0,0)',
            'chart.labels.above.angle':     null,
            'chart.labels.above.offset':    4,
            'chart.labels.above.units.pre': '',
            'chart.labels.above.units.post':'',
            'chart.ylabels':                true,
            'chart.ylabels.count':          5,
            'chart.ylabels.inside':         false,
            'chart.ylabels.offsetx':        0,
            'chart.ylabels.offsety':        0,
            'chart.labels.offsetx':         0,
            'chart.labels.offsety':         0,
            'chart.xaxispos':               'bottom',
            'chart.yaxispos':               'left',
            'chart.text.angle':             0,
            'chart.text.color':             'black', // Gradients aren't supported for this color
            'chart.text.size':              12,
            'chart.text.font':              'Segoe UI, Arial, Verdana, sans-serif',
            'chart.text.accessible':              true,
            'chart.text.accessible.overflow':     'visible',
            'chart.text.accessible.pointerevents': true,
            'chart.ymin':                   0,
            'chart.ymax':                   null,
            'chart.title':                  '',
            'chart.title.font':             null,
            'chart.title.background':       null, // Gradients aren't supported for this color
            'chart.title.hpos':             null,
            'chart.title.vpos':             null,
            'chart.title.bold':             true,
            'chart.title.xaxis':            '',
            'chart.title.xaxis.bold':       true,
            'chart.title.xaxis.size':       null,
            'chart.title.xaxis.font':       null,
            'chart.title.xaxis.color':      null,
            'chart.title.yaxis':            '',
            'chart.title.yaxis.bold':       true,
            'chart.title.yaxis.size':       null,
            'chart.title.yaxis.font':       null,
            'chart.title.yaxis.color':      null, // Gradients aren't supported for this color
            'chart.title.xaxis.pos':        null,
            'chart.title.yaxis.pos':        null,
            'chart.title.yaxis.x':          null,
            'chart.title.yaxis.y':          null,
            'chart.title.xaxis.x':          null,
            'chart.title.xaxis.y':          null,
            'chart.title.x':                null,
            'chart.title.y':                null,
            'chart.title.halign':           null,
            'chart.title.valign':           null,
            'chart.colors':                 ['red','#0f0','blue','pink','orange','cyan','black','white','green','magenta'],
            'chart.colors.sequential':      false,
            'chart.colors.reverse':         false,
            'chart.grouping':               'grouped',
            'chart.variant':                'bar',
            'chart.variant.sketch.verticals': true,
            'chart.variant.threed.xaxis':   true,
            'chart.variant.threed.yaxis':   true,
            'chart.variant.threed.angle':   0.1,
            'chart.variant.threed.offsetx': 10,
            'chart.variant.threed.offsety': 5,
            'chart.shadow':                 false,
            'chart.shadow.color':           '#aaa',  // Gradients aren't supported for this color
            'chart.shadow.offsetx':         0,
            'chart.shadow.offsety':         0,
            'chart.shadow.blur':            15,
            'chart.tooltips':               null,
            'chart.tooltips.effect':        'fade',
            'chart.tooltips.css.class':     'RGraph_tooltip',
            'chart.tooltips.event':         'onclick',
            'chart.tooltips.highlight':     true,
            'chart.tooltips.hotspot.xonly': false,
            'chart.highlight.stroke':       'rgba(0,0,0,0)',
            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
            'chart.key':                    null,
            'chart.key.background':         'white',
            'chart.key.position':           'graph',
            'chart.key.shadow':             false,
            'chart.key.shadow.color':       '#666',
            'chart.key.shadow.blur':        3,
            'chart.key.shadow.offsetx':     2,
            'chart.key.shadow.offsety':     2,
            'chart.key.position.gutter.boxed':false,
            'chart.key.position.x':         null,
            'chart.key.position.y':         null,
            'chart.key.interactive':        false,
            'chart.key.interactive.highlight.chart.stroke':'black',
            'chart.key.interactive.highlight.chart.fill':'rgba(255,255,255,0.7)',
            'chart.key.interactive.highlight.label':'rgba(255,0,0,0.2)',
            'chart.key.halign':             'right',
            'chart.key.color.shape':        'square',
            'chart.key.rounded':            true,
            'chart.key.text.size':          10,
            'chart.key.linewidth':          1,
            'chart.key.colors':             null,
            'chart.key.text.color':         'black',
            'chart.contextmenu':            null,
            'chart.units.pre':              '',
            'chart.units.post':             '',
            'chart.scale.decimals':         0,
            'chart.scale.point':            '.',
            'chart.scale.thousand':         ',',
            'chart.scale.round':            false,
            'chart.scale.zerostart':        true,
            'chart.crosshairs':             false,
            'chart.crosshairs.color':       '#333',
            'chart.crosshairs.hline':       true,
            'chart.crosshairs.vline':       true,
            'chart.linewidth':              1,
            'chart.annotatable':            false,
            'chart.annotate.color':         'black',
            'chart.zoom.factor':            1.5,
            'chart.zoom.fade.in':           true,
            'chart.zoom.fade.out':          true,
            'chart.zoom.hdir':              'right',
            'chart.zoom.vdir':              'down',
            'chart.zoom.frames':            25,
            'chart.zoom.delay':             16.666,
            'chart.zoom.shadow':            true,
            'chart.zoom.background':        true,
            'chart.resizable':              false,
            'chart.resize.handle.background': null,
            'chart.adjustable':             false,
            'chart.adjustable.only':        null,
            'chart.noaxes':                 false,
            'chart.noxaxis':                false,
            'chart.noyaxis':                false,
            'chart.events.click':           null,
            'chart.events.mousemove':       null,
            'chart.numxticks':              null,
            'chart.bevel':                  false,
            'chart.errorbars':              false,
            'chart.errorbars.color':        'black',
            'chart.errorbars.capped':        true,
            'chart.errorbars.capped.width':  14,
            'chart.errorbars.linewidth':     1,
            'chart.combinedchart.effect':    null,
            'chart.combinedchart.effect.options':  null,
            'chart.combinedchart.effect.callback': null,
            'chart.clearto':   'rgba(0,0,0,0)'
        }

    // Check for support
    if (!this.canvas) {
        alert('[BAR] No canvas support');
        return;
    }


    //
    // Convert strings into numbers. Also converts undefined elements to null
    //
    for (var i=0; i<data.length; ++i) {
        if (typeof data[i] === 'string') {
            data[i] = parseFloat(data[i]);
        } else if (typeof data[i] === 'object' && data[i]) {
            for (var j=0; j<data[i].length; ++j) {
                if (typeof data[i][j] === 'string') {
                    data[i][j] = parseFloat(data[i][j]);
                }
            }
        } else if (typeof data[i] === 'undefined') {
            data[i] = null;
        }
    }

    /**
     * Determine whether the chart will contain stacked or grouped bars
     */
    for (var i=0; i<data.length; ++i) {
        if (typeof data[i] === 'object' && !RGraph.is_null(data[i])) {
            this.stackedOrGrouped = true;
        }
    }


    /**
     * Create the dollar objects so that functions can be added to them
     */
    var linear_data = RGraph.arrayLinearize(data);

    for (var i=0; i<linear_data.length; ++i) {
        this['$' + i] = {};
    }


    // Store the data and set the orignal_data to it
    this.data = data;
    this.original_data = RGraph.arrayClone(data);


    // Used to store the coords of the bars
    this.coords     = [];
    this.coords2    = [];
    this.coordsText = [];



    /**
     * This linearises the data. Doing so can make it easier to pull
     * out the appropriate data from tooltips
     */
    this.data_arr = RGraph.arrayLinearize(this.data);


    /**
     * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
     * done already
     */
    if (!this.canvas.__rgraph_aa_translated__) {
        this.context.translate(0.5,0.5);

        this.canvas.__rgraph_aa_translated__ = true;
    }





    // Short variable names
    var RG   = RGraph,
        ca   = this.canvas,
        co   = ca.getContext('2d'),
        prop = this.properties,
        pa2  = RG.path2,
        win  = window,
        doc  = document,
        ma   = Math



    /**
     * "Decorate" the object with the generic effects if the effects library has been included
     */
    if (RG.Effects && typeof RG.Effects.decorate === 'function') {
        RG.Effects.decorate(this);
    }





    /**
     * A setter
     *
     * @param name  string The name of the property to set
     * @param value mixed  The value of the property
     */
    this.set =
        this.Set = function (name)
        {
            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];

            /**
             * the number of arguments is only one and it's an
             * object - parse it for configuration data and return.
             */
            if (arguments.length === 1 && typeof arguments[0] === 'object') {
                RG.parseObjectStyleConfig(this, arguments[0]);
                return this;
            }








            /**
             * This should be done first - prepend the propertyy name with "chart." if necessary
             */
            if (name.substr(0,6) != 'chart.') {
                name = 'chart.' + name;
            }




            // Convert uppercase letters to dot+lower case letter
            while(name.match(/([A-Z])/)) {
                name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
            }


            // BC accommodation
            if (name === 'chart.xlabels.offset') {
                name = 'chart.labels.offsety';
            }

            if (name == 'chart.labels.abovebar') {
                name = 'chart.labels.above';
            }

            if (name == 'chart.strokestyle') {
                name = 'chart.strokecolor';
            }

            /**
             * Check for xaxispos
             */
            if (name == 'chart.xaxispos' ) {
                if (value != 'bottom' && value != 'center' && value != 'top') {
                    alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');
                    value = 'center';
                }

                if (value == 'top') {
                    for (var i=0; i<this.data.length; ++i) {
                        if (typeof(this.data[i]) == 'number' && this.data[i] > 0) {
                            alert('[BAR] The data element with index ' + i + ' should be negative');
                        }
                    }
                }
            }

            /**
             * lineWidth doesn't appear to like a zero setting
             */
            if (name.toLowerCase() == 'chart.linewidth' && value == 0) {
                value = 0.0001;
            }






            prop[name] = value;

            return this;
        };




    /**
     * A getter
     *
     * @param name  string The name of the property to get
     */
    this.get =
        this.Get = function (name)
        {
            /**
             * This should be done first - prepend the property name with "chart." if necessary
             */
            if (name.substr(0,6) != 'chart.') {
                name = 'chart.' + name;
            }

            // Convert uppercase letters to dot+lower case letter
            while(name.match(/([A-Z])/)) {
                name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
            }

            return prop[name];
        };




    /**
     * The function you call to draw the bar chart
     */
    this.draw =
        this.Draw = function ()
        {
            // MUST be the first thing done!
            if (typeof(prop['chart.background.image']) == 'string') {
                RG.DrawBackgroundImage(this);
            }

            /**
             * Fire the onbeforedraw event
             */
            RG.FireCustomEvent(this, 'onbeforedraw');



            //
            // If the chart is 3d then angle it it
            //
            if (prop['chart.variant'] === '3d') {
                if (prop['chart.text.accessible']) {
                    // Nada
                } else {
                    co.setTransform(1,prop['chart.variant.threed.angle'],0,1,0.5,0.5);
                }
            }



            /**
             * Parse the colors. This allows for simple gradient syntax
             */
            if (!this.colorsParsed) {
                this.parseColors();

                // Don't want to do this again
                this.colorsParsed = true;
            }



            /**
             * This is new in May 2011 and facilitates indiviual gutter settings,
             * eg chart.gutter.left
             */
            this.gutterLeft   = prop['chart.gutter.left'];
            this.gutterRight  = prop['chart.gutter.right'];
            this.gutterTop    = prop['chart.gutter.top'];
            this.gutterBottom = prop['chart.gutter.bottom'];

            // Cache this in a class variable as it's used rather a lot

            /**
             * Check for tooltips and alert the user that they're not supported
             * with pyramid charts
             */
            if (   (prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot')
                && typeof(prop['chart.tooltips']) == 'object'
                && prop['chart.tooltips']
                && prop['chart.tooltips'].length > 0) {

                alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');
            }

            /**
             * Stop the coords arrays from growing uncontrollably
             */
            this.coords     = [];
            this.coords2    = [];
            this.coordsText = [];

            /**
             * Work out a few things. They need to be here because they depend on things you can change before you
             * call Draw() but after you instantiate the object
             */
            this.max            = 0;
            this.grapharea      = ca.height - this.gutterTop - this.gutterBottom;
            this.halfgrapharea  = this.grapharea / 2;
            this.halfTextHeight = prop['chart.text.size'] / 2;





            // Now draw the background on to the main canvas
            RG.background.Draw(this);




            //If it's a sketch chart variant, draw the axes first
            //if (prop['chart.variant'] == 'sketch') {
            //    this.DrawAxes();
            //    this.Drawbars();
            //} else {
            this.drawbars();
            this.drawAxes();
            //}

            this.DrawLabels();


            /**
             * Draw the bevel if required
             */
            if (prop['chart.bevel'] || prop['chart.bevelled']) {
                this.DrawBevel();
            }


            // Draw the key if necessary
            if (prop['chart.key'] && prop['chart.key'].length) {
                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
            }


            /**
             * Setup the context menu if required
             */
            if (prop['chart.contextmenu']) {
                RG.ShowContext(this);
            }




            /**
             * Draw errorbars
             */
            if (prop['chart.errorbars']) {
                this.drawErrorbars();
            }




            /**
             * Draw "in graph" labels
             */
            if (prop['chart.labels.ingraph']) {
                RG.DrawInGraphLabels(this);
            }


            /**
             * This function enables resizing
             */
            if (prop['chart.resizable']) {
                RG.AllowResizing(this);
            }


            /**
             * This installs the event listeners
             */
            RG.InstallEventListeners(this);


            /**
             * Fire the onfirstdraw event
             */
            if (this.firstDraw) {
                RG.fireCustomEvent(this, 'onfirstdraw');
                this.firstDraw = false;
                this.firstDrawFunc();
            }


            /**
             * Fire the RGraph ondraw event
             */
            RG.fireCustomEvent(this, 'ondraw');

            return this;
        };



    /**
     * Used in chaining. Runs a function there and then - not waiting for
     * the events to fire (eg the onbeforedraw event)
     *
     * @param function func The function to execute
     */
    this.exec = function (func)
    {
        func(this);

        return this;
    };




    /**
     * Draws the charts axes
     */
    this.drawAxes =
        this.DrawAxes = function ()
        {
            if (prop['chart.noaxes']) {
                return;
            }

            var xaxispos = prop['chart.xaxispos'];
            var yaxispos = prop['chart.yaxispos'];
            var isSketch = prop['chart.variant'] == 'sketch';

            co.beginPath();
            co.strokeStyle = prop['chart.axis.color'];
            co.lineWidth   = prop['chart.axis.linewidth'] + 0.001;


            if (RG.ISSAFARI == -1) {
                co.lineCap = 'square';
            }


            // Draw the Y axis
            if (prop['chart.noyaxis'] == false) {
                if (yaxispos == 'right') {
                    co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                    co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
                } else {
                    co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));
                    co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
                }
            }

            // Draw the X axis
            if (prop['chart.noxaxis'] == false) {
                if (xaxispos == 'center') {
                    co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + (isSketch ? 2 : 0)));
                    co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - (isSketch ? 2 : 0)));
                } else if (xaxispos == 'top') {
                    co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                    co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));
                } else {
                    co.moveTo(
                        this.gutterLeft - (isSketch ? 5 : 0),
                        ma.round(this.getYCoord(0) - (isSketch ? 2 : 0))
                    );
                    co.lineTo(
                        ca.width - this.gutterRight + (isSketch ? 8 : 0),
                        ma.round(this.getYCoord(0) + (isSketch ? 2 : 0))
                    );

                }
            }

            var numYTicks = prop['chart.numyticks'];

            //
            // DRAW THE Y TICKMARKS
            //
            if (prop['chart.noyaxis'] == false && !isSketch) {

                var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;
                var xpos     = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;

                if (this.properties['chart.numyticks'] > 0) {
                    for (y=this.gutterTop;
                         xaxispos == 'center' ? y <= (ca.height - this.gutterBottom) : y < (ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0));
                         y += yTickGap) {

                        if (xaxispos == 'center' && y == (this.gutterTop + (this.grapharea / 2))) {
                            continue;
                        }

                        // X axis at the top
                        if (xaxispos == 'top' && y == this.gutterTop) {
                            continue;
                        }

                        co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(y));
                        co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(y));
                    }

                    //
                    // If the X axis is offset (ie not at the bottom when xaxispos
                    // is set to bottom) - draw an extra tick
                    //
                    if (xaxispos === 'bottom' && prop['chart.ymin'] !== 0) {
                        co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), ma.round(ca.height - prop['chart.gutter.bottom']));
                        co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), ma.round(ca.height - prop['chart.gutter.bottom']));
                    }
                }

                /**
                 * If the X axis is not being shown, draw an extra tick
                 */
                if (prop['chart.noxaxis']) {
                    if (xaxispos == 'center') {
                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));
                        co.lineTo(xpos, Math.round(ca.height / 2));
                    } else if (xaxispos == 'top') {
                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));
                        co.lineTo(xpos, Math.round(this.gutterTop));
                    } else {
                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));
                        co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));
                    }
                }
            }


            // Draw the X tickmarks
            if (prop['chart.noxaxis'] == false && !isSketch) {

                if (typeof(prop['chart.numxticks']) == 'number') {
                    var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];
                } else {
                    var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;
                }

                if (xaxispos == 'bottom') {
                    yStart   = prop['chart.ymin'] < 0 ? this.getYCoord(0) - 3 : this.getYCoord(0);
                    yEnd     = this.getYCoord(0) + 3;
                } else if (xaxispos == 'top') {
                    yStart = this.gutterTop - 3;
                    yEnd   = this.gutterTop;
                } else if (xaxispos == 'center') {
                    yStart = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + 3;
                    yEnd   = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - 3;
                }

                //yStart = yStart;
                //yEnd   = yEnd;

                //////////////// X TICKS ////////////////
                var noEndXTick = prop['chart.noendxtick'];

                for (x=this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0),len=(ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0)); x<len; x+=xTickGap) {

                    if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {
                        co.moveTo(ma.round(x), yStart);
                        co.lineTo(ma.round(x), yEnd);

                    } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < (ca.width - this.gutterRight) ) {
                        co.moveTo(ma.round(x), yStart);
                        co.lineTo(ma.round(x), yEnd);

                    } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && !noEndXTick) {
                        co.moveTo(ma.round(x), yStart);
                        co.lineTo(ma.round(x), yEnd);

                    } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && x > (this.gutterLeft) && noEndXTick) {
                        co.moveTo(ma.round(x), yStart);
                        co.lineTo(ma.round(x), yEnd);
                    }
                }

                if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {
                    if (typeof(prop['chart.numxticks']) == 'number' && prop['chart.numxticks'] > 0) {
                        co.moveTo(Math.round(this.gutterLeft), yStart);
                        co.lineTo(Math.round(this.gutterLeft), yEnd);
                    }
                }

                //////////////// X TICKS ////////////////
            }

            /**
             * If the Y axis is not being shown, draw an extra tick
             */
            if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {
                if (xaxispos == 'center') {
                    co.moveTo(ma.round(this.gutterLeft), (ca.height / 2) - 3);
                    co.lineTo(ma.round(this.gutterLeft), (ca.height / 2) + 3);
                } else {
                    co.moveTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom);
                    co.lineTo(ma.round(this.gutterLeft), ca.height - this.gutterBottom + 3);
                }
            }

            co.stroke();
        };




    /**
     * Draws the bars
     */
    this.drawbars =
        this.Drawbars = function ()
        {
            co.lineWidth   = prop['chart.linewidth'];
            co.strokeStyle = prop['chart.strokecolor'];
            co.fillStyle   = prop['chart.colors'][0];

            var prevX      = 0,
                prevY      = 0,
                decimals   = prop['chart.scale.decimals'];


            /**
             * Work out the max value
             */
            if (prop['chart.ymax']) {

                this.scale2 = RG.getScale2(this, {
                    'max':prop['chart.ymax'],
                    'strict': prop['chart.scale.round'] ? false : true,
                    'min':prop['chart.ymin'],
                    'scale.thousand':prop['chart.scale.thousand'],
                    'scale.point':prop['chart.scale.point'],
                    'scale.decimals':prop['chart.scale.decimals'],
                    'ylabels.count':prop['chart.ylabels.count'],
                    'scale.round':prop['chart.scale.round'],
                    'units.pre': prop['chart.units.pre'],
                    'units.post': prop['chart.units.post']
                });

            } else {





                //
                // If errorbars are given as a number then convert the nuumber to an
                // array.
                //
                var errorbars = prop['chart.errorbars'];

                if (typeof errorbars === 'number') {

                    var value = errorbars;

                    prop['chart.errorbars'] = [];

                    for (var i=0; i<this.data.length; ++i) {
                        if (typeof this.data[i] === 'number') {
                            prop['chart.errorbars'].push([value, null]);

                        } else if (typeof this.data[i] === 'object' && !RG.isNull(this.data[i])) {
                            for (var j=0; j<this.data[i].length; ++j) {
                                prop['chart.errorbars'].push([value, null]);
                            }
                        }
                    }

                    errorbars = prop['chart.errorbars'];
                }








                for (i=0; i<this.data.length; ++i) {
                    if (typeof(this.data[i]) == 'object') {
                        var value = prop['chart.grouping'] === 'grouped' ? Number(RG.arrayMax(this.data[i], true)) : Number(RG.array_sum(this.data[i]));

                    } else {
                        var value = Number(this.data[i]);
                    }

                    this.max = ma.max(ma.abs(this.max), ma.abs(value) +

                        Number(
                            (
                                typeof prop['chart.errorbars'] === 'object'
                                && typeof prop['chart.errorbars'][i] === 'object'
                                && !RG.isNull(prop['chart.errorbars'][i])
                                && typeof prop['chart.errorbars'][i][0] === 'number'
                            ) ? prop['chart.errorbars'][i][0]  : 0
                        )
                    );
                }







                this.scale2 = RGraph.getScale2(this, {
                    'max':this.max,
                    'min':prop['chart.ymin'],
                    'scale.thousand':prop['chart.scale.thousand'],
                    'scale.point':prop['chart.scale.point'],
                    'scale.decimals':prop['chart.scale.decimals'],
                    'ylabels.count':prop['chart.ylabels.count'],
                    'scale.round':prop['chart.scale.round'],
                    'units.pre': prop['chart.units.pre'],
                    'units.post': prop['chart.units.post']
                });

                this.max = this.scale2.max;
            }

            /**
             * if the chart is adjustable fix the scale so that it doesn't change.
             */
            if (prop['chart.adjustable'] && !prop['chart.ymax']) {
                this.Set('chart.ymax', this.scale2.max);
            }

            /**
             * Draw horizontal bars here
             */
            if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {
                RGraph.DrawBars(this);
            }

            var variant = prop['chart.variant'];

            /**
             * Draw the 3D axes is necessary
             */
            if (variant === '3d') {
                RG.draw3DAxes(this);
            }

            /**
             * Get the variant once, and draw the bars, be they regular, stacked or grouped
             */

                // Get these variables outside of the loop
            var xaxispos      = prop['chart.xaxispos'],
                width         = (ca.width - this.gutterLeft - this.gutterRight ) / this.data.length,
                orig_height   = height,
                hmargin       = prop['chart.hmargin'],
                shadow        = prop['chart.shadow'],
                shadowColor   = prop['chart.shadow.color'],
                shadowBlur    = prop['chart.shadow.blur'],
                shadowOffsetX = prop['chart.shadow.offsetx'],
                shadowOffsetY = prop['chart.shadow.offsety'],
                strokeStyle   = prop['chart.strokecolor'],
                colors        = prop['chart.colors'],
                sequentialColorIndex = 0

            var height;

            for (i=0,len=this.data.length; i<len; i+=1) {





                // Work out the height
                //The width is up outside the loop
                if (RG.arraySum(this.data[i]) < 0) {
                    var height = (RG.arraySum(this.data[i]) + this.scale2.min)  / (this.scale2.max - this.scale2.min);
                } else {
                    var height = (RG.arraySum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min);
                }

                height *= ma.abs(this.getYCoord(this.scale2.max) - this.getYCoord(this.scale2.min));






                var x = (i * width) + this.gutterLeft;
                var y = xaxispos == 'center' ? ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - height
                    : ca.height - height - this.gutterBottom;

                // xaxispos is top
                if (xaxispos == 'top') {
                    y = this.gutterTop + ma.abs(height);
                }


                // Account for negative lengths - Some browsers don't like a negative value
                if (height < 0) {
                    y += height;
                    height = ma.abs(height);
                }






                /**
                 * Turn on the shadow if need be
                 */
                if (shadow) {
                    co.shadowColor   = shadowColor;
                    co.shadowBlur    = shadowBlur;
                    co.shadowOffsetX = shadowOffsetX;
                    co.shadowOffsetY = shadowOffsetY;
                }

                /**
                 * Draw the bar
                 */
                co.beginPath();
                if (typeof this.data[i] == 'number') {


                    // If the Y axis is offset change the bar start (the top of the bar)
                    if (xaxispos === 'bottom' && prop['chart.ymin'] < 0) {
                        if (this.data[i] >= 0) {
                            height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));
                        } else {
                            y = this.getYCoord(0);
                            height = ma.abs(this.getYCoord(0) - this.getYCoord(this.data[i]));
                        }
                    }

                    var barWidth = width - (2 * hmargin);

                    /**
                     * Check for a negative bar width
                     */
                    if (barWidth < 0) {
                        alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                    }

                    // Set the fill color
                    co.strokeStyle = strokeStyle;
                    co.fillStyle = colors[0];

                    /**
                     * Sequential colors
                     */
                    if (prop['chart.colors.sequential']) {
                        co.fillStyle = colors[i];
                    }

                    if (variant == 'sketch') {

                        co.lineCap = 'round';

                        var sketchOffset = 3;

                        co.beginPath();

                        co.strokeStyle = colors[0];

                        /**
                         * Sequential colors
                         */
                        if (prop['chart.colors.sequential']) {
                            co.strokeStyle = colors[i];
                        }

                        // Left side
                        co.moveTo(x + hmargin + 2, y + height - 2);
                        co.lineTo(x + hmargin -    1, y - 4);

                        // The top
                        co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));
                        co.bezierCurveTo(
                            x + ((hmargin + width) * 0.33),
                            y + 15 + (this.data[i] < 0 ? height - 10: 0),
                            x + ((hmargin + width) * 0.66),
                            y + 5 + (this.data[i] < 0 ? height - 10 : 0),x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0)
                        );


                        // The right side
                        co.moveTo(x + hmargin + width - 5, y  - 5);
                        co.lineTo(x + hmargin + width - 3, y + height - 3);

                        if (prop['chart.variant.sketch.verticals']) {
                            for (var r=0.2; r<=0.8; r+=0.2) {
                                co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - (r * width),y - 1);
                                co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - (r * width), y + height + (r == 0.2 ? 1 : -2));
                            }
                        }

                        co.stroke();

                        // Regular bar
                    } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {

                        if (RGraph.ISOLD && shadow) {
                            this.DrawIEShadow([x + hmargin, y, barWidth, height]);
                        }

                        if (variant == 'glass') {
                            RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                            RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                        } else {
                            // On 9th April 2013 these two were swapped around so that the stroke happens SECOND so that any
                            // shadow that is cast by the fill does not overwrite the stroke

                            co.beginPath();
                            co.rect(x + hmargin, y, barWidth, height);
                            co.fill();

                            // Turn the shadow off so that the stroke doesn't cast any "extra" shadow
                            // that would show inside the bar
                            RG.NoShadow(this);

                            co.beginPath();
                            co.rect(x + hmargin, y, barWidth, height);
                            co.stroke();
                        }

                        // 3D effect
                        if (variant == '3d') {

                            var prevStrokeStyle = co.strokeStyle;
                            var prevFillStyle   = co.fillStyle;

                            // Draw the top (if the value is positive - otherwise there's no point)
                            if (this.data[i] >= 0) {
                                co.beginPath();
                                co.moveTo(x + hmargin, y);
                                co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                                co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(x + hmargin + barWidth, y);
                                co.closePath();

                                co.stroke();
                                co.fill();
                            }

                            // Draw the right hand side
                            co.beginPath();
                            co.moveTo(x + hmargin + barWidth, y);
                            co.lineTo(
                                x + hmargin + barWidth + prop['chart.variant.threed.offsetx'],
                                this.data[i] < 0 && xaxispos === 'bottom' ?
                                    this.getYCoord(0) : (
                                        this.data[i] < 0 && (y - prop['chart.variant.threed.offsety'])
                                        < (this.gutterTop + this.halfgrapharea)

                                            ?

                                            (this.gutterTop + this.halfgrapharea)

                                            : (y - prop['chart.variant.threed.offsety']))
                            );

                            co.lineTo(
                                x + hmargin + barWidth + prop['chart.variant.threed.offsetx'],


                                this.data[i] < 0 && (y - prop['chart.variant.threed.offsety'] + height) < (this.gutterTop + this.getYCoord(0))
                                    ? this.getYCoord(this.data[i]) - prop['chart.variant.threed.offsety']
                                    : (this.data[i] > 0 ?
                                            y - prop['chart.variant.threed.offsety'] + height :
                                            ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom)
                                    )
                            );
                            co.lineTo(x + hmargin + barWidth, y + height);
                            co.closePath();
                            co.stroke();
                            co.fill();




                            // Draw the lighter top section
                            if (this.data[i] > 0) {
                                co.beginPath();
                                co.fillStyle = 'rgba(255,255,255,0.5)';
                                co.moveTo(x + hmargin, y);
                                co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                                co.lineTo(x + hmargin + prop['chart.variant.threed.offsetx'] + barWidth, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(x + hmargin + barWidth, y);
                                co.lineTo(x + hmargin, y);
                                co.closePath();
                                co.stroke();
                                co.fill();
                            }




                            // Draw the darker right side section
                            co.beginPath();
                            co.fillStyle = 'rgba(0,0,0,0.4)';
                            // TL
                            co.moveTo(x + hmargin + barWidth, y);

                            // TR
                            co.lineTo(
                                x + hmargin + barWidth + prop['chart.variant.threed.offsetx'],
                                this.data[i] < 0 && xaxispos === 'bottom' ? this.getYCoord(0) : (this.data[i] < 0 && (y - prop['chart.variant.threed.offsety']) < (this.gutterTop + this.halfgrapharea) ? (this.gutterTop + this.halfgrapharea) : y - prop['chart.variant.threed.offsety'])
                            );

                            // BR
                            co.lineTo(
                                x + hmargin + barWidth + prop['chart.variant.threed.offsetx'],

                                this.data[i] < 0 && (y - prop['chart.variant.threed.offsety'] + height) < this.getYCoord(0)
                                    ? this.getYCoord(0)
                                    : this.data[i] > 0 ? y - prop['chart.variant.threed.offsety'] + height : ma.min(y - prop['chart.variant.threed.offsety'] + height, ca.height - this.gutterBottom)
                            );
                            // BL
                            co.lineTo(x + hmargin + barWidth, y + height);
                            co.lineTo(x + hmargin + barWidth, y);
                            co.closePath();

                            co.stroke();
                            co.fill();

                            co.strokeStyle = prevStrokeStyle;
                            co.fillStyle   = prevFillStyle;

                            // Glass variant
                        } else if (variant == 'glass') {

                            var grad = co.createLinearGradient(x + hmargin,y,x + hmargin + (barWidth / 2),y);
                            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                            grad.addColorStop(1, 'rgba(255,255,255,0.5)');

                            co.beginPath();
                            co.fillStyle = grad;
                            co.fillRect(x + hmargin + 2,y + (this.data[i] > 0 ? 2 : 0),(barWidth / 2) - 2,height - 2);
                            co.fill();
                        }


                        // Dot chart
                    } else if (variant == 'dot') {

                        co.beginPath();
                        co.moveTo(x + (width / 2), y);
                        co.lineTo(x + (width / 2), y + height);
                        co.stroke();

                        co.beginPath();
                        co.fillStyle = this.properties['chart.colors'][i];
                        co.arc(x + (width / 2), y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);

                        // Set the colour for the dots
                        co.fillStyle = prop['chart.colors'][0];

                        /**
                         * Sequential colors
                         */
                        if (prop['chart.colors.sequential']) {
                            co.fillStyle = colors[i];
                        }

                        co.stroke();
                        co.fill();



                        // Unknown variant type
                    } else {
                        alert('[BAR] Warning! Unknown chart.variant: ' + variant);
                    }

                    this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);

                    if (typeof this.coords2[i] == 'undefined') {
                        this.coords2[i] = [];
                    }
                    this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);


                    /**
                     * Stacked bar
                     */
                } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {

                    if (this.scale2.min) {
                        alert("[ERROR] Stacked Bar charts with a Y min are not supported");
                    }

                    var barWidth     = width - (2 * hmargin);
                    var redrawCoords = [];// Necessary to draw if the shadow is enabled
                    var startY       = 0;
                    var dataset      = this.data[i];

                    /**
                     * Check for a negative bar width
                     */
                    if (barWidth < 0) {
                        alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                    }

                    for (j=0; j<dataset.length; ++j) {

                        // Stacked bar chart and X axis pos in the middle - poitless since negative values are not permitted
                        if (xaxispos == 'center') {
                            alert("[BAR] It's pointless having the X axis position at the center on a stacked bar chart.");
                            return;
                        }

                        // Negative values not permitted for the stacked chart
                        if (this.data[i][j] < 0) {
                            alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');
                            return;
                        }

                        /**
                         * Set the fill and stroke colors
                         */
                        co.strokeStyle = strokeStyle
                        co.fillStyle = colors[j];

                        if (prop['chart.colors.reverse']) {
                            co.fillStyle = colors[this.data[i].length - j - 1];
                        }

                        if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                            co.fillStyle = colors[sequentialColorIndex++];
                        } else if (prop['chart.colors.sequential']) {
                            co.fillStyle = colors[sequentialColorIndex - 1];
                        }

                        var height = (dataset[j] / this.scale2.max) * (ca.height - this.gutterTop - this.gutterBottom );

                        // If the X axis pos is in the center, we need to half the  height
                        if (xaxispos == 'center') {
                            height /= 2;
                        }

                        var totalHeight = (RGraph.array_sum(dataset) / this.scale2.max) * (ca.height - hmargin - this.gutterTop - this.gutterBottom);

                        /**
                         * Store the coords for tooltips
                         */
                        this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);
                        if (typeof this.coords2[i] == 'undefined') {
                            this.coords2[i] = [];
                        }
                        this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);

                        // MSIE shadow
                        if (RGraph.ISOLD && shadow) {
                            this.DrawIEShadow([x + hmargin, y, width - (2 * hmargin), height + 1]);
                        }

                        if (height > 0) {
                            co.strokeRect(x + hmargin, y, width - (2 * hmargin), height);
                            co.fillRect(x + hmargin, y, width - (2 * hmargin), height);
                        }


                        if (j == 0) {
                            var startY = y;
                            var startX = x;
                        }

                        /**
                         * Store the redraw coords if the shadow is enabled
                         */
                        if (shadow) {
                            redrawCoords.push([x + hmargin, y, width - (2 * hmargin), height, co.fillStyle]);
                        }

                        /**
                         * Stacked 3D effect
                         */
                        if (variant == '3d') {

                            var prevFillStyle = co.fillStyle;
                            var prevStrokeStyle = co.strokeStyle;


                            // Draw the top side
                            if (j == 0) {
                                co.beginPath();
                                co.moveTo(startX + hmargin, y);
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + barWidth + hmargin, y);
                                co.closePath();

                                co.fill();
                                co.stroke();
                            }

                            // Draw the side section
                            co.beginPath();
                            co.moveTo(startX + barWidth + hmargin, y);
                            co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);
                            co.lineTo(startX + barWidth + hmargin , y + height);
                            co.closePath();

                            co.fill();
                            co.stroke();

                            // Draw the lighter top side
                            if (j == 0) {
                                co.fillStyle = 'rgba(255,255,255,0.5)';
                                co.beginPath();
                                co.moveTo(startX + hmargin, y);
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + hmargin, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + barWidth + hmargin, y - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + barWidth + hmargin, y);
                                co.closePath();

                                co.fill();
                                co.stroke();
                            }

                            // Draw the darker side section
                            co.fillStyle = 'rgba(0,0,0,0.4)';
                            co.beginPath();
                            co.moveTo(startX + barWidth + hmargin, y);
                            co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety']);
                            co.lineTo(startX + barWidth + hmargin + prop['chart.variant.threed.offsetx'], y - prop['chart.variant.threed.offsety'] + height);
                            co.lineTo(startX + barWidth + hmargin , y + height);
                            co.closePath();

                            co.fill();
                            co.stroke();

                            co.strokeStyle = prevStrokeStyle;
                            co.fillStyle = prevFillStyle;
                        }

                        y += height;
                    }



                    /**
                     * Redraw the bars if the shadow is enabled due to hem being drawn from the bottom up, and the
                     * shadow spilling over to higher up bars
                     */
                    if (shadow) {

                        RGraph.NoShadow(this);

                        for (k=0; k<redrawCoords.length; ++k) {
                            co.strokeStyle = strokeStyle;
                            co.fillStyle = redrawCoords[k][4];
                            co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);
                            co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);

                            co.stroke();
                            co.fill();
                        }

                        // Reset the redraw coords to be empty
                        redrawCoords = [];
                    }

                    /**
                     * Grouped bar
                     */
                } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {

                    var redrawCoords = [];
                    co.lineWidth = prop['chart.linewidth'];

                    for (j=0; j<this.data[i].length; ++j) {

                        // Set the fill and stroke colors
                        co.strokeStyle = strokeStyle;
                        co.fillStyle   = colors[j];

                        /**
                         * Sequential colors
                         */
                        if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                            co.fillStyle = colors[sequentialColorIndex++];
                        } else if (prop['chart.colors.sequential']) {
                            co.fillStyle = colors[sequentialColorIndex - 1];
                        }

                        var individualBarWidth = (width - (2 * hmargin)) / this.data[i].length;
                        var height = ((this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : (-1 * this.scale2.min) )) / (this.scale2.max - this.scale2.min) ) * (ca.height - this.gutterTop - this.gutterBottom );
                        var groupedMargin = prop['chart.hmargin.grouped'];
                        var startX = x + hmargin + (j * individualBarWidth);

                        /**
                         * Check for a negative bar width
                         */
                        if (individualBarWidth < 0) {
                            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                        }

                        // If the X axis pos is in the center, we need to half the  height
                        if (xaxispos == 'center') {
                            height /= 2;
                        }

                        /**
                         * Determine the start positioning for the bar
                         */
                        if (xaxispos == 'top') {
                            var startY = this.gutterTop;
                            var height = Math.abs(height);

                        } else if (xaxispos == 'center') {
                            var startY = this.gutterTop + (this.grapharea / 2) - height;

                        } else {
                            var startY = this.getYCoord(0);//ca.height - this.gutterBottom - height;
                            var height = ma.abs(ma.abs(this.getYCoord(this.data[i][j])) - this.getYCoord(0));

                            if (this.data[i][j] >= 0) {
                                startY -= height;
                            }

                        }

                        co.strokeRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
                        co.fillRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
                        y += height;



                        /**
                         * Grouped 3D effect
                         */
                        if (variant == '3d') {

                            var prevFillStyle   = co.fillStyle;
                            var prevStrokeStyle = co.strokeStyle;
                            var hmarginGrouped  = prop['chart.hmargin.grouped'];

                            // Draw the top side
                            if (this.data[i][j]  >= 0) {

                                co.beginPath();
                                co.moveTo(startX + hmarginGrouped, startY);
                                co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);
                                co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);
                                co.closePath();
                                co.fill();
                                co.stroke();
                            }

                            // Draw the side section
                            co.beginPath();
                            co.moveTo(startX + individualBarWidth - hmarginGrouped - 1, startY);
                            co.lineTo(
                                startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'],
                                this.data[i][j] < 0 ? (this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety']) : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']
                            );

                            co.lineTo(
                                startX + individualBarWidth - hmarginGrouped + prop['chart.variant.threed.offsetx'],
                                this.data[i][j] < 0 && (startY + height - prop['chart.variant.threed.offsety']) < (this.gutterTop + this.halfgrapharea) ? (this.gutterTop + this.halfgrapharea) : (startY + height - prop['chart.variant.threed.offsety'])
                            );
                            co.lineTo(startX + individualBarWidth - hmarginGrouped - 1, startY + height);
                            co.closePath();
                            co.fill();
                            co.stroke();


                            // Draw the lighter top side - but only if the current value is positive
                            if (this.data[i][j] >= 0) {
                                co.fillStyle = 'rgba(255,255,255,0.5)';
                                co.beginPath();
                                // BL
                                co.moveTo(startX + hmarginGrouped, startY);

                                // BR
                                co.lineTo(startX + hmarginGrouped + prop['chart.variant.threed.offsetx'], startY - prop['chart.variant.threed.offsety']);

                                // TR
                                co.lineTo(startX + prop['chart.variant.threed.offsetx'] + individualBarWidth - hmarginGrouped, startY - prop['chart.variant.threed.offsety']);

                                // TL
                                co.lineTo(startX + individualBarWidth - hmarginGrouped, startY);
                                co.closePath();

                                co.fill();
                                co.stroke();
                            }

                            // Draw the darker side section
                            co.fillStyle = 'rgba(0,0,0,0.4)';
                            co.beginPath();
                            // TL corner
                            co.moveTo(
                                startX + individualBarWidth - hmarginGrouped,
                                startY
                            );


                            co.lineTo(
                                startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped,
                                this.data[i][j] < 0 ? (this.getYCoord(0) + ma.abs(height) - prop['chart.variant.threed.offsety']) : this.getYCoord(0) - height - prop['chart.variant.threed.offsety']
                            );

                            // TR corner
                            co.lineTo(
                                startX + individualBarWidth + prop['chart.variant.threed.offsetx'] - hmarginGrouped,
                                this.data[i][j] < 0 && (startY + height - 5) < (this.gutterTop + this.halfgrapharea) ? (this.gutterTop + this.halfgrapharea) : (startY + height - prop['chart.variant.threed.offsety'])
                            );

                            // TL corner
                            co.lineTo(startX + individualBarWidth - hmarginGrouped, startY + height);
                            co.closePath();

                            co.fill();
                            co.stroke();

                            co.strokeStyle = prevStrokeStyle;
                            co.fillStyle   = prevFillStyle;
                        }

                        if (height < 0) {
                            height = Math.abs(height);
                            startY = startY - height;
                        }

                        this.coords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);
                        if (typeof this.coords2[i] == 'undefined') {
                            this.coords2[i] = [];
                        }

                        this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);

                        // Facilitate shadows going to the left
                        if (prop['chart.shadow']) {
                            redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height, co.fillStyle]);
                        }
                    }







                    /**
                     * Redraw the bar if shadows are going to the left
                     */
                    if (redrawCoords.length) {

                        RGraph.NoShadow(this);

                        co.lineWidth = prop['chart.linewidth'];

                        co.beginPath();
                        for (var j=0; j<redrawCoords.length; ++j) {

                            co.fillStyle   = redrawCoords[j][4];
                            co.strokeStyle = prop['chart.strokecolor'];

                            co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                            co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                        }
                        co.fill();
                        co.stroke();

                        redrawCoords = [];
                    }
                } else {
                    this.coords.push([]);
                }

                co.closePath();
            }

            // If 3D, redraw the right hand Y axis
            if (prop['chart.variant'] === '3d' && prop['chart.yaxispos'] === 'right') {
                RG.draw3DYAxis(this);
            }





            /**
             * Turn off any shadow
             */
            RGraph.noShadow(this);
        };



    /**
     * Draws the labels for the graph
     */
    this.drawLabels =
        this.DrawLabels = function ()
        {
            var context = co;

            var text_angle = prop['chart.text.angle'],
                text_size  = prop['chart.text.size'],
                labels     = prop['chart.labels'];


            // Draw the Y axis labels:
            if (prop['chart.ylabels']) {
                if (prop['chart.xaxispos'] == 'top')    this.Drawlabels_top();
                if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();
                if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();
            }

            /**
             * The X axis labels
             */
            if (typeof(labels) == 'object' && labels) {

                var yOffset = Number(prop['chart.labels.offsety']),
                    xOffset = Number(prop['chart.labels.offsetx']),
                    bold    = prop['chart.labels.bold']

                /**
                 * Text angle
                 */
                if (prop['chart.text.angle'] != 0) {
                    var valign =  'center';
                    var halign =  'right';
                    var angle  = 0 - prop['chart.text.angle'];
                } else {
                    var valign =  'top';
                    var halign =  'center';
                    var angle  = 0;
                }

                // Draw the X axis labels
                co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];
                // How wide is each bar
                var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;

                // Reset the xTickGap
                xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length

                // Draw the X tickmarks
                var i=0;
                var font = prop['chart.text.font'];
                for (x=this.gutterLeft + (xTickGap / 2); x<=ca.width - this.gutterRight; x+=xTickGap) {
                    RG.text2(this, {
                        'font': font,
                        'size': text_size,
                        'x': x + xOffset,
                        'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop + yOffset - 5: (ca.height - this.gutterBottom) + yOffset + 3,
                        'bold': bold,
                        'text': String(labels[i++]),
                        'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign,
                        'halign': halign,
                        'tag':'label',
                        'marker':false,
                        'angle':angle,
                        'tag': 'labels'
                    });
                }
            }
            /**
             * Draw above labels
             */
            this.drawAboveLabels();
        };



    /**
     * Draws the X axis at the top
     */
    this.drawlabels_top =
        this.Drawlabels_top = function ()
        {
            var ca   = this.canvas;
            var co   = this.context;
            var prop = this.properties;

            co.beginPath();
            co.fillStyle   = prop['chart.text.color'];
            co.strokeStyle = 'black';

            if (prop['chart.xaxispos'] == 'top') {

                var context    = co;
                var text_size  = prop['chart.text.size'];
                var units_pre  = prop['chart.units.pre'];
                var units_post = prop['chart.units.post'];
                var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                var font       = prop['chart.text.font'];
                var numYLabels = prop['chart.ylabels.count'];
                var ymin       = prop['chart.ymin'];
                var offsetx     = prop['chart.ylabels.offsetx'];
                var offsety     = prop['chart.ylabels.offsety'];

                if (prop['chart.ylabels.inside'] == true) {
                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                    var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                    var boxed = true;
                } else {
                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                    var boxed = false;
                }

                /**
                 * Draw specific Y labels here so that the local variables can be reused
                 */
                if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {

                    var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);
                    var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                    for (var i=0; i<labels.length; ++i) {

                        var y = this.gutterTop + (grapharea * (i / labels.length)) + (grapharea / labels.length);

                        RG.text2(this, {
                            'font': font,
                            'size': text_size,
                            'x': xpos + offsetx,
                            'y': y + offsety,
                            'text': String(labels[i]),
                            'valign': 'center',
                            'halign': align,
                            'bordered':boxed,
                            'tag': 'scale'
                        });
                    }

                    return;
                }







                /**
                 * Draw the scale
                 */
                var labels = this.scale2.labels;
                for (var i=0; i<labels.length; ++i) {
                    RGraph.Text2(this, {
                        'font': font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':this.gutterTop + ((this.grapharea / labels.length) * (i + 1)) + offsety,
                        'text': '-' + labels[i],
                        'valign': 'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag':'scale'
                    });
                }








                /**
                 * Show the minimum value if its not zero
                 */
                if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {

                    RGraph.Text2(this, {
                        'font': font,
                        'size': text_size,
                        'x': xpos + offsetx,
                        'y': this.gutterTop + offsety,
                        'text': (this.scale2.min != 0 ? '-' : '') + RGraph.numberFormat(this,(this.scale2.min.toFixed((this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']))), units_pre, units_post),
                        'valign': 'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag': 'scale'
                    });
                }

            }

            co.fill();
        };



    /**
     * Draws the X axis in the middle
     */
    this.drawlabels_center =
        this.Drawlabels_center = function ()
        {
            var ca   = this.canvas;
            var co   = this.context;
            var prop = this.properties;

            var font       = prop['chart.text.font'];
            var numYLabels = prop['chart.ylabels.count'];

            co.fillStyle = prop['chart.text.color'];

            if (prop['chart.xaxispos'] == 'center') {

                /**
                 * Draw the top labels
                 */
                var text_size  = prop['chart.text.size'];
                var units_pre  = prop['chart.units.pre'];
                var units_post = prop['chart.units.post'];
                var context = co;
                var align   = '';
                var xpos    = 0;
                var boxed   = false;
                var ymin    = prop['chart.ymin'];
                var offsetx = prop['chart.ylabels.offsetx'];
                var offsety = prop['chart.ylabels.offsety'];

                co.fillStyle   = prop['chart.text.color'];
                co.strokeStyle = 'black';

                if (prop['chart.ylabels.inside'] == true) {
                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                    var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                    var boxed = true;
                } else {
                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                    var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                    var boxed = false;
                }












                /**
                 * Draw specific Y labels here so that the local variables can be reused
                 */
                if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {

                    var labels    = prop['chart.ylabels.specific'];
                    var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                    // Draw the top halves labels
                    for (var i=0; i<labels.length; ++i) {

                        var y = this.gutterTop + ((grapharea / 2) / (labels.length - 1)) * i;

                        RGraph.Text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':xpos + offsetx,
                            'y':y + offsety,
                            'text':String(labels[i]),
                            'valign':'center',
                            'halign':align,
                            'bordered':boxed,
                            'tag': 'scale'
                        });
                    }

                    // Draw the bottom halves labels
                    for (var i=labels.length-1; i>=1; --i) {

                        var y = this.gutterTop  + (grapharea * (i / ((labels.length - 1) * 2) )) + (grapharea / 2);

                        RG.Text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':xpos + offsetx,
                            'y':y + offsety,
                            'text':String(labels[labels.length - i - 1]),
                            'valign':'center',
                            'halign':align,
                            'bordered':boxed,
                            'tag': 'scale'
                        });
                    }

                    return;
                }










                /**
                 * Draw the top halfs labels
                 */
                for (var i=0; i<this.scale2.labels.length; ++i) {
                    var y    = this.gutterTop + this.halfgrapharea - ((this.halfgrapharea / numYLabels) * (i + 1));
                    var text = this.scale2.labels[i];
                    RG.Text2(this, {
                        'font':font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':y + offsety,
                        'text':
                        text,
                        'valign':
                            'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag':'scale'
                    });
                }

                /**
                 * Draw the bottom halfs labels
                 */
                for (var i=(this.scale2.labels.length - 1); i>=0; --i) {
                    var y = this.gutterTop + ((this.halfgrapharea / numYLabels) * (i + 1)) + this.halfgrapharea;
                    var text = this.scale2.labels[i];
                    RG.Text2(this, {
                        'font':font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':y + offsety,
                        'text': '-' + text,
                        'valign':'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag':'scale'
                    });
                }





                /**
                 * Show the minimum value if its not zero
                 */
                if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {
                    RG.Text2(this, {
                        'font':font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':this.gutterTop + this.halfgrapharea + offsety,
                        'text': RG.number_format(this,(this.scale2.min.toFixed((this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']))), units_pre, units_post),
                        'valign':'center',
                        'valign':'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag':'scale'
                    });
                }
            }
        };




    /**
     * Draws the X axdis at the bottom (the default)
     */
    this.drawlabels_bottom =
        this.Drawlabels_bottom = function ()
        {
            var text_size  = prop['chart.text.size'],
                units_pre  = prop['chart.units.pre'],
                units_post = prop['chart.units.post'],
                context    = this.context,
                align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left',
                font       = prop['chart.text.font'],
                numYLabels = prop['chart.ylabels.count'],
                ymin       = prop['chart.ymin'],
                offsetx    = prop['chart.ylabels.offsetx'],
                offsety    = prop['chart.ylabels.offsety']

            co.beginPath();

            co.fillStyle   = prop['chart.text.color'];
            co.strokeStyle = 'black';

            if (prop['chart.ylabels.inside'] == true) {
                var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                var boxed = true;
            } else {
                var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                var boxed = false;
            }

            /**
             * Draw specific Y labels here so that the local variables can be reused
             */
            if (prop['chart.ylabels.specific'] && typeof(prop['chart.ylabels.specific']) == 'object') {

                var labels = prop['chart.ylabels.specific'];
                var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                for (var i=0; i<labels.length; ++i) {
                    var y = this.gutterTop + (grapharea * (i / (labels.length - 1)));

                    RGraph.Text2(this, {
                        'font':font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':y + offsety,
                        'text': labels[i],
                        'valign':'center',
                        'halign': align,
                        'bordered': boxed,
                        'tag':'scale'
                    });
                }

                return;
            }

            var gutterTop      = this.gutterTop;
            var halfTextHeight = this.halfTextHeight;
            var scale          = this.scale;


            for (var i=0; i<numYLabels; ++i) {
                var text = this.scale2.labels[i];
                RGraph.Text2(this, {
                    'font':font,
                    'size':text_size,
                    'x':xpos + offsetx,
                    'y':this.gutterTop + this.grapharea - ((this.grapharea / numYLabels) * (i+1)) + offsety,
                    'text': text,
                    'valign':'center',
                    'halign': align,
                    'bordered': boxed,
                    'tag':'scale'
                });
            }


            /**
             * Show the minimum value if its not zero
             */
            if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {
                RG.text2(this, {
                    font:font,
                    size:text_size,
                    x:xpos + offsetx,
                    y:ca.height - this.gutterBottom + offsety,
                    text: RG.numberFormat(this,(this.scale2.min.toFixed((this.scale2.min === 0 ? 0 : prop['chart.scale.decimals']))), units_pre, units_post),
                    valign:'center',
                    halign: align,
                    bordered: boxed,
                    tag:'scale'
                });
            }

            co.fill();
        };


    /**
     * This function is used by MSIE only to manually draw the shadow
     *
     * @param array coords The coords for the bar
     */
    this.drawIEShadow =
        this.DrawIEShadow = function (coords)
        {
            var co   = this.context;
            var ca   = this.canvas;
            var prop = this.properties;

            var prevFillStyle = co.fillStyle;
            var offsetx       = prop['chart.shadow.offsetx'];
            var offsety       = prop['chart.shadow.offsety'];

            co.lineWidth = prop['chart.linewidth'];
            co.fillStyle = prop['chart.shadow.color'];
            co.beginPath();

            // Draw shadow here
            co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);

            co.fill();

            // Change the fillstyle back to what it was
            co.fillStyle = prevFillStyle;
        };




    /**
     * Not used by the class during creating the graph, but is used by event handlers
     * to get the coordinates (if any) of the selected bar
     *
     * @param object e The event object
     * @param object   OPTIONAL You can pass in the bar object instead of the
     *                          function using "this"
     */
    this.getShape =
        this.getBar = function (e)
        {
            // This facilitates you being able to pass in the bar object as a parameter instead of
            // the function getting it from itself
            var obj = arguments[1] ? arguments[1] : this;

            var mouseXY = RG.getMouseXY(e),
                mouseX  = mouseXY[0],
                mouseY  = mouseXY[1],
                canvas  = obj.canvas,
                context = obj.context,
                coords  = obj.coords

            for (var i=0,len=coords.length; i<len; i+=1) {

                if (obj.coords[i].length == 0) {
                    continue;
                }

                var left   = coords[i][0],
                    top    = coords[i][1],
                    width  = coords[i][2],
                    height = coords[i][3],
                    prop   = obj.properties

                // Old way of testing
                //if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height)) {

                // Recreate the path/rectangle so that it can be tested
                //  ** DO NOT STROKE OR FILL IT **
                if (prop['chart.tooltips.hotspot.xonly']) {
                    pa2(co,
                        'b r % % % %',
                        left,
                        this.gutterTop,
                        width,
                        ca.height - this.gutterBottom
                    );
                } else {
                    pa2(co,
                        'b r % % % %',
                        left,
                        top,
                        width,
                        height
                    );
                }

                if (co.isPointInPath(mouseX, mouseY)) {


                    if (prop['chart.tooltips']) {
                        var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                    }

                    // Work out the dataset
                    var dataset = 0,
                        idx     = i

                    while (idx >=  (typeof obj.data[dataset] === 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {

                        if (typeof obj.data[dataset] === 'number') {
                            idx -= 1;
                        } else if (obj.data[dataset]) { // Accounts for null being an object
                            idx -= obj.data[dataset].length;
                        } else {
                            idx -= 1;
                        }

                        dataset++;
                    }

                    if (typeof(obj.data[dataset]) == 'number') {
                        idx = null;
                    }


                    return {
                        0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                        'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset
                    };
                }
            }

            return null;
        };




    /**
     * This retrives the bar based on the X coordinate only.
     *
     * @param object e The event object
     * @param object   OPTIONAL You can pass in the bar object instead of the
     *                          function using "this"
     */
    this.getShapeByX = function (e)
    {
        var canvas      = e.target;
        var mouseCoords = RGraph.getMouseXY(e);


        // This facilitates you being able to pass in the bar object as a parameter instead of
        // the function getting it from itself
        var obj = arguments[1] ? arguments[1] : this;


        /**
         * Loop through the bars determining if the mouse is over a bar
         */
        for (var i=0,len=obj.coords.length; i<len; i++) {

            if (obj.coords[i].length == 0) {
                continue;
            }

            var mouseX = mouseCoords[0];
            var mouseY = mouseCoords[1];
            var left   = obj.coords[i][0];
            var top    = obj.coords[i][1];
            var width  = obj.coords[i][2];
            var height = obj.coords[i][3];
            var prop   = obj.properties;

            if (mouseX >= left && mouseX <= (left + width)) {

                if (prop['chart.tooltips']) {
                    var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                }



                return {
                    0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                    'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip
                };
            }
        }

        return null;
    };




    /**
     * When you click on the chart, this method can return the Y value at that point. It works for any point on the
     * chart (that is inside the gutters) - not just points within the Bars.
     *
     * EITHER:
     *
     * @param object arg The event object
     *
     * OR:
     *
     * @param object arg A two element array containing the X and Y coordinates
     */
    this.getValue = function (arg)
    {
        var co   = this.context;
        var ca   = this.canvas;
        var prop = this.properties;

        if (arg.length == 2) {
            var mouseX = arg[0];
            var mouseY = arg[1];
        } else {
            var mouseCoords = RG.getMouseXY(arg);
            var mouseX      = mouseCoords[0];
            var mouseY      = mouseCoords[1];
        }

        if (   mouseY < prop['chart.gutter.top']
            || mouseY > (ca.height - prop['chart.gutter.bottom'])
            || mouseX < prop['chart.gutter.left']
            || mouseX > (ca.width - prop['chart.gutter.right'])
        ) {
            return null;
        }

        if (prop['chart.xaxispos'] == 'center') {
            var value = (((this.grapharea / 2) - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
            value *= 2;

            if (value >= 0) {
                value += this.scale2.min;
            } else {
                value -= this.scale2.min;
            }

        } else if (prop['chart.xaxispos'] == 'top') {
            var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
            value = this.scale2.max - value;
            value = ma.abs(value) * -1;
        } else {
            var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
            value += this.scale2.min;
        }




        return value;
    };


    /**
     * This function can be used when the canvas is clicked on (or similar - depending on the event)
     * to retrieve the relevant Y coordinate for a particular value.
     *
     * @param int value The value to get the Y coordinate for
     */
    this.getYCoord = function (value)
    {

        if (value > this.scale2.max) {
            return null;
        }

        var co   = this.context,
            ca   = this.canvas,
            prop = this.properties;

        var y, xaxispos = prop['chart.xaxispos'];

        if (xaxispos == 'top') {

            // Account for negative numbers
            if (value < 0) {
                value = ma.abs(value);
            }

            y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * this.grapharea;
            y = y + this.gutterTop

        } else if (xaxispos == 'center') {

            y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * (this.grapharea / 2);
            y = (this.grapharea / 2) - y;
            y += this.gutterTop;

        } else {

            if (value < this.scale2.min) {
                value = this.scale2.min;
            }

            y  = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min));
            y *= (ca.height - this.gutterTop - this.gutterBottom);

            y = ca.height - this.gutterBottom - y;
        }

        return y;
    };



    /**
     * Each object type has its own Highlight() function which highlights the appropriate shape
     *
     * @param object shape The shape to highlight
     */
    this.highlight =
        this.Highlight = function (shape)
        {
            if (typeof prop['chart.highlight.style'] === 'function') {
                (prop['chart.highlight.style'])(shape);
            } else {
                // Add the new highlight
                RG.Highlight.Rect(this, shape);
            }
        };



    /**
     * The getObjectByXY() worker method
     */
    this.getObjectByXY = function (e)
    {
        var mouseXY = RG.getMouseXY(e);

        // Adjust the mouse Y coordinate for when the bar chart is
        // a 3D variant
        if (prop['chart.variant'] === '3d') {
            var adjustment = prop['chart.variant.threed.angle'] * mouseXY[0];
            mouseXY[1] -= adjustment;
        }



        if (
            mouseXY[0] >= prop['chart.gutter.left']
            && mouseXY[0] <= (ca.width - prop['chart.gutter.right'])
            && mouseXY[1] >= prop['chart.gutter.top']
            && mouseXY[1] <= (ca.height - prop['chart.gutter.bottom'])
        ) {

            return this;
        }
    };




    /**
     * This method handles the adjusting calculation for when the mouse is moved
     *
     * @param object e The event object
     */
    this.adjusting_mousemove =
        this.Adjusting_mousemove = function (e)
        {
            /**
             * Handle adjusting for the Bar
             */
            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {

                // Rounding the value to the given number of decimals make the chart step
                var value   = Number(this.getValue(e));
                var shape   = RG.Registry.Get('chart.adjusting.shape')

                if (shape) {

                    RG.Registry.Set('chart.adjusting.shape', shape);

                    if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {

                        var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);

                        if (typeof this.data[indexes[0]] == 'number') {
                            this.data[indexes[0]] = Number(value);
                        } else if (!RG.isNull(this.data[indexes[0]])) {
                            this.data[indexes[0]][indexes[1]] = Number(value);
                        }
                    } else if (typeof this.data[shape['index']] == 'number') {

                        this.data[shape['index']] = Number(value);
                    }

                    RG.redrawCanvas(e.target);
                    RG.fireCustomEvent(this, 'onadjust');
                }
            }
        };




    /**
     * This allows for easy specification of gradients
     */
    this.parseColors = function ()
    {
        // Save the original colors so that they can be restored when the canvas is reset
        if (this.original_colors.length === 0) {
            this.original_colors['chart.colors']                = RGraph.array_clone(prop['chart.colors']);
            this.original_colors['chart.key.colors']            = RGraph.array_clone(prop['chart.key.colors']);
            this.original_colors['chart.crosshairs.color']      = prop['chart.crosshairs.color'];
            this.original_colors['chart.highlight.stroke']      = prop['chart.highlight.stroke'];
            this.original_colors['chart.highlight.fill']        = prop['chart.highlight.fill'];
            this.original_colors['chart.text.color']            = prop['chart.text.color'];
            this.original_colors['chart.background.barcolor1']  = prop['chart.background.barcolor1'];
            this.original_colors['chart.background.barcolor2']  = prop['chart.background.barcolor2'];
            this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];
            this.original_colors['chart.background.color']      = prop['chart.background.color'];
            this.original_colors['chart.strokecolor']           = prop['chart.strokecolor'];
            this.original_colors['chart.axis.color']            = prop['chart.axis.color'];
        }


        // chart.colors
        var colors = prop['chart.colors'];
        if (colors) {
            for (var i=0; i<colors.length; ++i) {
                colors[i] = this.parseSingleColorForGradient(colors[i]);
            }
        }

        // chart.key.colors
        var colors = prop['chart.key.colors'];
        if (colors) {
            for (var i=0; i<colors.length; ++i) {
                colors[i] = this.parseSingleColorForGradient(colors[i]);
            }
        }

        prop['chart.crosshairs.color']      = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);
        prop['chart.highlight.stroke']      = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
        prop['chart.highlight.fill']        = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
        prop['chart.text.color']            = this.parseSingleColorForGradient(prop['chart.text.color']);
        prop['chart.background.barcolor1']  = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);
        prop['chart.background.barcolor2']  = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);
        prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);
        prop['chart.background.color']      = this.parseSingleColorForGradient(prop['chart.background.color']);
        prop['chart.strokecolor']           = this.parseSingleColorForGradient(prop['chart.strokecolor']);
        prop['chart.axis.color']            = this.parseSingleColorForGradient(prop['chart.axis.color']);
    };




    /**
     * Use this function to reset the object to the post-constructor state. Eg reset colors if
     * need be etc
     */
    this.reset = function ()
    {
    };



    /**
     * This parses a single color value
     */
    this.parseSingleColorForGradient = function (color)
    {
        if (!color || typeof(color) != 'string') {
            return color;
        }

        if (color.match(/^gradient\((.*)\)$/i)) {

            var parts = RegExp.$1.split(':');

            // Create the gradient
            var grad = co.createLinearGradient(0,ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);

            var diff = 1 / (parts.length - 1);

            grad.addColorStop(0, RG.trim(parts[0]));

            for (var j=1,len=parts.length; j<len; ++j) {
                grad.addColorStop(j * diff, RGraph.trim(parts[j]));
            }
        }

        return grad ? grad : color;
    };




    this.drawBevel =
        this.DrawBevel = function ()
        {
            var coords  = this.coords;
            var coords2 = this.coords2;

            var prop    = this.properties;
            var co      = this.context;
            var ca      = this.canvas;

            if (prop['chart.grouping'] == 'stacked') {
                for (var i=0; i<coords2.length; ++i) {
                    if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {

                        var x = coords2[i][0][0];
                        var y = coords2[i][0][1];
                        var w = coords2[i][0][2];

                        var arr = [];
                        for (var j=0; j<coords2[i].length; ++j) {
                            arr.push(coords2[i][j][3]);
                        }
                        var h = RGraph.array_sum(arr);


                        co.save();

                        co.strokeStyle = 'black';

                        // Clip to the rect
                        co.beginPath();
                        co.rect(x, y, w, h);
                        co.clip();

                        // Add the shadow
                        co.shadowColor = 'black';
                        co.shadowOffsetX = 0;
                        co.shadowOffsetY = 0;
                        co.shadowBlur = 20;

                        co.beginPath();
                        co.rect(x - 3, y - 3, w + 6, h + 100);
                        co.lineWidth = 5;
                        co.stroke();
                        co.restore();
                    }
                }
            } else {

                for (var i=0; i<coords.length; ++i) {
                    if (coords[i]) {

                        var x = coords[i][0];
                        var y = coords[i][1];
                        var w = coords[i][2];
                        var h = coords[i][3];

                        var xaxispos = prop['chart.xaxispos'];
                        var xaxis_ycoord = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;


                        co.save();

                        co.strokeStyle = 'black';

                        // Clip to the rect
                        co.beginPath();
                        co.rect(x, y, w, h);

                        co.clip();

                        // Add the shadow
                        co.shadowColor = 'black';
                        co.shadowOffsetX = 0;
                        co.shadowOffsetY = 0;
                        co.shadowBlur =  20;

                        if (xaxispos == 'top' || (xaxispos == 'center' && (y + h) > xaxis_ycoord)) {
                            y = y - 100;
                            h = h + 100;
                        } else {
                            y = y;
                            h = h + 100;
                        }

                        co.beginPath();
                        co.rect(x - 3, y - 3, w + 6, h + 6);
                        co.lineWidth = 5;
                        co.stroke();
                        co.restore();
                    }
                }
            }
        };




    /**
     * This function handles highlighting an entire data-series for the interactive
     * key
     *
     * @param int index The index of the data series to be highlighted
     */
    this.interactiveKeyHighlight = function (index)
    {
        this.coords2.forEach(function (value, idx, arr)
        {
            if (typeof value[index] == 'object' && value[index]) {

                var x = value[index][0]
                var y = value[index][1]
                var w = value[index][2]
                var h = value[index][3]

                co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];
                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
                co.lineWidth   = 2;
                co.strokeRect(x, y, w, h);
                co.fillRect(x, y, w, h);
            }
        });
    };




    /**
     * Using a function to add events makes it easier to facilitate method chaining
     *
     * @param string   type The type of even to add
     * @param function func
     */
    this.on = function (type, func)
    {
        if (type.substr(0,2) !== 'on') {
            type = 'on' + type;
        }

        if (typeof this[type] !== 'function') {
            this[type] = func;
        } else {
            RG.addCustomEventListener(this, type, func);
        }

        return this;
    };




    /**
     * Draws the above labels
     */
    this.drawAboveLabels = function ()
    {
        var labels    = prop['chart.labels.above'],
            specific  = prop['chart.labels.above.specific'],
            color     = prop['chart.labels.above.color'],
            background= prop['chart.labels.above.background'],
            decimals  = prop['chart.labels.above.decimals'],
            size      = prop['chart.labels.above.size'],
            angle     = -1 * prop['chart.labels.above.angle'],
            unitsPre  = prop['chart.labels.above.units.pre'],
            unitsPost = prop['chart.labels.above.units.post'],
            coords    = this.coords,
            coords2   = this.coords2,
            data      = this.data,
            ldata     = RG.arrayLinearize(this.data),
            offset    = prop['chart.labels.above.offset'],
            text_font = prop['chart.text.font'],
            text_size = prop['chart.text.size'],
            grouping  = prop['chart.grouping']


        // Turn off any shadow
        RG.noShadow(this);

        // Color
        co.fillStyle = typeof color === 'string' ? color : prop['chart.text.color'];


        // This bit draws the text labels that appear above the bars if requested
        if (labels && grouping === 'grouped') {
            for (var i=0,len=data.length,sequentialIndex=0; i<len; i+=1) {

                // Alignment for regular, positive bars
                if (typeof data[i] === 'number' && data[i] >= 0) {

                    var angle  = angle;
                    var halign = (angle ? 'left' : 'center');
                    var valign = angle !== 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + (coords2[i][0][2] / 2),
                        'y': coords2[i][0][1] - offset,
                        'text': specific ? (specific[sequentialIndex] || '') : RG.numberFormat(this, Number(typeof data[i] === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'marker': false,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;






                    // Alignment for regular, negative bars
                } else if (typeof data[i] === 'number' && data[i] < 0) {

                    var angle  = angle;
                    var halign = angle ? 'right' : 'center';
                    var valign = angle !== 0 ? 'center' : 'top';


                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + (coords2[i][0][2] / 2),
                        'y': coords2[i][0][1] + coords2[i][0][3] + offset,
                        'text': specific ? (specific[sequentialIndex] || '') : RG.numberFormat(this, Number(typeof data[i] === 'object' ? data[i][0] : data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;






                    // Alignment for grouped bars
                } else if (typeof data[i] === 'object') {

                    for (var j=0,len2=data[i].length; j<len2; j+=1) {

                        var angle  = angle;
                        var halign = data[i][j] < 0 ? 'right' : 'left';
                        halign = angle === 0 ? 'center' : halign;
                        var valign = data[i][j] < 0 ? 'top' : 'bottom';
                        valign = angle != 0 ? 'center' : valign;

                        RG.text2(this, {
                            'font': text_font,
                            'size': typeof size === 'number' ? size : text_size - 3,
                            'x': coords2[i][j][0] + (coords2[i][j][2] / 2),
                            'y': coords2[i][j][1] + (data[i][j] < 0 ? coords2[i][j][3] + offset: -offset),
                            'text': specific ? (specific[sequentialIndex] || '') : RG.numberFormat(this, Number(data[i][j]).toFixed(decimals), unitsPre, unitsPost),
                            'halign': halign,
                            'valign': valign,
                            'angle': angle,
                            'bounding': true,
                            'bounding.fill': background,
                            'bounding.stroke': 'rgba(0,0,0,0)',
                            'marker': false,
                            'tag': 'labels.above'
                        });
                        sequentialIndex++;
                    }
                }
            }





            /**
             * STACKED bars
             */
        } else if (labels && grouping === 'stacked') {
            for (var i=0,len=data.length,sequentialIndex=0; i<len; i+=1) {
                if (typeof data[i] === 'object') {

                    var angle  = angle;
                    var halign = angle != 0 ? 'left' : 'center';
                    var valign = angle != 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + (coords2[i][0][2] / 2),
                        'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset,
                        'text': specific ? (specific[sequentialIndex] || '') : RG.numberFormat(this, Number(RG.arraySum(data[i])).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex += data[i].length;

                    /**
                     * Regular numbers but in a stacked grouping
                     */
                } else {

                    var angle  = angle;
                    var halign = angle != 0 ? 'left' : 'center';
                    var valign = angle != 0 ? 'center' : 'bottom';

                    RG.text2(this, {
                        'font': text_font,
                        'size': typeof size === 'number' ? size : text_size - 3,
                        'x': coords2[i][0][0] + (coords2[i][0][2] / 2),
                        'y': coords2[i][0][1] + (data[i][0] < 0 ? coords2[i][0][3] : 0) - offset,
                        'text': specific ? (specific[sequentialIndex] || '') : RG.numberFormat(this, Number(data[i]).toFixed(decimals), unitsPre, unitsPost),
                        'halign': halign,
                        'valign': valign,
                        'angle': angle,
                        'bounding': true,
                        'bounding.fill': background,
                        'bounding.stroke': 'rgba(0,0,0,0)',
                        'marker': false,
                        'tag': 'labels.above'
                    });

                    sequentialIndex++;
                }
            }
        }
    };




    /**
     * This function runs once only
     */
    this.firstDrawFunc = function ()
    {
    };




    /**
     * (new) Bar chart Wave effect. This is a rewrite that should be smoother
     * because it just uses a single loop and not setTimeout
     *
     * @param object   OPTIONAL An object map of options. You specify 'frames' here to give the number of frames in the effect
     * @param function OPTIONAL A function that will be called when the effect is complete
     */
    this.wave = function ()
    {
        var obj = this,
            opt = arguments[0] || {},
            labelsAbove = this.get('labelsAbove');

        opt.frames =  opt.frames || 60;
        opt.startFrames = [];
        opt.counters    = [];

        var framesperbar   = opt.frames / 3,
            frame          = -1,
            callback       = arguments[1] || function () {},
            original       = RG.arrayClone(this.original_data);

        //
        // turn off the labelsAbove option whilst animating
        //
        this.set('labelsAbove', false);

        for (var i=0,len=obj.data.length; i<len; i+=1) {
            opt.startFrames[i] = ((opt.frames / 2) / (obj.data.length - 1)) * i;

            if (typeof obj.data[i] === 'object' && obj.data[i]) {
                opt.counters[i] = [];
                for (var j=0; j<obj.data[i].length; j++) {
                    opt.counters[i][j] = 0;
                }
            } else {
                opt.counters[i]    = 0;
            }
        }

        /**
         * This stops the chart from jumping
         */
        obj.draw();
        obj.Set('ymax', obj.scale2.max);
        RG.clear(obj.canvas);

        function iterator ()
        {
            ++frame;

            for (var i=0,len=obj.data.length; i<len; i+=1) {
                if (frame > opt.startFrames[i]) {
                    if (typeof obj.data[i] === 'number') {

                        obj.data[i] = ma.min(
                            ma.abs(original[i]),
                            ma.abs(original[i] * ( (opt.counters[i]++) / framesperbar))
                        );

                        // Make the number negative if the original was
                        if (original[i] < 0) {
                            obj.data[i] *= -1;
                        }
                    } else if (!RG.isNull(obj.data[i])) {
                        for (var j=0,len2=obj.data[i].length; j<len2; j+=1) {

                            obj.data[i][j] = ma.min(
                                ma.abs(original[i][j]),
                                ma.abs(original[i][j] * ( (opt.counters[i][j]++) / framesperbar))
                            );

                            // Make the number negative if the original was
                            if (original[i][j] < 0) {
                                obj.data[i][j] *= -1;
                            }
                        }
                    }
                } else {
                    obj.data[i] = typeof obj.data[i] === 'object' && obj.data[i] ? RG.arrayPad([], obj.data[i].length, 0) : (RG.isNull(obj.data[i]) ? null : 0);
                }
            }


            if (frame >= opt.frames) {

                if (labelsAbove) {
                    obj.set('labelsAbove', true);
                    RG.redraw();
                }

                callback(obj);
            } else {
                RG.redrawCanvas(obj.canvas);
                RG.Effects.updateCanvas(iterator);
            }
        }

        iterator();

        return this;
    };




    /**
     * Color Wave effect. This fades in color sequentially like the wave effect
     * makes the bars grow.
     *
     * @param object   OPTIONAL An object map of options. You specify 'frames'
     *                          here to give the number of frames in the effect
     * @param function OPTIONAL A function that will be called when the effect
     *                          is complete
     */
    this.colorWave = function ()
    {
        var obj = this,
            opt = arguments[0] || {};
        opt.frames =  opt.frames || 60;
        opt.startFrames = [];
        opt.counters    = [],
            colors          = obj.properties['chart.colors'];

        // If just one color is specified and colorsSequential is not, then
        // pad the colors array out
        if (colors.length <= obj.data.length) {
            obj.set('chart.colors.sequential', true);
            colors =  RG.arrayPad(colors, obj.data.length, colors[colors.length - 1]);
        }

        var framesperbar   = opt.frames / 2,
            frame          = -1,
            callback       = arguments[1] || function () {},
            originalColors = RG.arrayClone(obj.properties['chart.colors']);



        for (var i=0,len=originalColors.length; i<len; i+=1) {
            opt.startFrames[i] = ((opt.frames / 2) / (originalColors.length - 1)) * i;
            opt.counters[i]    = 0;
        }


        function iterator ()
        {
            ++frame;

            for (var i=0,len=colors.length; i<len; i+=1) {
                if (frame > opt.startFrames[i] && colors[i].match(/^rgba?\(([0-9 ]+),([0-9 ]+),([0-9 ]+)(,([ 0-9.]+)?)\)/)) {

                    // DO NOT USE SPACES!
                    colors[i] = 'rgba({1},{2},{3},{4})'.format(
                        RegExp.$1,
                        RegExp.$2,
                        RegExp.$3,
                        (frame - opt.startFrames[i]) / framesperbar
                    );
                } else {
                    colors[i] = colors[i].replace(/,[0-9. ]+\)/, ',0)');
                }
            }


            if (frame >= opt.frames) {
                callback(obj);
            } else {
                RG.redrawCanvas(obj.canvas);
                RG.Effects.updateCanvas(iterator);
            }
        }

        iterator();

        return this;
    };




    /**
     * Grow
     *
     * The Bar chart Grow effect gradually increases the values of the bars
     *
     * @param object       An object of options - eg: {frames: 30}
     * @param function     A function to call when the effect is complete
     */
    this.grow = function ()
    {
        // Callback
        var opt         = arguments[0] || {},
            frames      = opt.frames || 30,
            frame       = 0,
            callback    = arguments[1] || function () {},
            obj         = this,
            labelsAbove = this.get('labelsAbove')






        // Go through the data and change string arguments of the format +/-[0-9]
        // to absolute numbers
        if (RG.isArray(opt.data)) {

            var ymax = 0;

            for (var i=0; i<opt.data.length; ++i) {
                if (typeof opt.data[i] === 'object') {
                    for (var j=0; j<opt.data[i].length; ++j) {
                        if (typeof opt.data[i][j] === 'string'&& opt.data[i][j].match(/(\+|\-)([0-9]+)/)) {
                            if (RegExp.$1 === '+') {
                                opt.data[i][j] = this.original_data[i][j] + parseInt(RegExp.$2);
                            } else {
                                opt.data[i][j] = this.original_data[i][j] - parseInt(RegExp.$2);
                            }
                        }

                        ymax = ma.max(ymax, opt.data[i][j]);
                    }
                } else if (typeof opt.data[i] === 'string' && opt.data[i].match(/(\+|\-)([0-9]+)/)) {
                    if (RegExp.$1 === '+') {
                        opt.data[i] = this.original_data[i] + parseInt(RegExp.$2);
                    } else {
                        opt.data[i] = this.original_data[i] - parseInt(RegExp.$2);
                    }
                    ymax = ma.max(ymax, opt.data[i]);
                } else {
                    ymax = ma.max(ymax, opt.data[i]);
                }
            }


            var scale = RG.getScale2(this, {'max':ymax});
            this.Set('chart.ymax', scale.max);
        }






        //
        // turn off the labelsAbove option whilst animating
        //
        this.set('labelsAbove', false);






        // Stop the scale from changing by setting chart.ymax (if it's not already set)
        if (prop['chart.ymax'] == null) {

            var ymax = 0;

            for (var i=0; i<obj.data.length; ++i) {
                if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'stacked') {
                    ymax = ma.max(ymax, ma.abs(RG.arraySum(this.data[i])));

                } else if (RG.isArray(this.data[i]) && prop['chart.grouping'] === 'grouped') {

                    for (var j=0,group=[]; j<this.data[i].length; j++) {
                        group.push(ma.abs(this.data[i][j]));
                    }

                    ymax = ma.max(ymax, ma.abs(RG.arrayMax(group)));

                } else {
                    ymax = ma.max(ymax, ma.abs(this.data[i]));
                }
            }

            var scale = RG.getScale2(this, {'max':ymax});
            this.Set('chart.ymax', scale.max);
        }

        // You can give a ymax to the grow function
        if (typeof opt.ymax === 'number') {
            obj.set('ymax', opt.ymax);
        }



        var iterator = function ()
        {
            var easingMultiplier = RG.Effects.getEasingMultiplier(frames, frame);

            // Alter the Bar chart data depending on the frame
            for (var j=0,len=obj.original_data.length; j<len; ++j) {
                if (typeof obj.data[j] === 'object' && !RG.isNull(obj.data[j])) {
                    for (var k=0,len2=obj.data[j].length; k<len2; ++k) {
                        if (obj.firstDraw || !opt.data) {
                            obj.data[j][k] = easingMultiplier * obj.original_data[j][k];
                        } else if (opt.data && opt.data.length === obj.original_data.length) {
                            var diff    = opt.data[j][k] - obj.original_data[j][k];
                            obj.data[j][k] = (easingMultiplier * diff) + obj.original_data[j][k];
                        }
                    }
                } else {

                    if (obj.firstDraw || !opt.data) {
                        obj.data[j] = easingMultiplier * obj.original_data[j];
                    } else if (opt.data && opt.data.length === obj.original_data.length) {
                        var diff    = opt.data[j] - obj.original_data[j];
                        obj.data[j] = (easingMultiplier * diff) + obj.original_data[j];
                    }
                }
            }




            //RGraph.clear(obj.canvas);
            RG.redrawCanvas(obj.canvas);




            if (frame < frames) {
                frame += 1;

                RG.Effects.updateCanvas(iterator);

                // Call the callback function
            } else {





                // Do some housekeeping if new data was specified thats done in
                // the constructor - but needs to be redone because new data
                // has been specified
                if (RG.isArray(opt.data)) {

                    var linear_data = RG.arrayLinearize(data);

                    for (var i=0; i<linear_data.length; ++i) {
                        if (!obj['$' + i]) {
                            obj['$' + i] = {};
                        }
                    }
                }



                obj.data = data;
                obj.original_data = RG.arrayClone(data);





                if (labelsAbove) {
                    obj.set('labelsAbove', true);
                    RG.redraw();
                }
                callback(obj);
            }
        };

        iterator();

        return this;
    };




    //
    // Draws error-bars for the Bar and Line charts
    //
    this.drawErrorbars = function ()
    {
        var coords = this.coords,
            color = prop['chart.errorbars.color'] || 'black',
            default_halfwidth = ma.min(prop['chart.errorbars.capped.width'], coords[0][2]) / 2,
            x = 0,
            errorbars = prop['chart.errorbars'],
            length = 0;


        // If not capped set the width of the cqap to zero
        if (!prop['chart.errorbars.capped']) {
            prop['chart.errorbars.capped.width'] = 0;
            halfwidth = 0;
        }

        // Set the linewidth
        co.lineWidth = prop['chart.errorbars.linewidth'];




        for (var i=0; i<coords.length; ++i) {


            // Default to black
            color = prop['chart.errorbars.color'] || 'black';

            // Set the perbar linewidth if the fourth option in the array
            // is specified
            if (errorbars[i] && typeof errorbars[i][3] === 'number') {
                co.lineWidth = errorbars[i][3];
            }

            // Set the halfwidth
            var halfwidth = (errorbars[i]&& typeof errorbars[i][4] === 'number') ? errorbars[i][4] / 2 : default_halfwidth;

            if (!prop['chart.errorbars.capped']) {
                halfwidth = 0;
            }



            // Calulate the pixel size
            if (typeof errorbars[i] === 'number') {

                length = ma.abs(this.getYCoord(errorbars[i]) - this.getYCoord(0));

                if (length) {
                    pa2(
                        co,
                        'b m % % l % % l % % l % % s %',
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1],
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1] - length,
                        coords[i][0] + (coords[i][2] / 2) - halfwidth,
                        ma.round(coords[i][1] - length),
                        coords[i][0] + (coords[i][2] / 2) + halfwidth,
                        ma.round(coords[i][1] - length),
                        color
                    );
                }
            } else if (typeof errorbars[i] === 'object' && !RG.isNull(errorbars[i])) {

                var positiveLength = ma.abs(this.getYCoord(errorbars[i][0]) - this.getYCoord(0));

                // Color
                if (typeof errorbars[i][1] === 'string') {
                    color = errorbars[i][1];

                } else if (typeof errorbars[i][2] === 'string') {
                    color = errorbars[i][2];
                }

                // Cap width
                halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : default_halfwidth;

                if (!prop['chart.errorbars.capped']) {
                    halfwidth = 0;
                }

                if (!RG.isNull(errorbars[i][0])) {
                    pa2(
                        co,
                        'b m % % l % % l % % l % % s %',
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1],
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1] - positiveLength,
                        coords[i][0] + (coords[i][2] / 2) - halfwidth,
                        ma.round(coords[i][1] - positiveLength),
                        coords[i][0] + (coords[i][2] / 2) + halfwidth,
                        ma.round(coords[i][1] - positiveLength),
                        color
                    );
                }

                if (typeof errorbars[i][1] === 'number') {

                    var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));

                    pa2(
                        co,
                        'b m % % l % % l % % l % % s %',
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1],
                        coords[i][0] + (coords[i][2] / 2),
                        coords[i][1] + negativeLength,
                        coords[i][0] + (coords[i][2] / 2) - halfwidth,
                        ma.round(coords[i][1] + negativeLength),
                        coords[i][0] + (coords[i][2] / 2) + halfwidth,
                        ma.round(coords[i][1] + negativeLength),
                        color
                    );
                }
            }


            // Reset the perbar linewidth to the default if the fourth option
            // in the array was specified specified
            if (errorbars[i] && typeof errorbars[i][3] === 'number') {
                co.lineWidth = prop['chart.errorbars.linewidth'];
            }
        }
    };




    //
    // A per-object to test whether a particular bar is adjustable or not
    //
    // @param shape The shape object
    //
    this.isAdjustable = function (shape)
    {
        if (RG.isNull(prop['chart.adjustable.only']) || !RG.isArray(prop['chart.adjustable.only'])) {
            return true;
        }

        if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {
            return true;
        }

        return false;
    };




    /**
     * Register the object
     */
    RG.register(this);




    /**
     * This is the 'end' of the constructor so if the first argument
     * contains configuration dsta - handle that.
     */
    if (parseConfObjectForOptions) {
        RG.parseObjectStyleConfig(this, conf.options);
    }
};





/*********************************************************************************************************
 * This is the combined bar and Line class which makes creating bar/line combo charts a little bit easier *
 /*********************************************************************************************************/







RGraph.CombinedChart = function ()
{
    /**
     * Create a default empty array for the objects
     */
    this.objects = [];
    var objects  = [];

    if (RGraph.isArray(arguments[0])) {
        objects = arguments[0];
    } else {

        for (var i=0; i<arguments.length; i+=1) {

            objects[i] = arguments[i];
        }
    }

    for (var i=0; i<objects.length; ++i) {

        this.objects[i] = objects[i];

        /**
         * Set the Line chart gutters to match the Bar chart gutters
         */
        this.objects[i].set({
            gutterLeft:   this.objects[0].get('gutter.left'), // Needs to use the dot form to skirt an IE9 bug
            gutterRight:  this.objects[0].get('gutter.right'), // Needs to use the dot form to skirt an IE9 bug
            gutterTop:    this.objects[0].get('gutter.top'), // Needs to use the dot form to skirt an IE9 bug
            gutterBottom: this.objects[0].get('gutter.bottom') // Needs to use the dot form to skirt an IE9 bug
        });

        if (this.objects[i].type == 'line') {

            var obj = this.objects[i];

            /**
             * Set the line chart hmargin
             */
            obj.set('hmargin', ((this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length) / 2 );


            /**
             * No labels, axes or grid on the Line chart
             */
            obj.set('noaxes', true);
            obj.set('backgroundGrid', false);
            obj.set('ylabels', false);
        }

        /**
         * Resizing
         */
        if (this.objects[i].get('chart.resizable')) {
            var resizable_object = obj;
        }
    }

    /**
     * Resizing
     */
    if (resizable_object) {
        /**
         * This recalculates the Line chart hmargin when the chart is resized
         */
        function myOnresizebeforedraw (obj)
        {
            var gutterLeft  = obj.get('gutterLeft');
            var gutterRight = obj.get('gutterRight');

            obj.set('hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));
        }

        RGraph.AddCustomEventListener(
            resizable_object,
            'onresizebeforedraw',
            myOnresizebeforedraw
        );
    }
};




/**
 * The Add method can be used to add methods to the CombinedChart object.
 */
RGraph.CombinedChart.prototype.add =
    RGraph.CombinedChart.prototype.Add = function (obj)
    {
        this.objects.push(obj);
    };


/**
 * The Draw method goes through all of the objects drawing them (sequentially)
 */
RGraph.CombinedChart.prototype.draw =
    RGraph.CombinedChart.prototype.Draw = function ()
    {
        for (var i=0; i<this.objects.length; ++i) {
            if (this.objects[i].properties['chart.combinedchart.effect']) {

                var options = this.objects[i].properties['chart.combinedchart.effect.options'] ? eval('(' + this.objects[i].properties['chart.combinedchart.effect.options'] + ')') : null;

                (this.objects[i][this.objects[i].properties['chart.combinedchart.effect']])
                (
                    options,
                    this.objects[i].properties['chart.combinedchart.effect.callback']
                )
            } else {
                this.objects[i].draw();
            }
        }
    };